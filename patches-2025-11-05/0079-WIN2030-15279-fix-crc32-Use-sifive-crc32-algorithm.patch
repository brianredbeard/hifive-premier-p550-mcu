From 01c3c1775fa45e4b6054b5a7f4d7052e92845598 Mon Sep 17 00:00:00 2001
From: linmin <linmin@eswincomputing.com>
Date: Sat, 8 Jun 2024 11:48:59 +0800
Subject: [PATCH 079/109] WIN2030-15279:fix(crc32):Use sifive crc32 algorithm

Changelogs:
1.Add sifive_crc32.c which use sifive crc32 algorithm
2.Delete padding bytes in CarrierBoardInfo structure

Change-Id: I3318836059a02e595e26b06617b8838a7c2c85f6
---
 Core/Inc/hf_common.h     |   3 +-
 Core/Inc/sifive_crc32.h  |  21 ++++
 Core/Src/hf_board_init.c |   2 +-
 Core/Src/hf_common.c     | 106 +++++++++---------
 Core/Src/sifive_crc32.c  | 225 +++++++++++++++++++++++++++++++++++++++
 Makefile                 |   1 +
 6 files changed, 303 insertions(+), 55 deletions(-)
 create mode 100644 Core/Inc/sifive_crc32.h
 create mode 100644 Core/Src/sifive_crc32.c

diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index f6442de..1ab5963 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -111,7 +111,6 @@ typedef struct {
 	uint8_t ethernetMAC1[6];	// The MAC of the SOM
 	uint8_t ethernetMAC2[6];	// The MAC of the SOM
 	uint8_t ethernetMAC3[6];	// The MAC of the MCU
-	uint8_t padding[1];		// padding one byte to make the sizeof(CarrierBoardInfo) - sizeof(crc32Checksum) align with 4bytes
 	uint32_t crc32Checksum;
 	// uint8_t padding[4];
 } __attribute__((packed)) CarrierBoardInfo;
@@ -219,7 +218,7 @@ extern UART_HandleTypeDef huart3;
 #define BMC_SOFTWARE_VERSION_MAJOR                   1
 #define BMC_SOFTWARE_VERSION_MINOR                   2
 
-#define MAGIC_NUMBER	0xF15E5045
+#define MAGIC_NUMBER	0x45505EF1
 
 #define AT24C_ADDR (0x50<<1)
 
diff --git a/Core/Inc/sifive_crc32.h b/Core/Inc/sifive_crc32.h
new file mode 100644
index 0000000..17ea8f1
--- /dev/null
+++ b/Core/Inc/sifive_crc32.h
@@ -0,0 +1,21 @@
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef __STM32_CRC32_H
+#define __STM32_CRC32_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include <stdio.h>
+
+/* types ------------------------------------------------------------*/
+
+uint32_t GetCRC32(uint8_t* pbuffer, uint32_t length);
+uint32_t sifive_crc32(const uint8_t *p, uint32_t len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HF_COMMON_H */
diff --git a/Core/Src/hf_board_init.c b/Core/Src/hf_board_init.c
index 577efe2..9132ede 100644
--- a/Core/Src/hf_board_init.c
+++ b/Core/Src/hf_board_init.c
@@ -138,7 +138,7 @@ int board_init(void)
 	MX_RTC_Init();
 	MX_TIM4_Init();
 	// MX_SPI1_Init();
-	MX_CRC_Init();
+	// MX_CRC_Init();
 	// MX_RNG_Init();
 	MX_TIM1_Init();
 	MX_TIM9_Init();
diff --git a/Core/Src/hf_common.c b/Core/Src/hf_common.c
index 1240e0b..103c4f2 100644
--- a/Core/Src/hf_common.c
+++ b/Core/Src/hf_common.c
@@ -3,6 +3,7 @@
 #include <string.h>
 #include "lwip.h"
 #include "hf_common.h"
+#include "sifive_crc32.h"
 
 #include "cmsis_os.h"
 #include "semphr.h"
@@ -34,8 +35,7 @@
 #define esEXIT_CRITICAL(MUTEX)		taskEXIT_CRITICAL()
 #endif
 /* variables ---------------------------------------------------------*/
-static uint32_t gCbinfoArray[CBINFO_MAX_SIZE]; // Store cbinfo to eliminate HAL_CRC_Calculate warning
-static CarrierBoardInfo *pgCarrier_Board_Info = (CarrierBoardInfo *)gCbinfoArray;
+static CarrierBoardInfo gCarrier_Board_Info;
 
 static MCUServerInfo gMCU_Server_Info;
 static SomPwrMgtDIPInfo gSOM_PwgMgtDIP_Info;
@@ -229,10 +229,9 @@ static int write_cbinfo(CarrierBoardInfo *pCarrier_Board_Info, CbinfoPart cbinfo
 	return 0;
 }
 
-static int restore_cbinfo_to_factory(uint32_t *pCbinfoArray)
+static int restore_cbinfo_to_factory(CarrierBoardInfo *pCarrier_Board_Info)
 {
 	char sn[] = "sn1234567890abcdef";
-	CarrierBoardInfo *pCarrier_Board_Info = (CarrierBoardInfo *)pCbinfoArray;
 
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
 
@@ -256,7 +255,7 @@ static int restore_cbinfo_to_factory(uint32_t *pCbinfoArray)
 	pCarrier_Board_Info->ethernetMAC3[4] = MAC_ADDR4;
 	pCarrier_Board_Info->ethernetMAC3[5] = MAC_ADDR5;
 
-	pCarrier_Board_Info->crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)pCbinfoArray, sizeof(CarrierBoardInfo)/4 - 1);
+	pCarrier_Board_Info->crc32Checksum = sifive_crc32((uint8_t *)pCarrier_Board_Info, sizeof(CarrierBoardInfo)/4 - 1);
 #if 0
 	/* write to main partition */
 	write_cbinfo(pCarrier_Board_Info, cbinfo_main);
@@ -291,8 +290,9 @@ static int print_cbinfo(CarrierBoardInfo *pCarrierBoardInfo)
 	memcpy(boardSn, pCarrierBoardInfo->boardSerialNumber, sizeof(pCarrierBoardInfo->boardSerialNumber));
 	eeprom_debug("SN:%s\n", boardSn);
 
-
 	eeprom_debug("manufacturingTestStatus:0x%x\n", pCarrierBoardInfo->manufacturingTestStatus);
+	eeprom_debug("checksum:0x%lx\n", pCarrierBoardInfo->crc32Checksum);
+
 
 	return 0;
 }
@@ -301,53 +301,58 @@ static int get_carrier_board_info(void)
 {
 	int ret = 0;
 	uint32_t crc32Checksum;
-	uint32_t gCbinfoArrayBackup[CBINFO_MAX_SIZE];
-	CarrierBoardInfo *pCbinfoBackup = (CarrierBoardInfo *)gCbinfoArrayBackup;
+	CarrierBoardInfo CbinfoBackup;
 
-	// printf("main offset:0x%d, back offset:%d\n", CARRIER_BOARD_INFO_EEPROM_MAIN_OFFSET, CARRIER_BOARD_INFO_EEPROM_BACKUP_OFFSET);
-	// printf("pgCarrier_Board_Info addr:0x%p, size:%d\n", pgCarrier_Board_Info, sizeof(CarrierBoardInfo));
-	memset((uint8_t *)pgCarrier_Board_Info, 0, sizeof(CarrierBoardInfo));
+	eeprom_debug("&gCarrier_Board_Info addr:0x%p, size:%d\n", &gCarrier_Board_Info, sizeof(CarrierBoardInfo));
+	memset((uint8_t *)&gCarrier_Board_Info, 0, sizeof(CarrierBoardInfo));
 	/* read main partintion */
-	ret = read_cbinfo(pgCarrier_Board_Info, cbinfo_main);
+	ret = read_cbinfo(&gCarrier_Board_Info, cbinfo_main);
 	if(ret) {
 		return -1;
 	}
-	print_cbinfo(pgCarrier_Board_Info);
+	print_cbinfo(&gCarrier_Board_Info);
+	print_data((uint8_t *)&gCarrier_Board_Info, sizeof(CarrierBoardInfo));
 	/* calculate crc32 checksum of main partition */
-	crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)gCbinfoArray, sizeof(CarrierBoardInfo)/4 - 1);
-	if (crc32Checksum != pgCarrier_Board_Info->crc32Checksum) { //main partition is bad
+	crc32Checksum = sifive_crc32((uint8_t *)&gCarrier_Board_Info, sizeof(CarrierBoardInfo)/4 - 1);
+	if (crc32Checksum != gCarrier_Board_Info.crc32Checksum) { //main partition is bad
+		printf("Bad main checksum,0x%lx is NOT equal to calculated value:0x%lx\n", gCarrier_Board_Info.crc32Checksum, crc32Checksum);
+		eeprom_debug("%s:%d\n", __func__, __LINE__);
+		print_data((uint8_t *)&gCarrier_Board_Info, sizeof(CarrierBoardInfo));
 		/* try to read and check the backup partition */
-		ret = read_cbinfo(pgCarrier_Board_Info, cbinfo_backup);
+		ret = read_cbinfo(&gCarrier_Board_Info, cbinfo_backup);
 		if(ret) {
 			return -1;
 		}
-		printf("Bad main checksum,0x%lx is NOT equal to calculated value:0x%lx\n", pgCarrier_Board_Info->crc32Checksum, crc32Checksum);
-		crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)gCbinfoArray, sizeof(CarrierBoardInfo)/4 - 1);
-		if (crc32Checksum != pgCarrier_Board_Info->crc32Checksum) { // backup patition is also bad
+
+		crc32Checksum = sifive_crc32((uint8_t *)&gCarrier_Board_Info, sizeof(CarrierBoardInfo)/4 - 1);
+		if (crc32Checksum != gCarrier_Board_Info.crc32Checksum) { // backup patition is also bad
 			/* restore to factory settings */
-			printf("Bad backup checksum,0x%lx is NOT equal to calculated value:0x%lx\n", pgCarrier_Board_Info->crc32Checksum, crc32Checksum);
-			restore_cbinfo_to_factory(gCbinfoArray);
+			printf("Bad backup checksum,0x%lx is NOT equal to calculated value:0x%lx\n", gCarrier_Board_Info.crc32Checksum, crc32Checksum);
+			restore_cbinfo_to_factory(&gCarrier_Board_Info);
 			printf("Restored cbinfo to factory settings\n");
 		}
 		else { // backup partion is ok
 			/* recover the main partition with the backup value */
 			printf("Recover main with backup settings\n");
-			write_cbinfo(pgCarrier_Board_Info, cbinfo_main);
+			write_cbinfo(&gCarrier_Board_Info, cbinfo_main);
 		}
 	}
 	else { // main partition is ok
 		/* check backup partion, if it's bad, recover it with main value */
-		ret = read_cbinfo(pCbinfoBackup, cbinfo_backup);
+		ret = read_cbinfo(&CbinfoBackup, cbinfo_backup);
 		if(ret) {
 			return -1;
 		}
-		print_cbinfo(pCbinfoBackup);
-		crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)gCbinfoArrayBackup, sizeof(CarrierBoardInfo)/4 - 1);
-		if (crc32Checksum != pCbinfoBackup->crc32Checksum) {
+		print_cbinfo(&CbinfoBackup);
+		crc32Checksum = sifive_crc32((uint8_t *)&CbinfoBackup, sizeof(CarrierBoardInfo)/4 - 1);
+		if (crc32Checksum != CbinfoBackup.crc32Checksum) {
 			/* recover the backup partition with the main value */
-			printf("Bad backup checksum,0x%lx is NOT equal to calculated value:0x%lx\n", pCbinfoBackup->crc32Checksum, crc32Checksum);
+			printf("Bad backup checksum,0x%lx is NOT equal to calculated value:0x%lx\n", CbinfoBackup.crc32Checksum, crc32Checksum);
 			printf("Recover backup with main settings\n");
-			write_cbinfo(pgCarrier_Board_Info, cbinfo_backup);
+			write_cbinfo(&gCarrier_Board_Info, cbinfo_backup);
+		}
+		else {
+			printf("cbinfo checksum ok!!!!\n");
 		}
 	}
 	return 0;
@@ -361,7 +366,6 @@ static int get_mcu_server_info(void)
 
 	memset((uint8_t *)&gMCU_Server_Info, 0, sizeof(MCUServerInfo));
 	eeprom_debug("print MCUServerInfo:\n");
-	print_data((uint8_t *)&gMCU_Server_Info, sizeof(MCUServerInfo));
 	ret = hf_i2c_mem_read(&hi2c1, AT24C_ADDR, MCU_SERVER_INFO_EEPROM_OFFSET,
 				(uint8_t *)&gMCU_Server_Info, sizeof(MCUServerInfo));
 	if(ret) {
@@ -370,14 +374,14 @@ static int get_mcu_server_info(void)
 	}
 	eeprom_debug("print MCUServerInfo:\n");
 	print_data((uint8_t *)&gMCU_Server_Info, sizeof(MCUServerInfo));
-	if ((0 == strlen(gMCU_Server_Info.AdminName)) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
+	if ((0 == strlen(gMCU_Server_Info.AdminName)) || (gCarrier_Board_Info.magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		memset(gMCU_Server_Info.AdminName, 0, sizeof(gMCU_Server_Info.AdminName));
 		strcpy(gMCU_Server_Info.AdminName, DEFAULT_ADMIN_NAME);
 		eeprom_debug("No valid admin_name in EEPROM, set to %s!\n", gMCU_Server_Info.AdminName);
 	}
 
-	if ((0 == strlen(gMCU_Server_Info.AdminPassword)) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
+	if ((0 == strlen(gMCU_Server_Info.AdminPassword)) || (gCarrier_Board_Info.magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		memset(gMCU_Server_Info.AdminPassword, 0, sizeof(gMCU_Server_Info.AdminPassword));
 		strcpy(gMCU_Server_Info.AdminPassword, DEFAULT_ADMIN_PASSWORD);
@@ -386,7 +390,7 @@ static int get_mcu_server_info(void)
 		print_data((uint8_t *)&gMCU_Server_Info, sizeof(MCUServerInfo));
 	}
 
-	if ((0 == gMCU_Server_Info.ip_address[0]) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
+	if ((0 == gMCU_Server_Info.ip_address[0]) || (gCarrier_Board_Info.magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		gMCU_Server_Info.ip_address[0] = IP_ADDR0;
 		gMCU_Server_Info.ip_address[1] = IP_ADDR1;
@@ -396,7 +400,7 @@ static int get_mcu_server_info(void)
 	}
 
 	hlmask = ntohl_seq(gMCU_Server_Info.netmask_address);
-	if (!ip4_addr_netmask_valid(hlmask) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
+	if (!ip4_addr_netmask_valid(hlmask) || (gCarrier_Board_Info.magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		gMCU_Server_Info.netmask_address[0] = NETMASK_ADDR0;
 		gMCU_Server_Info.netmask_address[1] = NETMASK_ADDR1;
@@ -405,7 +409,7 @@ static int get_mcu_server_info(void)
 		eeprom_debug("No valid netmask in EEPROM, set to default!\n");
 	}
 
-	if ((0 == gMCU_Server_Info.gateway_address[0]) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
+	if ((0 == gMCU_Server_Info.gateway_address[0]) || (gCarrier_Board_Info.magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		gMCU_Server_Info.gateway_address[0] = GATEWAY_ADDR0;
 		gMCU_Server_Info.gateway_address[1] = GATEWAY_ADDR1;
@@ -539,7 +543,7 @@ int es_get_carrier_borad_info(CarrierBoardInfo *pCarrier_board_info)
 		return -1;
 
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
-	memcpy(pCarrier_board_info, pgCarrier_Board_Info, sizeof(CarrierBoardInfo));
+	memcpy(pCarrier_board_info, &gCarrier_Board_Info, sizeof(CarrierBoardInfo));
 	esEXIT_CRITICAL(gEEPROM_Mutex);
 	return 0;
 }
@@ -547,17 +551,15 @@ int es_get_carrier_borad_info(CarrierBoardInfo *pCarrier_board_info)
 int es_set_carrier_borad_info(CarrierBoardInfo *pCarrier_Board_Info)
 {
 	int skip_update_eeprom = 1;
-	uint32_t cbinfoArray[CBINFO_MAX_SIZE];
 
 	if (NULL == pCarrier_Board_Info)
 		return -1;
 
-	memcpy(cbinfoArray, pCarrier_Board_Info, sizeof(CarrierBoardInfo));
-	pCarrier_Board_Info->crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)cbinfoArray, sizeof(CarrierBoardInfo)/4 - 1);
+	pCarrier_Board_Info->crc32Checksum = sifive_crc32((uint8_t *)pCarrier_Board_Info, sizeof(CarrierBoardInfo)/4 - 1);
 
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
-	if (0 != memcmp(pCarrier_Board_Info, pgCarrier_Board_Info, sizeof(CarrierBoardInfo))) {
-		memcpy(pgCarrier_Board_Info, pCarrier_Board_Info, sizeof(CarrierBoardInfo));
+	if (0 != memcmp(pCarrier_Board_Info, &gCarrier_Board_Info, sizeof(CarrierBoardInfo))) {
+		memcpy(&gCarrier_Board_Info, pCarrier_Board_Info, sizeof(CarrierBoardInfo));
 		skip_update_eeprom = 0;
 		eeprom_debug("Updated CarrierBoardInfo in EEPROM!\n");
 	}
@@ -586,13 +588,13 @@ int es_get_mcu_mac(uint8_t *p_mac_address, uint8_t index)
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
 	switch (index) {
 		case 0:
-			memcpy(p_mac_address, pgCarrier_Board_Info->ethernetMAC1, sizeof(pgCarrier_Board_Info->ethernetMAC1));
+			memcpy(p_mac_address, gCarrier_Board_Info.ethernetMAC1, sizeof(gCarrier_Board_Info.ethernetMAC1));
 			break;
 		case 1:
-			memcpy(p_mac_address, pgCarrier_Board_Info->ethernetMAC2, sizeof(pgCarrier_Board_Info->ethernetMAC2));
+			memcpy(p_mac_address, gCarrier_Board_Info.ethernetMAC2, sizeof(gCarrier_Board_Info.ethernetMAC2));
 			break;
 		case 2:
-			memcpy(p_mac_address, pgCarrier_Board_Info->ethernetMAC3, sizeof(pgCarrier_Board_Info->ethernetMAC3));
+			memcpy(p_mac_address, gCarrier_Board_Info.ethernetMAC3, sizeof(gCarrier_Board_Info.ethernetMAC3));
 			break;
 		default:
 			break;
@@ -621,23 +623,23 @@ int es_set_mcu_mac(uint8_t *p_mac_address, uint8_t index)
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
 	switch (index) {
 		case 0:
-			if (0 != memcmp(pgCarrier_Board_Info->ethernetMAC1, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC1))) {
-				memcpy(pgCarrier_Board_Info->ethernetMAC1, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC1));
+			if (0 != memcmp(gCarrier_Board_Info.ethernetMAC1, p_mac_address, sizeof(gCarrier_Board_Info.ethernetMAC1))) {
+				memcpy(gCarrier_Board_Info.ethernetMAC1, p_mac_address, sizeof(gCarrier_Board_Info.ethernetMAC1));
 				update_mac = 1;
 			}
 			break;
 		case 1:
 		{
-			if (0 != memcmp(pgCarrier_Board_Info->ethernetMAC2, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC2))) {
-				memcpy(pgCarrier_Board_Info->ethernetMAC2, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC2));
+			if (0 != memcmp(gCarrier_Board_Info.ethernetMAC2, p_mac_address, sizeof(gCarrier_Board_Info.ethernetMAC2))) {
+				memcpy(gCarrier_Board_Info.ethernetMAC2, p_mac_address, sizeof(gCarrier_Board_Info.ethernetMAC2));
 				update_mac = 1;
 			}
 			break;
 		}
 		case 2:
 		{
-			if (0 != memcmp(pgCarrier_Board_Info->ethernetMAC3, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC3))) {
-				memcpy(pgCarrier_Board_Info->ethernetMAC3, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC3));
+			if (0 != memcmp(gCarrier_Board_Info.ethernetMAC3, p_mac_address, sizeof(gCarrier_Board_Info.ethernetMAC3))) {
+				memcpy(gCarrier_Board_Info.ethernetMAC3, p_mac_address, sizeof(gCarrier_Board_Info.ethernetMAC3));
 				update_mac = 1;
 			}
 			break;
@@ -646,13 +648,13 @@ int es_set_mcu_mac(uint8_t *p_mac_address, uint8_t index)
 			break;
 	}
 	if (update_mac) {
-		pgCarrier_Board_Info->crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)gCbinfoArray, sizeof(CarrierBoardInfo)/4 - 1);
+		gCarrier_Board_Info.crc32Checksum = sifive_crc32((uint8_t *)&gCarrier_Board_Info, sizeof(CarrierBoardInfo)/4 - 1);
 
 		hf_i2c_mem_write(&hi2c1, AT24C_ADDR, CARRIER_BOARD_INFO_EEPROM_MAIN_OFFSET,
-					(uint8_t *)pgCarrier_Board_Info, sizeof(CarrierBoardInfo));
+					(uint8_t *)&gCarrier_Board_Info, sizeof(CarrierBoardInfo));
 
 		hf_i2c_mem_write(&hi2c1, AT24C_ADDR, CARRIER_BOARD_INFO_EEPROM_BACKUP_OFFSET,
-					(uint8_t *)pgCarrier_Board_Info, sizeof(CarrierBoardInfo));
+					(uint8_t *)&gCarrier_Board_Info, sizeof(CarrierBoardInfo));
 	}
 	esEXIT_CRITICAL(gEEPROM_Mutex);
 
diff --git a/Core/Src/sifive_crc32.c b/Core/Src/sifive_crc32.c
new file mode 100644
index 0000000..b63d990
--- /dev/null
+++ b/Core/Src/sifive_crc32.c
@@ -0,0 +1,225 @@
+/*
+ * This file is derived from crc32.c from the zlib-1.1.3 distribution
+ * by Jean-loup Gailly and Mark Adler.
+ */
+
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <stddef.h>
+
+typedef uint32_t uLong;
+typedef uint8_t Byte;
+#define cpu_to_le32(x) (uint32_t)(x)
+#define le32_to_cpu(x) (uint32_t)(x)
+
+#define tole(x) cpu_to_le32(x)
+
+#define CONFIG_DYNAMIC_CRC_TABLE  1
+
+#ifdef CONFIG_DYNAMIC_CRC_TABLE
+
+static int  crc_table_empty = 1;
+static uint32_t crc_table[256];
+static void  make_crc_table(void);
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.
+*/
+static void  make_crc_table(void)
+{
+  uint32_t c;
+  int n, k;
+  uLong poly;		/* polynomial exclusive-or pattern */
+  /* terms of polynomial defining this crc (except x^32): */
+  static Byte  p[] = {
+		0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26};
+
+  /* make exclusive-or pattern from polynomial (0xedb88320L) */
+  poly = 0L;
+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+    poly |= 1L << (31 - p[n]);
+
+  for (n = 0; n < 256; n++)
+  {
+    c = (uLong)n;
+    for (k = 0; k < 8; k++)
+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+    crc_table[n] = tole(c);
+  }
+  crc_table_empty = 0;
+}
+#elif !defined(CONFIG_ARM64_CRC32)
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+
+static const uint32_t  crc_table[256] = {
+tole(0x00000000L), tole(0x77073096L), tole(0xee0e612cL), tole(0x990951baL),
+tole(0x076dc419L), tole(0x706af48fL), tole(0xe963a535L), tole(0x9e6495a3L),
+tole(0x0edb8832L), tole(0x79dcb8a4L), tole(0xe0d5e91eL), tole(0x97d2d988L),
+tole(0x09b64c2bL), tole(0x7eb17cbdL), tole(0xe7b82d07L), tole(0x90bf1d91L),
+tole(0x1db71064L), tole(0x6ab020f2L), tole(0xf3b97148L), tole(0x84be41deL),
+tole(0x1adad47dL), tole(0x6ddde4ebL), tole(0xf4d4b551L), tole(0x83d385c7L),
+tole(0x136c9856L), tole(0x646ba8c0L), tole(0xfd62f97aL), tole(0x8a65c9ecL),
+tole(0x14015c4fL), tole(0x63066cd9L), tole(0xfa0f3d63L), tole(0x8d080df5L),
+tole(0x3b6e20c8L), tole(0x4c69105eL), tole(0xd56041e4L), tole(0xa2677172L),
+tole(0x3c03e4d1L), tole(0x4b04d447L), tole(0xd20d85fdL), tole(0xa50ab56bL),
+tole(0x35b5a8faL), tole(0x42b2986cL), tole(0xdbbbc9d6L), tole(0xacbcf940L),
+tole(0x32d86ce3L), tole(0x45df5c75L), tole(0xdcd60dcfL), tole(0xabd13d59L),
+tole(0x26d930acL), tole(0x51de003aL), tole(0xc8d75180L), tole(0xbfd06116L),
+tole(0x21b4f4b5L), tole(0x56b3c423L), tole(0xcfba9599L), tole(0xb8bda50fL),
+tole(0x2802b89eL), tole(0x5f058808L), tole(0xc60cd9b2L), tole(0xb10be924L),
+tole(0x2f6f7c87L), tole(0x58684c11L), tole(0xc1611dabL), tole(0xb6662d3dL),
+tole(0x76dc4190L), tole(0x01db7106L), tole(0x98d220bcL), tole(0xefd5102aL),
+tole(0x71b18589L), tole(0x06b6b51fL), tole(0x9fbfe4a5L), tole(0xe8b8d433L),
+tole(0x7807c9a2L), tole(0x0f00f934L), tole(0x9609a88eL), tole(0xe10e9818L),
+tole(0x7f6a0dbbL), tole(0x086d3d2dL), tole(0x91646c97L), tole(0xe6635c01L),
+tole(0x6b6b51f4L), tole(0x1c6c6162L), tole(0x856530d8L), tole(0xf262004eL),
+tole(0x6c0695edL), tole(0x1b01a57bL), tole(0x8208f4c1L), tole(0xf50fc457L),
+tole(0x65b0d9c6L), tole(0x12b7e950L), tole(0x8bbeb8eaL), tole(0xfcb9887cL),
+tole(0x62dd1ddfL), tole(0x15da2d49L), tole(0x8cd37cf3L), tole(0xfbd44c65L),
+tole(0x4db26158L), tole(0x3ab551ceL), tole(0xa3bc0074L), tole(0xd4bb30e2L),
+tole(0x4adfa541L), tole(0x3dd895d7L), tole(0xa4d1c46dL), tole(0xd3d6f4fbL),
+tole(0x4369e96aL), tole(0x346ed9fcL), tole(0xad678846L), tole(0xda60b8d0L),
+tole(0x44042d73L), tole(0x33031de5L), tole(0xaa0a4c5fL), tole(0xdd0d7cc9L),
+tole(0x5005713cL), tole(0x270241aaL), tole(0xbe0b1010L), tole(0xc90c2086L),
+tole(0x5768b525L), tole(0x206f85b3L), tole(0xb966d409L), tole(0xce61e49fL),
+tole(0x5edef90eL), tole(0x29d9c998L), tole(0xb0d09822L), tole(0xc7d7a8b4L),
+tole(0x59b33d17L), tole(0x2eb40d81L), tole(0xb7bd5c3bL), tole(0xc0ba6cadL),
+tole(0xedb88320L), tole(0x9abfb3b6L), tole(0x03b6e20cL), tole(0x74b1d29aL),
+tole(0xead54739L), tole(0x9dd277afL), tole(0x04db2615L), tole(0x73dc1683L),
+tole(0xe3630b12L), tole(0x94643b84L), tole(0x0d6d6a3eL), tole(0x7a6a5aa8L),
+tole(0xe40ecf0bL), tole(0x9309ff9dL), tole(0x0a00ae27L), tole(0x7d079eb1L),
+tole(0xf00f9344L), tole(0x8708a3d2L), tole(0x1e01f268L), tole(0x6906c2feL),
+tole(0xf762575dL), tole(0x806567cbL), tole(0x196c3671L), tole(0x6e6b06e7L),
+tole(0xfed41b76L), tole(0x89d32be0L), tole(0x10da7a5aL), tole(0x67dd4accL),
+tole(0xf9b9df6fL), tole(0x8ebeeff9L), tole(0x17b7be43L), tole(0x60b08ed5L),
+tole(0xd6d6a3e8L), tole(0xa1d1937eL), tole(0x38d8c2c4L), tole(0x4fdff252L),
+tole(0xd1bb67f1L), tole(0xa6bc5767L), tole(0x3fb506ddL), tole(0x48b2364bL),
+tole(0xd80d2bdaL), tole(0xaf0a1b4cL), tole(0x36034af6L), tole(0x41047a60L),
+tole(0xdf60efc3L), tole(0xa867df55L), tole(0x316e8eefL), tole(0x4669be79L),
+tole(0xcb61b38cL), tole(0xbc66831aL), tole(0x256fd2a0L), tole(0x5268e236L),
+tole(0xcc0c7795L), tole(0xbb0b4703L), tole(0x220216b9L), tole(0x5505262fL),
+tole(0xc5ba3bbeL), tole(0xb2bd0b28L), tole(0x2bb45a92L), tole(0x5cb36a04L),
+tole(0xc2d7ffa7L), tole(0xb5d0cf31L), tole(0x2cd99e8bL), tole(0x5bdeae1dL),
+tole(0x9b64c2b0L), tole(0xec63f226L), tole(0x756aa39cL), tole(0x026d930aL),
+tole(0x9c0906a9L), tole(0xeb0e363fL), tole(0x72076785L), tole(0x05005713L),
+tole(0x95bf4a82L), tole(0xe2b87a14L), tole(0x7bb12baeL), tole(0x0cb61b38L),
+tole(0x92d28e9bL), tole(0xe5d5be0dL), tole(0x7cdcefb7L), tole(0x0bdbdf21L),
+tole(0x86d3d2d4L), tole(0xf1d4e242L), tole(0x68ddb3f8L), tole(0x1fda836eL),
+tole(0x81be16cdL), tole(0xf6b9265bL), tole(0x6fb077e1L), tole(0x18b74777L),
+tole(0x88085ae6L), tole(0xff0f6a70L), tole(0x66063bcaL), tole(0x11010b5cL),
+tole(0x8f659effL), tole(0xf862ae69L), tole(0x616bffd3L), tole(0x166ccf45L),
+tole(0xa00ae278L), tole(0xd70dd2eeL), tole(0x4e048354L), tole(0x3903b3c2L),
+tole(0xa7672661L), tole(0xd06016f7L), tole(0x4969474dL), tole(0x3e6e77dbL),
+tole(0xaed16a4aL), tole(0xd9d65adcL), tole(0x40df0b66L), tole(0x37d83bf0L),
+tole(0xa9bcae53L), tole(0xdebb9ec5L), tole(0x47b2cf7fL), tole(0x30b5ffe9L),
+tole(0xbdbdf21cL), tole(0xcabac28aL), tole(0x53b39330L), tole(0x24b4a3a6L),
+tole(0xbad03605L), tole(0xcdd70693L), tole(0x54de5729L), tole(0x23d967bfL),
+tole(0xb3667a2eL), tole(0xc4614ab8L), tole(0x5d681b02L), tole(0x2a6f2b94L),
+tole(0xb40bbe37L), tole(0xc30c8ea1L), tole(0x5a05df1bL), tole(0x2d02ef8dL)
+};
+#endif
+
+
+/* ========================================================================= */
+#define DO_CRC(x) crc = tab[(crc ^ (x)) & 255] ^ (crc >> 8)
+
+
+/* ========================================================================= */
+#define SIFIVE_CRC32_DEBUG_EN 0
+static void print_data(uint8_t *p_buf, int len)
+{
+  #if SIFIVE_CRC32_DEBUG_EN
+    int i;
+    for (i = 0; i < len; i++) {
+        printf(" %02x", p_buf[i]);
+        if (0 == ((i+1)%8))
+            printf("\n");
+    }
+    printf("\n");
+    #endif
+}
+
+/* No ones complement version. JFFS2 (and other things ?)
+ * don't use ones compliment in their CRC calculations.
+ */
+uint32_t crc32_no_comp(uint32_t crc, const uint8_t *buf, uint32_t len)
+{
+    const uint32_t *tab = crc_table;
+    const uint32_t *b =(const uint32_t *)buf;
+    size_t rem_len;
+#ifdef CONFIG_DYNAMIC_CRC_TABLE
+    if (crc_table_empty) {
+      make_crc_table();
+      print_data((uint8_t *)crc_table, sizeof(crc_table));
+    }
+
+#endif
+    crc = cpu_to_le32(crc);
+    /* Align it */
+    if (((long)b) & 3 && len) {
+        uint8_t *p = (uint8_t *)b;
+        do {
+            DO_CRC(*p++);
+        } while ((--len) && ((long)p)&3);
+        b = (uint32_t *)p;
+    }
+
+    rem_len = len & 3;
+    len = len >> 2;
+    for (--b; len; --len) {
+        /* load data 32 bits wide, xor data 32 bits wide. */
+        crc ^= *++b; /* use pre increment for speed */
+        DO_CRC(0);
+        DO_CRC(0);
+        DO_CRC(0);
+        DO_CRC(0);
+    }
+    len = rem_len;
+    /* And the last few bytes */
+    if (len) {
+        uint8_t *p = (uint8_t *)(b + 1) - 1;
+        do {
+            DO_CRC(*++p); /* use pre increment for speed */
+        } while (--len);
+    }
+
+    return le32_to_cpu(crc);
+}
+
+uint32_t sifive_crc32(const uint8_t *p, uint32_t len)
+{
+    uint32_t crc = 0xFFFFFFFF;
+
+    return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
+}
+
+
diff --git a/Makefile b/Makefile
index 48ca816..b4181c3 100644
--- a/Makefile
+++ b/Makefile
@@ -46,6 +46,7 @@ C_SOURCES =  \
 Core/Src/main.c \
 Core/Src/console.c \
 Core/Src/freertos.c \
+Core/Src/sifive_crc32.c \
 Core/Src/hf_common.c \
 Core/Src/hf_power_process.c \
 Core/Src/hf_http_process.c \
-- 
2.25.1

