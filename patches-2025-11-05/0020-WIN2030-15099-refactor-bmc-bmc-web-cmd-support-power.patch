From a7e35c5f1995c021f5138b602881c725fe2c1eb6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E2=80=9Chuangyifeng=E2=80=9D?=
 <huangyifeng@eswincomputing.com>
Date: Mon, 13 May 2024 14:27:50 +0800
Subject: [PATCH 020/109] WIN2030-15099:refactor(bmc):bmc web cmd support
 poweroff

Changelogs: 1.support poweroff cmd from web
     2.support to get SOM daemon status
     3.add critical section protection for som_power_state and
       som_daemon_state
Change-Id: I0677ba956827830f4ecc93e45d37ac2ba1b1cd41
---
 Core/Inc/hf_common.h           |  8 ++-
 Core/Src/hf_gpio_process.c     | 10 ++--
 Core/Src/hf_power_process.c    | 33 ++++++++++--
 Core/Src/hf_protocol_process.c | 97 ++++++++++++++++++++++++++++------
 Core/Src/web-server.c          | 19 ++++---
 5 files changed, 130 insertions(+), 37 deletions(-)

diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index f6a2e2b..17535c0 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -48,8 +48,6 @@ typedef enum {
 
 #define FRAME_DATA_MAX 250
 
-extern power_switch_t som_power_state;
-
 // Define command types
 typedef enum {
 	CMD_POWER_OFF = 0x01,
@@ -192,6 +190,12 @@ int es_get_som_dip_switch_soft_state(uint8_t *p_som_dip_switch_soft_state);
 int es_set_som_dip_switch_soft_state(uint8_t som_dip_switch_soft_state);
 
 int es_eeprom_info_test(void);
+power_switch_t get_som_power_state(void);
+void change_som_power_state(power_switch_t newState);
+deamon_stats_t get_som_daemon_state(void);
+void change_som_daemon_state(deamon_stats_t newState);
+
+void TriggerSomTimer(void);
 
 #ifdef __cplusplus
 }
diff --git a/Core/Src/hf_gpio_process.c b/Core/Src/hf_gpio_process.c
index e31d12e..9427299 100644
--- a/Core/Src/hf_gpio_process.c
+++ b/Core/Src/hf_gpio_process.c
@@ -76,7 +76,7 @@ static void key_process(void)
 				button_state = KEY_RELEASE_DETECTED_STATE;
 			} else if (currentTime - pressStartTime > LONG_PRESS_THRESHOLD) {
 				button_state = KEY_LONG_PRESS_STATE;
-			} else if ((som_power_state == SOM_POWER_OFF) && (currentTime - pressStartTime >= PRESS_Time)) {
+			} else if ((get_som_power_state() == SOM_POWER_OFF) && (currentTime - pressStartTime >= PRESS_Time)) {
 				button_state = KEY_SHORT_PRESS_STATE;
 			}
 			break;
@@ -106,15 +106,15 @@ static void key_process(void)
 		case KEY_SHORT_PRESS_STATE:
 			printf("KEY_SHORT_PRESS_STATE time %ld\n", currentTime - pressStartTime);
 			button_state = KEY_PRESS_STATE_END;
-			if (som_power_state != SOM_POWER_ON) {
-				som_power_state = SOM_POWER_ON;
+			if (get_som_power_state() != SOM_POWER_ON) {
+				change_som_power_state(SOM_POWER_ON);
 			}
 			break;
 		case KEY_LONG_PRESS_STATE:
 			printf("KEY_LONG_PRESS_STATE time %ld\n", currentTime - pressStartTime);
 			button_state = KEY_PRESS_STATE_END;
-			if (som_power_state == SOM_POWER_ON) {
-				som_power_state = SOM_POWER_OFF;
+			if (get_som_power_state() == SOM_POWER_ON) {
+				change_som_power_state(SOM_POWER_OFF);
 			}
 			break;
 		case KEY_DOUBLE_PRESS_STATE:
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index 8070ec1..e798c92 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -20,7 +20,7 @@
 /* Private macro -------------------------------------------------------------*/
 #define PCA9450_ADDR (0x25u << 1)
 /* Private variables ---------------------------------------------------------*/
-power_switch_t som_power_state = SOM_POWER_OFF;
+volatile power_switch_t som_power_state = SOM_POWER_OFF;
 
 static uint8_t get_dc_power_status(void);
 static void pmic_status_led_on(uint8_t turnon);
@@ -32,6 +32,25 @@ static int pmic_b6out_105v(void);
 
 #define MAXTRYCOUNT		10
 int try_count = 0;
+
+power_switch_t get_som_power_state(void)
+{
+	power_switch_t state;
+
+	taskENTER_CRITICAL();
+	state = som_power_state;
+	taskEXIT_CRITICAL();
+	return state;
+}
+
+void change_som_power_state(power_switch_t newState)
+{
+	// Enter critical section to ensure thread safety when traversing and deleting
+	taskENTER_CRITICAL();
+	som_power_state = newState;
+	taskEXIT_CRITICAL();
+}
+
 void hf_power_task(void *parameter)
 {
 	HAL_StatusTypeDef status = HAL_OK;
@@ -39,12 +58,15 @@ void hf_power_task(void *parameter)
 	GPIO_PinState pin_state = GPIO_PIN_RESET;
 	printf("hf_power_task started!!!\r\n");
 
-	#ifdef AUTO_BOOT
+#ifdef AUTO_BOOT
 	power_state = ATX_PS_ON_STATE;
-	som_power_state = SOM_POWER_ON;
-	#endif
+	change_som_power_state(SOM_POWER_ON);
+#endif
+
 	power_led_on(pdFALSE);
+
 	while (1) {
+		taskENTER_CRITICAL();
 		switch (power_state) {
 		case ATX_PS_ON_STATE:
 			printf("ATX_PS_ON_STATE\r\n");
@@ -59,7 +81,7 @@ void hf_power_task(void *parameter)
 				pin_state = get_dc_power_status();
 				osDelay(100);
 			} while (pin_state != pdTRUE && try_count--);
-			
+
 			if(try_count <= 0)
 			{
 				printf("DC_PWR_STATE fail\r\n");
@@ -120,6 +142,7 @@ void hf_power_task(void *parameter)
 			}
 			break;
 		}
+		taskEXIT_CRITICAL();
 		osDelay(100);
 	}
 }
diff --git a/Core/Src/hf_protocol_process.c b/Core/Src/hf_protocol_process.c
index 1d9aed4..0f0e067 100644
--- a/Core/Src/hf_protocol_process.c
+++ b/Core/Src/hf_protocol_process.c
@@ -9,6 +9,7 @@
 #include "task.h"
 #include "queue.h"
 #include "semphr.h"
+#include "timers.h"
 
 #define head_meg "\xA5\x5A\xAA\x55"
 #define end_msg "\x0D\x0A\x0D\x0A"
@@ -467,15 +468,17 @@ QueueHandle_t xUart4MsgQueue;
 typedef enum {
 	MSG_REQUEST = 0x01,
 	MSG_REPLY,
+	MSG_NOTIFLY,
 } MsgType;
 
 void dump_message(Message data)
 {
-	printf("Header: 0x%lX, Cmd Type: 0x%x, Data Len: %d, Checksum: 0x%X, Tail: 0x%lx\n",
-		data.header, data.cmd_type, data.data_len, data.checksum, data.tail);
+	printf("Header: 0x%lX, Msg_type %d, Cmd Type: 0x%x, Data Len: %d, Checksum: 0x%X, Tail: 0x%lx\n",
+		data.header, data.msg_type, data.cmd_type, data.data_len, data.checksum, data.tail);
 }
 // Define a mutex handle
 SemaphoreHandle_t xMutex = NULL;
+TimerHandle_t xSomTimer;
 
 // Function to initialize the mutex
 void init_transmit_mutex(void) {
@@ -618,7 +621,29 @@ static void buf_dump(uint8_t *data, uint32_t len)
 	printf("\n");
 }
 
-deamon_stats_t som_daemon_state = SOM_DAEMON_OFF;
+volatile deamon_stats_t som_daemon_state = SOM_DAEMON_OFF;
+deamon_stats_t get_som_daemon_state(void)
+{
+	deamon_stats_t state;
+
+	// Enter critical section to ensure thread safety when traversing and deleting
+	taskENTER_CRITICAL();
+	state = som_daemon_state;
+	taskEXIT_CRITICAL();
+
+	return state;
+}
+
+void change_som_daemon_state(deamon_stats_t newState)
+{
+
+	// Enter critical section to ensure thread safety when traversing and deleting
+	taskENTER_CRITICAL();
+	som_daemon_state = newState;
+	taskEXIT_CRITICAL();
+	return ;
+}
+
 void deamon_keeplive_task(void *argument)
 {
 	int ret = HAL_OK;
@@ -626,11 +651,11 @@ void deamon_keeplive_task(void *argument)
 	static uint8_t count = 0;
 
 	for (;;) {
-		if (SOM_POWER_ON != som_power_state) {
+		if (SOM_POWER_ON != get_som_power_state()) {
 			osDelay(50);
 			continue;
 		}
-		old_status = som_daemon_state;
+		old_status = get_som_daemon_state();
 		ret = web_cmd_handle(CMD_BOARD_STATUS, NULL, 0, 1000);
 		if (HAL_OK != ret) {
 			if (HAL_TIMEOUT == ret) {
@@ -642,22 +667,31 @@ void deamon_keeplive_task(void *argument)
 			}
 			count++;
 			if (5 >= count) {
-				som_daemon_state = SOM_DAEMON_OFF;
+				change_som_daemon_state(SOM_DAEMON_OFF);
 			}
 		} else {
-			som_daemon_state = SOM_DAEMON_ON;
+			change_som_daemon_state(SOM_DAEMON_ON);;
 			count = 0;
 		}
-		if (old_status != som_daemon_state) {
+		if (old_status != get_som_daemon_state()) {
 			printf("SOM Daemon status change to %s!\n",
-				som_daemon_state == SOM_DAEMON_ON ? "on" : "off");
+				get_som_daemon_state() == SOM_DAEMON_ON ? "on" : "off");
 		}
-		/*check every 1 second*/
+		/*check every 4 second*/
 		osDelay(pdMS_TO_TICKS(4000));
 	}
 }
 
-void handle_deamon_mesage(Message *msg)
+void handle_notify_mesage(Message *msg)
+{
+	if (CMD_POWER_OFF == msg->cmd_type) {
+		// Here the SOM should at shutdown state in opensbi, we can turn off its power safely
+		change_som_power_state(SOM_POWER_OFF);
+		printf("Poweroff SOM normaly, shutdown it now!\n");
+	}
+}
+
+void handle_som_mesage(Message *msg)
 {
 	if (MSG_REPLY == msg->msg_type) {
 		if (!listLIST_IS_EMPTY(&WebCmdList)) {
@@ -680,13 +714,32 @@ void handle_deamon_mesage(Message *msg)
 			}
 			taskEXIT_CRITICAL();
 		}
+	} else if (MSG_NOTIFLY == msg->msg_type) {
+		handle_notify_mesage(msg);
 	} else {
-		printf("Unsupport msg type: 0x%x\n", msg->cmd_type);
-		buf_dump((uint8_t *)&msg, sizeof(msg));
+		printf("Unsupport msg type: 0x%x\n", msg->msg_type);
+		buf_dump((uint8_t *)msg, sizeof(*msg));
 		dump_message(*msg);
 	}
 }
+
+void vSomTimerCallback(TimerHandle_t xSomTimer)
+{
+	if (SOM_POWER_OFF != get_som_power_state()) {
+		change_som_power_state(SOM_POWER_OFF);
+		printf("Poweroff SOM timeout, shutdown it now!\n");
+	}
+}
+
+void TriggerSomTimer(void)
+{
+	if (xTimerStart(xSomTimer, 0) != pdPASS) {
+		printf("Failed to trigger Som timer!\n");
+	}
+}
+
 #define QUEUE_LENGTH 8
+
 void uart4_protocol_task(void *argument)
 {
 	Message msg;
@@ -695,26 +748,36 @@ void uart4_protocol_task(void *argument)
 
 	xUart4MsgQueue = xQueueCreate(QUEUE_LENGTH, sizeof(Message));
 	if (xUart4MsgQueue == NULL) {
-		printf("Failed to create msg queue!\n");
+		printf("[%s %d]:Failed to create SOM msg queue!\n",__func__,__LINE__);
 		return;
 	}
 
 	//Init web server cmd list
 	vListInitialise(&WebCmdList);
+
+	/* Create a timer with a timeout set to 5 seconds */
+	xSomTimer = xTimerCreate( "SomTimer", (5000 / portTICK_PERIOD_MS),
+			pdFALSE, (void *)0, vSomTimerCallback);
+
+	if (xSomTimer == NULL) {
+		printf("[%s %d]:Failed to create SOM Timer!\n",__func__,__LINE__);
+		return;
+	}
+
 	for (;;) {
 		if (xQueueReceive(xUart4MsgQueue, &(msg), portMAX_DELAY)) {
 			if (msg.header == FRAME_HEADER && msg.tail == FRAME_TAIL) {
 				// Check checksum
 				if (check_checksum(&msg)) {
 					// handle command
-					handle_deamon_mesage(&msg);
+					handle_som_mesage(&msg);
 				} else {
-					printf("[%s %d]:Checksum error!\n",__func__,__LINE__);
+					printf("[%s %d]:SOM msg checksum error!\n",__func__,__LINE__);
 					buf_dump((uint8_t *)&msg, sizeof(msg));
 					dump_message(msg);
 				}
 			} else {
-				printf("[%s %d]:Invalid message format!\n",__func__,__LINE__);
+				printf("[%s %d]:Invalid SOM message format!\n",__func__,__LINE__);
 				buf_dump((uint8_t *)&msg, sizeof(msg));
 				dump_message(msg);
 			}
diff --git a/Core/Src/web-server.c b/Core/Src/web-server.c
index 948269a..3157515 100644
--- a/Core/Src/web-server.c
+++ b/Core/Src/web-server.c
@@ -10449,30 +10449,33 @@ void unescape_colon(char *str) {
 }
 
 //1:powerON,0:powerOFF
-int get_power_status()
+static int get_power_status()
 {
-	return som_power_state == SOM_POWER_ON ? 1 : 0;
+	return get_som_power_state() == SOM_POWER_ON ? 1 : 0;
 }
 
 //status 0:power off,1:power on
-int change_power_status(int status)
+static int change_power_status(int status)
 {
 	int ret = 0;
 
 	if (0 == status) {
-		if (SOM_POWER_ON == som_power_state) {
+		if (SOM_POWER_ON == get_som_power_state()) {
 			ret = web_cmd_handle(CMD_POWER_OFF, NULL, 0, 1000);
 			if (HAL_OK != ret) {
-				som_power_state = SOM_POWER_OFF;
+				change_som_power_state(SOM_POWER_OFF);
+				printf("Poweroff SOM error(ret %d), force shutdown it!\n", ret);
 				ret = HAL_OK;
-				printf("Faild to power SOM, force shutdown SOM!\n");
+				return ret;
 			}
+			// Trigger the Som timer to enusre SOM could poweroff in 5 senconds
+			TriggerSomTimer();
 		} else {
 			printf("SOM already power off!\n");
 		}
 	} else {
-		if (SOM_POWER_OFF == som_power_state) {
-			som_power_state = SOM_POWER_ON;
+		if (SOM_POWER_OFF == get_som_power_state()) {
+			change_som_power_state(SOM_POWER_ON);
 		} else {
 			printf("SOM already power on!\n");
 		}
-- 
2.25.1

