From f50fb312ed32c345095728d41f58008df3fc9245 Mon Sep 17 00:00:00 2001
From: xuxiang <xuxiang@eswincomputing.com>
Date: Tue, 11 Jun 2024 10:22:27 +0800
Subject: [PATCH 089/109] WIN2030-15279:refactor:get power info from MCU

Changelogs:
   1.Get power info form MCU instead of SOM.
   2.print log when reboot/restart/change power error happen.

Change-Id: I698617a6ed3dc600229e5b6570c76cd38fa3df10
---
 Core/Src/console.c          |   9 +-
 Core/Src/hf_board_init.c    |   4 +-
 Core/Src/hf_power_process.c | 225 +++++++++++++++++++++++++++++++++++-
 Core/Src/web-server.c       |  11 +-
 4 files changed, 242 insertions(+), 7 deletions(-)

diff --git a/Core/Src/console.c b/Core/Src/console.c
index 7c4db14..ec7cbb5 100644
--- a/Core/Src/console.c
+++ b/Core/Src/console.c
@@ -1088,12 +1088,19 @@ static BaseType_t prvCommandTempGet(char *pcWriteBuffer, size_t xWriteBufferLen,
 static BaseType_t prvCommandPwrDissipationGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
 {
     uint32_t millivolt = 0, milliCur = 0, microWatt = 0; //millivolt, milliCurrent, milliwatt
+#if 0
     power_info power_info = {0};
-
     power_info = get_power_info();
     millivolt = power_info.voltage;
     milliCur = power_info.current;
     microWatt = power_info.consumption;
+#else
+    int pwrStaus;
+    pwrStaus = get_som_power_state();
+    if (pwrStaus == SOM_POWER_ON) {
+        get_board_power(&millivolt, &milliCur, &microWatt);
+    }
+#endif
     snprintf(pcWriteBuffer, xWriteBufferLen,"consumption:%ld.%3.3ld(W)  voltage:%ld.%03ld(V)  current:%ld.%03ld(A)\n",
         microWatt / 1000000, microWatt % 1000000, millivolt / 1000, millivolt % 1000, milliCur / 1000, milliCur % 1000);
     return pdFALSE;
diff --git a/Core/Src/hf_board_init.c b/Core/Src/hf_board_init.c
index 9d515ec..cdbd51d 100644
--- a/Core/Src/hf_board_init.c
+++ b/Core/Src/hf_board_init.c
@@ -59,7 +59,7 @@ static void SystemClock_Config(void);
 static void MX_GPIO_Init(void);
 static void MX_DMA_Init(void);
 static void MX_I2C1_Init(void);
-static void MX_I2C3_Init(void);
+void MX_I2C3_Init(void);
 static void MX_SPI2_Init(void);
 static void MX_USART3_UART_Init(void);
 static void MX_WWDG_Init(void);
@@ -240,7 +240,7 @@ static void MX_I2C1_Init(void)
  * @param None
  * @retval None
  */
-static void MX_I2C3_Init(void)
+void MX_I2C3_Init(void)
 {
 	hi2c3.Instance = I2C3;
 	hi2c3.Init.ClockSpeed = 100000;
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index a9469fa..7376074 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -16,6 +16,48 @@
 #define DC_POWER_GOOD GPIO_PIN_SET
 #define DC_POWER_FAIL GPIO_PIN_RESET
 
+/* Private macro -------------------------------------------------------------*/
+#define PCA9450_ADDR (0x25u << 1)
+#define INA226_12V_ADDR (0X44U << 1)
+#define PAC1934_ADDR (0X10U << 1)
+
+#define INA2XX_CONFIG 0x00
+#define INA2XX_SHUNT_VOLTAGE 0x01 /* readonly */
+#define INA2XX_BUS_VOLTAGE 0x02	  /* readonly */
+#define INA2XX_POWER 0x03		  /* readonly */
+#define INA2XX_CURRENT 0x04		  /* readonly */
+#define INA2XX_CALIBRATION 0x05
+
+#define INA226_BUS_LSB 1250 /*uV*/
+
+#define INA226_SHUNT_RESISTOR 1000							 /*uOhm*/
+#define INA226_CURRENT_LSB (2500000 / INA226_SHUNT_RESISTOR) /*uA */
+#define INA226_POWER_LSB_FACTOR 25
+
+#define PAC193X_CMD_CTRL 0x1
+#define PAC193X_CMD_VBUS1 0x7
+#define PAC193X_CMD_VSENSE1 0xb
+#define PAC193X_CMD_VPOWER1 0x17
+#define PAC193X_CMD_REFRESH_V 0x1F
+#define PAC193X_CMD_NEG_PWR_ACT 0x23
+#define PAC193X_COSTANT_PWR_M 3200000000ull /* 3.2V^2*1000mO*/
+#define PAC193X_COSTANT_CURRENT_M 100000	/* 100mv*1000mO*/
+#define PAC193X_SHUNT_RESISTOR_M 4			/* mO*/
+
+#define DIV_ROUND_CLOSEST(x, divisor) (        \
+	{                                          \
+		typeof(x) __x = x;                     \
+		typeof(divisor) __d = divisor;         \
+		(((typeof(x))-1) > 0 ||                \
+		 ((typeof(divisor))-1) > 0 ||          \
+		 (((__x) > 0) == ((__d) > 0)))         \
+			? (((__x) + ((__d) / 2)) / (__d))  \
+			: (((__x) - ((__d) / 2)) / (__d)); \
+	})
+#define SWAP16(w) ((((w) & 0xff) << 8) | (((w) & 0xff00) >> 8))
+#define SWAP32(w) ((((w) & 0xff) << 24) | (((w) & 0xff00) << 8) | (((w) & 0xff0000) >> 8) | (((w) & 0xff000000) >> 24))
+
+
 /* Private macro -------------------------------------------------------------*/
 /* Private variables ---------------------------------------------------------*/
 volatile power_switch_t som_power_state = SOM_POWER_OFF;
@@ -66,8 +108,10 @@ void hf_power_task(void *parameter)
 				printf("DC_PWR_STATE fail\r\n");
 				change_som_power_state(SOM_POWER_OFF);
 				power_state = STOP_POWER;
-			} else
+			} else {
 				power_state = SOM_STATUS_CHECK_STATE;
+				MX_I2C3_Init();
+			}
 			break;
 		case SOM_STATUS_CHECK_STATE:
 			printf("SOM_STATUS_CHECK_STATE\r\n");
@@ -148,6 +192,7 @@ static uint8_t get_dc_power_status(void)
  * @param  reset pdTRUE : reset; pdFALSE : release
  * @retval None
  */
+extern void MX_I2C3_Init(void);
 void som_reset_control(uint8_t reset)
 {
 	GPIO_InitTypeDef GPIO_InitStruct = {0};
@@ -162,6 +207,7 @@ void som_reset_control(uint8_t reset)
 		HAL_GPIO_Init(MCU_RESET_SOM_N_GPIO_Port, &GPIO_InitStruct);
 		uart_deinit(UART4);
 		uart_deinit(USART6);
+		HAL_I2C_DeInit(&hi2c3);
 		SPI2_MASTER_CS_LOW();
 		set_bootsel(0, 0);
 	} else {
@@ -250,4 +296,181 @@ void vRestartSOM(void)
 	/*Delay 2 second*/
 	osDelay(pdMS_TO_TICKS(2000));
 	change_som_power_state(SOM_POWER_ON);
+}
+
+
+static int ina226_init(void)
+{
+	uint16_t default_cfg = SWAP16(0x4527);
+	uint16_t calibration_value = SWAP16(2048);
+	int ret = 0;
+
+	ret = hf_i2c_reg_write_block(&hi2c3, INA226_12V_ADDR, INA2XX_CONFIG, (uint8_t *)&default_cfg, 2);
+	if (ret)
+	{
+		printf("init ina226 error1\n");
+		return -1;
+	}
+	ret = hf_i2c_reg_write_block(&hi2c3, INA226_12V_ADDR, INA2XX_CALIBRATION, (uint8_t *)&calibration_value, 2);
+	if (ret)
+	{
+		printf("init ina226 error2\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+int get_board_power(uint32_t *volt, uint32_t *curr, uint32_t *power)
+{
+	uint32_t reg_bus = 0x0;
+	uint32_t reg_power = 0x0;
+	uint32_t reg_curr = 0x0;
+	int ret = 0;
+	static int is_first = 1;
+	struct rtc_time_t time = {0};
+
+	es_get_rtc_time(&time);
+
+	taskENTER_CRITICAL();
+	if (1 == is_first)
+	{
+		/*Write failure, not find wrong reason*/
+		ret = ina226_init();
+		if (ret)
+		{
+			ret = -1;
+			goto out;
+		}
+		is_first = 0;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_BUS_VOLTAGE, (uint8_t *)&reg_bus, 2);
+	if (ret)
+	{
+		printf("get board volt error(%02u:%02u:%02u CST)\n", time.Hours, time.Minutes, time.Seconds);
+		ret = -1;
+		goto out;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_POWER, (uint8_t *)&reg_power, 2);
+	if (ret)
+	{
+		printf("get board power error(%02u:%02u:%02u CST)\n", time.Hours, time.Minutes, time.Seconds);
+		ret = -1;
+		goto out;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_CURRENT, (uint8_t *)&reg_curr, 2);
+	if (ret)
+	{
+		printf("get board current error(%02u:%02u:%02u CST)\n", time.Hours, time.Minutes, time.Seconds);
+		ret = -1;
+		goto out;
+	}
+	reg_bus = SWAP16(reg_bus);
+	reg_curr = SWAP16(reg_curr);
+	reg_power = SWAP16(reg_power);
+
+	*volt = reg_bus * INA226_BUS_LSB;
+	*volt = DIV_ROUND_CLOSEST(*volt, 1000);
+
+	*power = reg_power * INA226_CURRENT_LSB * INA226_POWER_LSB_FACTOR;
+	*curr = reg_curr * INA226_CURRENT_LSB;
+	*curr = DIV_ROUND_CLOSEST(*curr, 1000);
+
+out:
+	taskEXIT_CRITICAL();
+	return ret;
+}
+
+
+int get_som_power(uint32_t *volt, uint32_t *curr, uint32_t *power)
+{
+	uint32_t reg_bus = 0x0;
+	uint32_t reg_power = 0x0;
+	uint32_t reg_curr = 0x0;
+	int ret = 0;
+	static int is_first = 1;
+	uint8_t act_val = 0;
+	uint8_t is_neg = 0;
+	uint8_t ctrl_value = 0x8;
+
+	taskENTER_CRITICAL();
+	if (1 == is_first)
+	{
+		/*Write failure, not find wrong reason*/
+		hf_i2c_reg_write(&hi2c3, PAC1934_ADDR, PAC193X_CMD_CTRL, &ctrl_value);
+
+		if (ret)
+		{
+			ret = -1;
+			goto out;
+		}
+		is_first = 0;
+	}
+
+	hf_i2c_reg_write_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_REFRESH_V, (uint8_t *)&ctrl_value, 0);
+	osDelay(1);
+	ret = hf_i2c_reg_read(&hi2c3, PAC1934_ADDR, PAC193X_CMD_NEG_PWR_ACT, &act_val);
+	if (ret)
+	{
+		printf("get PAC1934 act_val error\n");
+		ret = -1;
+		goto out;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VBUS1, (uint8_t *)&reg_bus, 2);
+	if (ret)
+	{
+		printf("get PAC1934 voltage error\n");
+		ret = -1;
+		goto out;
+	}
+	reg_bus = reg_bus & 0XFFFF;
+	reg_bus = SWAP16(reg_bus);
+	if (0x1 == ((act_val >> 3) & 0x1))
+	{
+		*volt = reg_bus * 1000 / 1024;
+		is_neg = 1;
+	}
+	else
+	{
+		*volt = reg_bus * 1000 / 2048;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VSENSE1, (uint8_t *)&reg_curr, 2);
+	reg_curr = SWAP16(reg_curr);
+	if (ret)
+	{
+		printf("get PAC1934 current error\n");
+		ret = -1;
+		goto out;
+	}
+	reg_curr = reg_curr & 0XFFFF;
+	if (0x1 == ((act_val >> 7) & 0x1))
+	{
+		*curr = reg_curr * PAC193X_COSTANT_CURRENT_M / (32768 * PAC193X_SHUNT_RESISTOR_M);
+		is_neg = 1;
+	}
+	else
+	{
+		*curr = reg_curr * PAC193X_COSTANT_CURRENT_M / (65536 * PAC193X_SHUNT_RESISTOR_M);
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VPOWER1, (uint8_t *)&reg_power, 4);
+	reg_power = SWAP32(reg_power);
+	if (ret)
+	{
+		printf("get PAC1934 power error\n");
+		ret = -1;
+		goto out;
+	}
+	reg_power = reg_power >> 4;
+	if (1 == is_neg)
+	{
+		*power = reg_power * PAC193X_COSTANT_PWR_M / (PAC193X_SHUNT_RESISTOR_M * 134217728ULL);
+	}
+	else
+	{
+		*power = reg_power * PAC193X_COSTANT_PWR_M / (PAC193X_SHUNT_RESISTOR_M * 268435456ULL);
+	}
+
+out:
+	taskEXIT_CRITICAL();
+	return ret;
 }
\ No newline at end of file
diff --git a/Core/Src/web-server.c b/Core/Src/web-server.c
index d262df7..8b98e3d 100644
--- a/Core/Src/web-server.c
+++ b/Core/Src/web-server.c
@@ -10463,7 +10463,7 @@ int change_power_status(int status)
 			ret = web_cmd_handle(CMD_POWER_OFF, NULL, 0, 2000);
 			if (HAL_OK != ret) {
 				change_som_power_state(SOM_POWER_OFF);
-				web_debug("Poweroff SOM error(ret %d), force shutdown it!\n", ret);
+				printf("Poweroff SOM error(ret %d), force shutdown it!\n", ret);
 				ret = HAL_OK;
 				return ret;
 			}
@@ -10500,7 +10500,7 @@ int xSOMRebootHandle(void)
 		som_reset_control(pdTRUE);
 		osDelay(10);
 		som_reset_control(pdFALSE);
-		web_debug("Faild to reboot SOM(ret %d), force reset SOM!\n", ret);
+		printf("Faild to reboot SOM(ret %d), force reset SOM!\n", ret);
 		ret = HAL_OK;
 		return ret;
 	}
@@ -10516,7 +10516,7 @@ int xSOMRestartHandle(void)
 
 	ret = web_cmd_handle(CMD_RESTART, NULL, 0, 2000);
 	if (HAL_OK != ret) {
-		web_debug("Faild to restart SOM(ret %d), force restart SOM!\n", ret);
+		printf("Faild to restart SOM(ret %d), force restart SOM!\n", ret);
 		vRestartSOM();
 		ret = HAL_OK;
 		return ret;
@@ -10532,10 +10532,15 @@ power_info get_power_info(void)
 	power_info power_info = {0};
 	int ret = HAL_OK;
 
+#if 0
 	ret = web_cmd_handle(CMD_POWER_INFO, &power_info, sizeof(power_info), 1000);
 	if (HAL_OK != ret) {
 		web_debug("Failed to get power info %d\n", ret);
 	}
+#else
+	if (get_power_status())
+		get_board_power(&power_info.voltage,&power_info.current,&power_info.consumption);
+#endif
 	web_debug("web call get_power_info, consumption %d, current %d, voltage %d, ret %d\n",
 		power_info->consumption, power_info->current, power_info->voltage, ret);
 	return power_info;
-- 
2.25.1

