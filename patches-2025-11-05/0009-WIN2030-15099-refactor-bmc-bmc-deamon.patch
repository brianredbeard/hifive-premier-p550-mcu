From b5077d066f1d075b264d8ac130e9160ed813a435 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E2=80=9Chuangyifeng=E2=80=9D?=
 <huangyifeng@eswincomputing.com>
Date: Mon, 29 Apr 2024 19:56:21 +0800
Subject: [PATCH 009/109] WIN2030-15099:refactor(bmc):bmc deamon

Changelogs:
  At this point,
1.using uart dma, mcu could send msg to u84, u84 handle the msg, then
reply to mcu.
2.uart task could parase the mssage, travse the list;
3.fix the ring buffer bug when wirte and read pointer reach the tail
ponite

Change-Id: I3a70dc67647acf370da7434dfe10aca477fc14ca
---
 Core/Inc/hf_common.h               |  39 +++++
 Core/Src/hf_board_init.c           |   2 +-
 Core/Src/hf_it_callback.c          |  28 +++-
 Core/Src/hf_power_process.c        |   2 +-
 Core/Src/hf_protocol_process.c     | 238 +++++++++++++++++++++++++++--
 Core/Src/main.c                    |  13 +-
 Core/Src/protocol_lib/protocol.c   |   6 +-
 Core/Src/protocol_lib/protocol.h   |   1 +
 Core/Src/protocol_lib/ringbuffer.c |  20 ++-
 Core/Src/protocol_lib/ringbuffer.h |   1 +
 Core/Src/stm32f4xx_hal_msp.c       |   5 +-
 11 files changed, 329 insertions(+), 26 deletions(-)

diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index 8a7d6d1..e96a030 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -9,6 +9,10 @@ extern "C" {
 /* Includes ------------------------------------------------------------------*/
 #include <stdio.h>
 #include "stm32f4xx_hal.h"
+#include "FreeRTOS.h"
+#include "list.h"
+#include "task.h"
+
 /* types ------------------------------------------------------------*/
 typedef enum {
   IDLE_STATE,
@@ -35,6 +39,41 @@ typedef enum {
   SOM_POWER_OFF,
   SOM_POWER_ON
 } power_switch_t;
+
+#define FRAME_DATA_MAX 250
+
+// Define command types
+typedef enum {
+	CMD_POWER_OFF = 0x01,
+	CMD_RESET = 0x02,
+	CMD_READ_BOARD_INFO = 0x03,
+	CMD_CONTROL_LED = 0x04,
+	// You can continue adding other command types
+} CommandType;
+
+// Message structure
+typedef struct {
+	uint32_t header;	// Frame header
+	uint32_t xTaskToNotify; // id
+	uint8_t msg_type; 	// Message type
+	uint8_t cmd_type; 	// Command type
+	uint8_t cmd_result;  // command result
+	uint8_t data_len; 	// Data length
+	uint8_t data[FRAME_DATA_MAX]; // Data
+	uint8_t checksum; 	// Checksum
+	uint32_t tail;		// Frame tail
+} __attribute__((packed)) Message;
+
+// WebCmd structure
+typedef struct {
+	ListItem_t xListItem; 	// FreeRTOS list item, must be the first member of the struct
+	TaskHandle_t xTaskToNotify;
+	uint8_t cmd_result;  // command result
+	uint8_t data[FRAME_DATA_MAX]; // command result Data
+} WebCmd;
+
+extern uint8_t UART4_RxBuf[sizeof(Message)];
+
 /* constants --------------------------------------------------------*/
 /* macro ------------------------------------------------------------*/
 /* define ------------------------------------------------------------*/
diff --git a/Core/Src/hf_board_init.c b/Core/Src/hf_board_init.c
index 3ed61ae..c23bf22 100644
--- a/Core/Src/hf_board_init.c
+++ b/Core/Src/hf_board_init.c
@@ -141,7 +141,7 @@ int board_init(void)
 	MX_RNG_Init();
 	// MX_TIM5_Init();
 	/* There is leakage, the som must be released before initialization */
-	// MX_UART4_Init();
+	MX_UART4_Init();
 	// MX_USART6_UART_Init();
 
 	/* To ensure that the i2c runs properly, initialize the som after it is powered on */
diff --git a/Core/Src/hf_it_callback.c b/Core/Src/hf_it_callback.c
index 77cbd7e..fcff0ac 100644
--- a/Core/Src/hf_it_callback.c
+++ b/Core/Src/hf_it_callback.c
@@ -70,6 +70,7 @@ void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
 }
 
 extern DMA_HandleTypeDef hdma_usart3_rx;
+extern DMA_HandleTypeDef hdma_uart4_rx;
 
 #include "protocol_lib/protocol.h"
 #include "protocol_lib/ringbuffer.h"
@@ -77,19 +78,40 @@ extern DMA_HandleTypeDef hdma_usart3_rx;
 extern uint32_t RxBuf_SIZE;
 extern uint8_t RxBuf[96];
 extern b_frame_class_t frame_uart3;
+extern b_frame_class_t frame_uart4;
+
+static void buf_dump(uint8_t *data)
+{
+	int i;
+
+	for (i = 0; i < sizeof(UART4_RxBuf); i++) {
+		printf("0x%x ", UART4_RxBuf[i]);
+		if (i != 0 && i % 20 == 0) {
+			printf("\n");
+		}
+	}
+	printf("\n");
+}
+
 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
 {
 	if (huart->Instance == USART3) {
-		printf("%s Size %d sizeof(RxBuf) %d\n", __func__, Size, sizeof(RxBuf));
+		printf("%s Size %d sizeof(UART3_RxBuf) %d\n", __func__, Size, sizeof(RxBuf));
 		es_frame_put(&frame_uart3, RxBuf, Size);
 		memset(RxBuf, 0, sizeof(RxBuf) / sizeof(uint8_t));
-
 		HAL_UARTEx_ReceiveToIdle_DMA(&huart3, RxBuf, RxBuf_SIZE);
 		__HAL_DMA_DISABLE_IT(&hdma_usart3_rx, DMA_IT_HT);
+	} else if (huart->Instance == UART4) {
+		printf("%s Size %d sizeof(UART4_RxBuf) %d\n", __func__, Size, sizeof(UART4_RxBuf));
+		if (HAL_UART_RXEVENT_TC == huart->RxEventType) {
+			buf_dump(UART4_RxBuf);
+			es_frame_put(&frame_uart4, UART4_RxBuf, sizeof(UART4_RxBuf));
+			memset(UART4_RxBuf, 0, sizeof(UART4_RxBuf) / sizeof(uint8_t));
+			HAL_UARTEx_ReceiveToIdle_DMA(&huart4, UART4_RxBuf, sizeof(UART4_RxBuf));
+		}
 	}
 }
 
-
 /**
   * @brief  Input Capture callback in non-blocking mode
   * @param  htim TIM IC handle
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index c7741ce..b66fc8f 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -8,7 +8,7 @@
 #include "hf_common.h"
 #include "hf_i2c.h"
 /* Private typedef -----------------------------------------------------------*/
-#define AUTO_BOOT
+ #define AUTO_BOOT
 /* Private define ------------------------------------------------------------*/
 #define ATX_POWER_GOOD GPIO_PIN_RESET
 #define ATX_POWER_FAIL GPIO_PIN_SET
diff --git a/Core/Src/hf_protocol_process.c b/Core/Src/hf_protocol_process.c
index e729849..993e975 100644
--- a/Core/Src/hf_protocol_process.c
+++ b/Core/Src/hf_protocol_process.c
@@ -4,16 +4,15 @@
 #include "protocol.h"
 #include "stm32f4xx.h"
 #include "stm32f4xx_hal.h"
+#include "FreeRTOS.h"
+#include "list.h"
+#include "task.h"
 
 #define head_meg "\xA5\x5A\xAA\x55"
 #define end_msg "\x0D\x0A\x0D\x0A"
 #define req_ok "\x6B\x6F"
 #define req_fail "\x6C\x69\x61\x66"
 
-uint32_t RxBuf_SIZE = 64;
-uint8_t RxBuf[96];
-b_frame_class_t frame_uart3;
-
 extern uint8_t ip_address[4];
 extern uint8_t netmask_address[4];
 extern uint8_t getway_address[4];
@@ -43,7 +42,7 @@ void es_send_req(b_frame_class_t *pframe, uint8_t req_cmd, int8_t *frame_data, u
 	memcpy(buf + b_len, pframe->frame_info.end, pframe->frame_info.end_len);
 	b_len += pframe->frame_info.end_len;
 
-	HAL_UART_Transmit(&huart3, buf, b_len, HAL_MAX_DELAY); // transmit the full sentence again
+	HAL_UART_Transmit(pframe->uart, buf, b_len, HAL_MAX_DELAY); // transmit the full sentence again
 }
 
 int32_t es_set_gpio(struct gpio_cmd *gpio)
@@ -196,7 +195,7 @@ int32_t es_set_fan_duty(struct fan_control_t *fan)
 		sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 		if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 			return HAL_ERROR;
-		
+
 		if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1) != HAL_OK)
 			return HAL_ERROR;
 	} else if (fan->fan_num == 1) {
@@ -210,7 +209,7 @@ int32_t es_set_fan_duty(struct fan_control_t *fan)
 		sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 		if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 			return HAL_ERROR;
-		
+
 		if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2) != HAL_OK)
 			return HAL_ERROR;
 	} else {
@@ -308,6 +307,10 @@ void es_process_cmd(b_frame_class_t *pframe)
 	}
 }
 
+uint32_t RxBuf_SIZE = 64;
+uint8_t RxBuf[96];
+b_frame_class_t frame_uart3;
+void deamon_test(void);
 void protocol_task(void *argument)
 {
 	// printf("%s %d\n", __func__, __LINE__);
@@ -318,12 +321,14 @@ void protocol_task(void *argument)
 	frame_info.end_len = sizeof(end_msg) - 1;
 	frame_info.pname = "uart3";
 	frame_uart3._in_frame_buffer_size = 256;
+	frame_uart3.uart = &huart3;
 	es_frame_init(&frame_uart3, &frame_info);
 	/* enable uart3 dma rx */
-	HAL_UARTEx_ReceiveToIdle_DMA(&huart3, RxBuf, RxBuf_SIZE);
+	HAL_UARTEx_ReceiveToIdle_DMA(frame_uart3.uart, RxBuf, RxBuf_SIZE);
 
 	uint8_t protocol_status = 0;
 	for (;;) {
+		deamon_test();
 		switch (protocol_status) {
 		case CHECK_HEAD:
 			if (!es_check_head(&frame_uart3))
@@ -355,6 +360,221 @@ void protocol_task(void *argument)
 		default:
 			protocol_status = CHECK_HEAD;
 		}
-		osDelay(900);
+		osDelay(10);
+	}
+}
+
+#define FRAME_HEADER    0xA55AAA55
+#define FRAME_TAIL      0xBDBABDBA
+
+uint8_t UART4_RxBuf[sizeof(Message)];
+b_frame_class_t frame_uart4;
+extern DMA_HandleTypeDef hdma_uart4_rx;
+// Define a global list
+List_t WebCmdList;
+
+// Define command types
+typedef enum {
+	MSG_REQUEST = 0x01,
+	MSG_REPLY = 0x02,
+} MsgType;
+
+void dump_message(Message data)
+{
+	printf("Header: 0x%lX, Cmd Type: 0x%x, Data Len: %d, Checksum: 0x%X, Tail: 0x%lx\n",
+		data.header, data.cmd_type, data.data_len, data.checksum, data.tail);
+}
+// Function to check message checksum
+int check_checksum(Message *msg)
+{
+	unsigned char checksum = 0;
+	checksum ^= msg->msg_type;
+	checksum ^= msg->cmd_type;
+	checksum ^= msg->data_len;
+	for (int i = 0; i < msg->data_len; ++i) {
+		checksum ^= msg->data[i];
+	}
+	return checksum == msg->checksum;
+}
+
+void generate_checksum(Message *msg)
+{
+	unsigned char checksum = 0;
+	checksum ^= msg->msg_type;
+	checksum ^= msg->cmd_type;
+	checksum ^= msg->data_len;
+	for (int i = 0; i < msg->data_len; ++i) {
+		checksum ^= msg->data[i];
+	}
+	msg->checksum = checksum;
+}
+
+BaseType_t transmit_deamon_request(Message *msg)
+{
+	UART_HandleTypeDef *huart = &huart4;
+
+	generate_checksum(msg);
+	// Transmit using DMA
+	HAL_StatusTypeDef status = HAL_UART_Transmit(huart, (uint8_t *)msg,
+			sizeof(Message), HAL_MAX_DELAY);
+	if (status == HAL_OK) {
+		return status; // Successful transmission
+	} else {
+		printf("[%s %d]:Failed to transmit msg, status %d!\n",__func__,__LINE__, status);
+		return status; // Transmission failed
+	}
+}
+int web_cmd_handle(CommandType cmd, void *data, int data_len)
+{
+	HAL_StatusTypeDef status;
+	uint32_t ulNotificationValue;
+	int ret = -HAL_ERROR;
+
+	WebCmd webcmd = {
+		.cmd_result = -1,
+		.data = {0},
+		.xTaskToNotify = xTaskGetCurrentTaskHandle(),
+	};
+
+	Message msg = {
+		.header = FRAME_HEADER,
+		.msg_type = MSG_REQUEST,
+		.cmd_type = cmd,
+		.data_len = data_len,
+		.tail = FRAME_TAIL,
+	};
+
+	/*Add webcmd to waiting list*/
+		// Initialize list item
+	vListInitialiseItem(&(webcmd.xListItem));
+		// Set the list item owner
+	listSET_LIST_ITEM_OWNER(&(webcmd.xListItem), &webcmd);
+		// Enter critical section to ensure thread safety when inserting item
+	taskENTER_CRITICAL();
+	vListInsertEnd(&WebCmdList, &(webcmd.xListItem));
+	taskEXIT_CRITICAL();
+
+	msg.xTaskToNotify = (uint32_t)webcmd.xTaskToNotify;
+	dump_message(msg);
+	status = transmit_deamon_request(&msg);
+	if (HAL_OK != status) {
+		ret = status;
+		goto err_msg;
+	}
+	/*wait 100ms to get the result*/
+	if (xTaskNotifyWait(0, 0, &ulNotificationValue, pdMS_TO_TICKS(100)) == pdTRUE) {
+		ret = webcmd.cmd_result;
+		memcpy(data, webcmd.data, data_len);
+	} else {
+		ret = -HAL_TIMEOUT;
+		goto err_msg;
+	}
+	return ret;
+
+err_msg:
+	taskENTER_CRITICAL();
+	uxListRemove(&(webcmd.xListItem));
+	taskEXIT_CRITICAL();
+	return ret;
+}
+
+void handle_deamon_mesage(Message *msg)
+{
+	if (MSG_REPLY == msg->msg_type) {
+		if (!listLIST_IS_EMPTY(&WebCmdList)) {
+			// Enter critical section to ensure thread safety when traversing and deleting
+			taskENTER_CRITICAL();
+			for (ListItem_t *pxItem = listGET_HEAD_ENTRY(&WebCmdList);
+				pxItem != listGET_END_MARKER(&WebCmdList);) {
+					WebCmd * pxWebCmd = (WebCmd *)listGET_LIST_ITEM_OWNER(pxItem);
+					// Get the next item before deleting the current one
+					ListItem_t *pxNextItem = listGET_NEXT(pxItem);
+					if ((uint32_t)pxWebCmd->xTaskToNotify == msg->xTaskToNotify) {
+						pxWebCmd->cmd_result = msg->cmd_result;
+						memcpy(pxWebCmd->data, msg->data, msg->data_len);
+						// Remove the current item from the list
+						uxListRemove(pxItem);
+						xTaskNotifyGive(pxWebCmd->xTaskToNotify);
+					}
+					// Move to the next item
+					pxItem = pxNextItem;
+			}
+			taskEXIT_CRITICAL();
+		}
+	}else {
+		printf("Unsupport msg type: 0x%x\n", msg->cmd_type);
+		dump_message(*msg);
+	}
+}
+
+volatile int g_test_flag = 0;
+void deamon_test(void)
+{
+	int ret;
+	char data[FRAME_DATA_MAX];
+
+	if (g_test_flag == 0)
+		return;
+
+	ret = web_cmd_handle(CMD_READ_BOARD_INFO, data, FRAME_DATA_MAX);
+
+	//pass
+	printf("call read borad info, result 0x%x, data %s\n", ret, data);
+	g_test_flag = 0;
+	return;//0 success,TODO call
+}
+
+void uart4_protocol_task(void *argument)
+{
+	b_frame_t frame_info;
+	ring_buf_t *ring;
+	int32_t len;
+	Message msg;
+
+	frame_info.head = head_meg;
+	frame_info.head_len = sizeof(head_meg) - 1;
+	frame_info.end = end_msg;
+	frame_info.end_len = sizeof(end_msg) - 1;
+	frame_info.pname = "uart4";
+	frame_uart4.uart = &huart4;
+	frame_uart4._in_frame_buffer_size = sizeof(UART4_RxBuf);
+
+	//Init msg ring buffer for deamon
+	es_frame_init(&frame_uart4, &frame_info);
+	ring = &frame_uart4._frame_ring;
+
+	//Init web server msg list
+	vListInitialise(&WebCmdList);
+
+	//trigger uart rx
+	HAL_UARTEx_ReceiveToIdle_DMA(&huart4, UART4_RxBuf, sizeof(UART4_RxBuf));
+	for (;;) {
+		len = get_ring_buf_len(ring);
+		if (!len) {
+			osDelay(10);
+			continue;
+		}
+		if (len < sizeof(msg)) {
+
+		}
+		len = read_ring_buf(ring, (uint8_t *)&msg, sizeof(msg));
+		if (len != sizeof(msg)) {
+
+		}
+
+		if (msg.header == FRAME_HEADER && msg.tail == FRAME_TAIL) {
+			// Check checksum
+			if (check_checksum(&msg)) {
+				// handle command
+				handle_deamon_mesage(&msg);
+			} else {
+				printf("Checksum error!\n");
+				dump_message(msg);
+			}
+		} else {
+			printf("Invalid message format!\n");
+			dump_message(msg);
+		}
+		osDelay(10);
 	}
 }
\ No newline at end of file
diff --git a/Core/Src/main.c b/Core/Src/main.c
index 6321375..c0dd55d 100644
--- a/Core/Src/main.c
+++ b/Core/Src/main.c
@@ -37,9 +37,10 @@ const osThreadAttr_t main_task_attributes = {
 };
 
 osThreadId_t protocol_task_handle;
+osThreadId_t uart4_protocol_task_handle;
 const osThreadAttr_t protocol_task_attributes = {
   .name = "protocolTask",
-  .stack_size = 1024*8,
+  .stack_size = 1024*2,
   .priority = (osPriority_t) osPriorityNormal,
 };
 
@@ -75,6 +76,7 @@ const osThreadAttr_t MoniterTask_attributes = {
 void hf_main_task(void *argument);
 void MoniterTask(void *argument);
 void protocol_task(void *argument);
+void uart4_protocol_task(void *argument);
 
 /* Private user code ---------------------------------------------------------*/
 
@@ -143,8 +145,9 @@ void hf_main_task(void *argument)
   http_task_handle = osThreadNew(hf_http_task, NULL, &http_task_attributes);
   // moniter_task_handle = osThreadNew(MoniterTask, NULL, &MoniterTask_attributes);
   protocol_task_handle = osThreadNew(protocol_task, NULL, &protocol_task_attributes);
+  uart4_protocol_task_handle = osThreadNew(uart4_protocol_task, NULL, &protocol_task_attributes);
   osDelay(900);
-  printf("HiFive 106SC \n");
+  printf("HiFive 106SC!\n");
   // extern void MX_IWDG_Init(void);
 
 	// MX_IWDG_Init();
@@ -211,12 +214,12 @@ void get_rtc_info(void)
   // HAL_RTC_GetAlarm(&hrtc, &alarm1, RTC_ALARM_A, RTC_FORMAT_BCD);
   // HAL_RTC_GetAlarm(&hrtc, &alarm2, RTC_ALARM_B, RTC_FORMAT_BCD);
   // printf("alarm1 info :\n");
-  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n", 
+  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n",
   //       alarm1.AlarmMask, alarm1.AlarmSubSecondMask, alarm1.AlarmDateWeekDaySel, alarm1.AlarmDateWeekDay, alarm1.Alarm );
   // printf("%02d/%02d/%02d\r\n",alarm1.AlarmTime.Hours, alarm1.AlarmTime.Minutes, alarm1.AlarmTime.Seconds);
 
   // printf("alarm2 info :\n");
-  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n", 
+  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n",
   //       alarm2.AlarmMask, alarm2.AlarmSubSecondMask, alarm2.AlarmDateWeekDaySel, alarm2.AlarmDateWeekDay, alarm2.Alarm );
   // printf("%02d/%02d/%02d\r\n",alarm2.AlarmTime.Hours, alarm2.AlarmTime.Minutes, alarm2.AlarmTime.Seconds);
   // printf("\r\n");
@@ -260,7 +263,7 @@ void MoniterTask(void *argument)
               printf("stack high water mark: %d\r\n",TaskStatus.usStackHighWaterMark);
         }
     }
-    vPortFree(StatusArray); 
+    vPortFree(StatusArray);
     osDelay(5000);
 
   }
diff --git a/Core/Src/protocol_lib/protocol.c b/Core/Src/protocol_lib/protocol.c
index 68bc28b..6b265e7 100644
--- a/Core/Src/protocol_lib/protocol.c
+++ b/Core/Src/protocol_lib/protocol.c
@@ -31,7 +31,7 @@ uint8_t es_frame_put(b_frame_class_t *pframe, uint8_t *dat, uint32_t len)
 	if (!dat || len == 0) {
 		return B_ERROR;
 	}
-	uint8_t putlen = write_ring_buf(&pframe->_frame_ring, dat, len);
+	uint32_t putlen = write_ring_buf(&pframe->_frame_ring, dat, len);
 
 	if (putlen != len) {
 		ring_buf_clr(&pframe->_frame_ring);
@@ -64,9 +64,9 @@ uint8_t es_check_head(b_frame_class_t *pframe)
 	do {
 		read_ring_buf(&pframe->_frame_ring, &tmp, 1);
 		if (tmp == pframe->frame_info.head[i]) {
-			// printf("tmp(%d) %x \n", i, tmp);
+			printf("tmp(%d) %x \n", i, tmp);
 			if (++i == pframe->frame_info.head_len) {
-				// printf("%s %d B_SUCCESS\n", __func__, __LINE__);
+				printf("%s %d B_SUCCESS\n", __func__, __LINE__);
 				return B_SUCCESS;
 			}
 		} else {
diff --git a/Core/Src/protocol_lib/protocol.h b/Core/Src/protocol_lib/protocol.h
index 9baae49..e64a47c 100644
--- a/Core/Src/protocol_lib/protocol.h
+++ b/Core/Src/protocol_lib/protocol.h
@@ -94,6 +94,7 @@ typedef struct {
 	ring_buf_t _frame_ring;
 	uint32_t _in_frame_buffer_size;
 	struct frame_data frame;
+	UART_HandleTypeDef *uart;
 } b_frame_class_t;
 
 typedef enum protocol_status_type {
diff --git a/Core/Src/protocol_lib/ringbuffer.c b/Core/Src/protocol_lib/ringbuffer.c
index 197ec2d..1eda808 100644
--- a/Core/Src/protocol_lib/ringbuffer.c
+++ b/Core/Src/protocol_lib/ringbuffer.c
@@ -19,9 +19,10 @@ uint8_t ring_buf_init(ring_buf_t *r, uint32_t size)
 	}
 	memset(r->pHead, 0, sizeof(size));
 
-	r->pWrite = r->pHead;
-	r->pRead = r->pHead;
-	r->pTail = r->pHead + size;
+    r->pWrite = r->pHead;
+    r->pRead = r->pHead;
+    r->pTail = r->pHead + size;
+    r->is_full = 0; // Initialize is_full to false
 
 	return B_SUCCESS;
 }
@@ -39,6 +40,7 @@ void ring_buf_clr(ring_buf_t *r)
 	}
 	r->pWrite = r->pHead;
 	r->pRead = r->pHead;
+    r->is_full = 0; // Clear the is_full flag
 }
 
 int32_t get_ring_buf_len(ring_buf_t *r)
@@ -49,6 +51,9 @@ int32_t get_ring_buf_len(ring_buf_t *r)
 		printf("%s : RingBuff is not Init!\n", __func__);
 		return -1;
 	}
+    if (r->is_full) {
+        return r->pTail - r->pHead; // If buffer is full, length is equal to size
+    }
 	if (r->pRead > r->pWrite) {
 		len = r->pTail - r->pRead;
 		len += r->pWrite - r->pHead;
@@ -65,6 +70,9 @@ int32_t get_ring_buf_free_space(ring_buf_t *r)
 		printf("%s : RingBuff is not Init!\n", __func__);
 		return -1;
 	}
+    if (r->is_full) {
+        return 0; // If buffer is full, free space is 0
+    }
 	if (r->pRead > r->pWrite) {
 		len = r->pRead - r->pWrite;
 	} else {
@@ -98,6 +106,8 @@ int32_t write_ring_buf(ring_buf_t *r, uint8_t *pBuff, uint32_t len)
 		memcpy(r->pWrite, pBuff, len);
 		r->pWrite += len;
 	}
+    if (r->pWrite == r->pRead)
+        r->is_full = 1; // Update is_full flag
 	return len;
 }
 
@@ -120,6 +130,8 @@ int32_t read_ring_buf(ring_buf_t *r, uint8_t *pBuff, uint32_t len)
 		printf("%s :Read buff size is larger than the valid area!\n", __func__);
 		return -1;
 	}
+    if (r->is_full)
+        r->is_full = 0; // Clear is_full flag when reading
 
 	if (r->pRead + len > r->pTail) {
 		uint32_t pre_len = r->pTail - r->pRead;
@@ -184,4 +196,6 @@ uint32_t ring_buf_clr_len(ring_buf_t *r, uint32_t len)
 	} else {
 		r->pRead += len;
 	}
+    if (r->pRead == r->pWrite)
+        r->is_full = 0; // Update is_full flag after clearing
 }
\ No newline at end of file
diff --git a/Core/Src/protocol_lib/ringbuffer.h b/Core/Src/protocol_lib/ringbuffer.h
index f5ce8b6..5bff552 100644
--- a/Core/Src/protocol_lib/ringbuffer.h
+++ b/Core/Src/protocol_lib/ringbuffer.h
@@ -15,6 +15,7 @@ typedef struct {
     uint8_t *pTail;
     uint8_t *pWrite;
     uint8_t *pRead;
+    uint8_t is_full; // New member to indicate if the ring buffer is full
 }ring_buf_t;
 
 uint8_t ring_buf_init(ring_buf_t *r, uint32_t size);
diff --git a/Core/Src/stm32f4xx_hal_msp.c b/Core/Src/stm32f4xx_hal_msp.c
index 0201441..530e2ed 100644
--- a/Core/Src/stm32f4xx_hal_msp.c
+++ b/Core/Src/stm32f4xx_hal_msp.c
@@ -898,7 +898,10 @@ void HAL_UART_MspInit(UART_HandleTypeDef* huart)
     hdma_uart4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
     hdma_uart4_rx.Init.Mode = DMA_NORMAL;
     hdma_uart4_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
-    hdma_uart4_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
+    hdma_uart4_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
+    hdma_uart4_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
+    hdma_uart4_rx.Init.MemBurst = DMA_MBURST_SINGLE;
+    hdma_uart4_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
     if (HAL_DMA_Init(&hdma_uart4_rx) != HAL_OK)
     {
       Error_Handler();
-- 
2.25.1

