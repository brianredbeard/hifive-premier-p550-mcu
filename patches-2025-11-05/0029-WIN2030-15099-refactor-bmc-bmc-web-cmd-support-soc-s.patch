From 9c2aa7effcd451e548627f0bb949de1f2188e397 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E2=80=9Chuangyifeng=E2=80=9D?=
 <huangyifeng@eswincomputing.com>
Date: Tue, 14 May 2024 13:49:06 +0800
Subject: [PATCH 029/109] WIN2030-15099:refactor(bmc):bmc web cmd support soc
 status

Changelogs:
    1. support web get soc status
    2. when web request reboot, start a timer to force reset if reboot
timeout.

Change-Id: Ic6ba24839c8cf9fa89c70144d20f98c1bf891a14
---
 Core/Inc/hf_common.h           |  4 ++-
 Core/Src/hf_gpio_process.c     |  1 +
 Core/Src/hf_protocol_process.c | 60 +++++++++++++++++++++++++++-------
 Core/Src/web-server.c          | 13 +++++---
 4 files changed, 60 insertions(+), 18 deletions(-)

diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index b6dfa4c..b80f33b 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -258,7 +258,9 @@ void change_som_power_state(power_switch_t newState);
 deamon_stats_t get_som_daemon_state(void);
 void change_som_daemon_state(deamon_stats_t newState);
 
-void TriggerSomTimer(void);
+void TriggerSomPowerOffTimer(void);
+void TriggerSomRebootTimer(void);
+void StopSomRebootTimer(void);
 
 void set_bootsel(uint8_t is_soft_crtl, uint8_t sel);
 
diff --git a/Core/Src/hf_gpio_process.c b/Core/Src/hf_gpio_process.c
index 9427299..b09a51e 100644
--- a/Core/Src/hf_gpio_process.c
+++ b/Core/Src/hf_gpio_process.c
@@ -138,6 +138,7 @@ static void key_process(void)
 static void mcu_reset_som_process(void)
 {
 	printf("%s %d mcu reset som\n", __func__, __LINE__);
+	StopSomRebootTimer();
 }
 
 static void som_rst_feedback_process(void)
diff --git a/Core/Src/hf_protocol_process.c b/Core/Src/hf_protocol_process.c
index cd418a7..9f57f76 100644
--- a/Core/Src/hf_protocol_process.c
+++ b/Core/Src/hf_protocol_process.c
@@ -419,7 +419,8 @@ void dump_message(Message data)
 }
 // Define a mutex handle
 SemaphoreHandle_t xMutex = NULL;
-TimerHandle_t xSomTimer;
+TimerHandle_t xSomPowerOffTimer;
+TimerHandle_t xSomRebootTimer;
 
 // Function to initialize the mutex
 void init_transmit_mutex(void) {
@@ -472,7 +473,7 @@ void generate_checksum(Message *msg)
 	msg->checksum = checksum;
 }
 
-BaseType_t transmit_deamon_request(Message *msg)
+static BaseType_t xTransmitRequestToSOM(Message *msg)
 {
 	UART_HandleTypeDef *huart = &huart4;
 
@@ -514,7 +515,10 @@ int web_cmd_handle(CommandType cmd, void *data, int data_len, uint32_t timeout)
 		.data_len = data_len,
 		.tail = FRAME_TAIL,
 	};
-
+	if (SOM_POWER_ON != get_som_power_state()) {
+		ret = HAL_ERROR;
+		return ret;
+	}
 	/*Add webcmd to waiting list*/
 		// Initialize list item
 	vListInitialiseItem(&(webcmd.xListItem));
@@ -527,14 +531,17 @@ int web_cmd_handle(CommandType cmd, void *data, int data_len, uint32_t timeout)
 
 	msg.xTaskToNotify = (uint32_t)webcmd.xTaskToNotify;
 	//dump_message(msg);
-	status = transmit_deamon_request(&msg);
+	status = xTransmitRequestToSOM(&msg);
 	if (HAL_OK != status) {
 		ret = status;
 		goto err_msg;
 	}
-	/*wait 100ms to get the result*/
+	/*wait to get the result*/
 	if (xTaskNotifyWait(0, 0, &ulNotificationValue, pdMS_TO_TICKS(timeout)) == pdTRUE) {
 		ret = webcmd.cmd_result;
+		if (HAL_OK != ret) {
+			printf("[%s %d]:Som process cmd %d failed, ret %d\n",__func__,__LINE__, cmd, ret);
+		}
 		memcpy(data, webcmd.data, data_len);
 	} else {
 		ret = HAL_TIMEOUT;
@@ -664,7 +671,7 @@ void handle_som_mesage(Message *msg)
 	}
 }
 
-void vSomTimerCallback(TimerHandle_t xSomTimer)
+void vSomPowerOffTimerCallback(TimerHandle_t xSomPowerOffTimer)
 {
 	if (SOM_POWER_OFF != get_som_power_state()) {
 		change_som_power_state(SOM_POWER_OFF);
@@ -672,9 +679,30 @@ void vSomTimerCallback(TimerHandle_t xSomTimer)
 	}
 }
 
-void TriggerSomTimer(void)
+void TriggerSomPowerOffTimer(void)
+{
+	if (xTimerStart(xSomPowerOffTimer, 0) != pdPASS) {
+		printf("Failed to trigger Som timer!\n");
+	}
+}
+
+void vSomRebootTimerCallback(TimerHandle_t xSomRebootTimer)
+{
+	som_reset_control(pdTRUE);
+	osDelay(10);
+	som_reset_control(pdFALSE);
+	printf("reboot SOM timeout, force reset SOM!\n");
+}
+
+void TriggerSomRebootTimer(void)
+{
+	if (xTimerStart(xSomRebootTimer, 0) != pdPASS) {
+		printf("Failed to trigger Som timer!\n");
+	}
+}
+void StopSomRebootTimer(void)
 {
-	if (xTimerStart(xSomTimer, 0) != pdPASS) {
+	if (xTimerStop(xSomRebootTimer, 0) != pdPASS) {
 		printf("Failed to trigger Som timer!\n");
 	}
 }
@@ -697,14 +725,22 @@ void uart4_protocol_task(void *argument)
 	vListInitialise(&WebCmdList);
 
 	/* Create a timer with a timeout set to 5 seconds */
-	xSomTimer = xTimerCreate( "SomTimer", (5000 / portTICK_PERIOD_MS),
-			pdFALSE, (void *)0, vSomTimerCallback);
+	xSomPowerOffTimer = xTimerCreate( "SomPowerOffTimer", pdMS_TO_TICKS(5000),
+			pdFALSE, (void *)0, vSomPowerOffTimerCallback);
 
-	if (xSomTimer == NULL) {
-		printf("[%s %d]:Failed to create SOM Timer!\n",__func__,__LINE__);
+	if (xSomPowerOffTimer == NULL) {
+		printf("[%s %d]:Failed to create SOM poweroff timer!\n",__func__,__LINE__);
 		return;
 	}
 
+	/* Create a timer with a timeout set to 5 seconds */
+	xSomRebootTimer = xTimerCreate( "SomRebootTimer", pdMS_TO_TICKS(5000),
+			pdFALSE, (void *)0, vSomRebootTimerCallback);
+
+	if (xSomRebootTimer == NULL) {
+		printf("[%s %d]:Failed to create SOM reboot timer!\n",__func__,__LINE__);
+		return;
+	}
 	for (;;) {
 		if (xQueueReceive(xUart4MsgQueue, &(msg), portMAX_DELAY)) {
 			if (msg.header == FRAME_HEADER && msg.tail == FRAME_TAIL) {
diff --git a/Core/Src/web-server.c b/Core/Src/web-server.c
index 87cf51b..2e5d19e 100644
--- a/Core/Src/web-server.c
+++ b/Core/Src/web-server.c
@@ -10599,7 +10599,7 @@ static int change_power_status(int status)
 				return ret;
 			}
 			// Trigger the Som timer to enusre SOM could poweroff in 5 senconds
-			TriggerSomTimer();
+			TriggerSomPowerOffTimer();
 		} else {
 			printf("SOM already power off!\n");
 		}
@@ -10632,9 +10632,11 @@ int reset()
 		som_reset_control(pdTRUE);
 		osDelay(10);
 		som_reset_control(pdFALSE);
+		printf("Faild to reboot SOM(ret %d), force reset SOM!\n", ret);
 		ret = HAL_OK;
-		printf("Faild to reboot SOM, force reset SOM %d\n", ret);
 	}
+	// Trigger the Som timer to enusre SOM could reboot in 5 senconds
+	TriggerSomRebootTimer();
 	printf("web call reset, ret %d\n", ret);
 	return ret;
 }
@@ -10890,9 +10892,10 @@ int set_rtcinfo(RTCInfo rtcInfo){
 	return 0;
 }
 
-int get_soc_status(){
-	printf("TODO call get_soc_status\n");
-	return 0;//0,working,1,stopped
+//0,working,1,stopped
+int get_soc_status()
+{
+	return SOM_DAEMON_ON == get_som_daemon_state() ? 0 : 1;
 }
 
  /** Serve one HTTP connection accepted in the http thread */
-- 
2.25.1

