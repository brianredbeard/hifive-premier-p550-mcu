From def3e6bbc49cbb2b7ae570514c861c32d4776e8a Mon Sep 17 00:00:00 2001
From: linmin <linmin@eswincomputing.com>
Date: Mon, 13 May 2024 09:59:37 +0800
Subject: [PATCH 033/109] WIN2030-15099:feat(cli):Add console on uart3

Changelogs:
1.FreeRTOS_CLI is added to support command line(console) on uart3
2.Support almost all of the commands as on webserver

Change-Id: Icf04f07868ecd181668c9ea722ba8b8e8ede6683
---
 Core/Inc/FreeRTOSConfig.h                     |    1 +
 Core/Inc/console.h                            |   16 +
 Core/Inc/hf_common.h                          |   15 +-
 Core/Inc/main.h                               |    1 -
 Core/Src/console.c                            | 1266 +++++++++++++++++
 Core/Src/hf_common.c                          |   27 +-
 Core/Src/hf_power_process.c                   |    3 +-
 Core/Src/main.c                               |   11 +-
 Core/Src/web-server.c                         |   48 +-
 Core/Src/web-server.h                         |   27 +
 Makefile                                      |    2 +
 .../FreeRTOS/Source/FreeRTOS_CLI.c            |  350 +++++
 .../FreeRTOS/Source/include/FreeRTOS_CLI.h    |  116 ++
 13 files changed, 1837 insertions(+), 46 deletions(-)
 create mode 100644 Core/Inc/console.h
 create mode 100644 Core/Src/console.c
 create mode 100644 Middlewares/Third_Party/FreeRTOS/Source/FreeRTOS_CLI.c
 create mode 100644 Middlewares/Third_Party/FreeRTOS/Source/include/FreeRTOS_CLI.h

diff --git a/Core/Inc/FreeRTOSConfig.h b/Core/Inc/FreeRTOSConfig.h
index 0671cf9..242ebe3 100644
--- a/Core/Inc/FreeRTOSConfig.h
+++ b/Core/Inc/FreeRTOSConfig.h
@@ -83,6 +83,7 @@
    if lengths will always be less than the number of bytes in a size_t. */
 #define configMESSAGE_BUFFER_LENGTH_TYPE         size_t
 /* USER CODE END MESSAGE_BUFFER_LENGTH_TYPE */
+#define configCOMMAND_INT_MAX_OUTPUT_SIZE 500
 
 /* Co-routine definitions. */
 #define configUSE_CO_ROUTINES                    0
diff --git a/Core/Inc/console.h b/Core/Inc/console.h
new file mode 100644
index 0000000..38a6208
--- /dev/null
+++ b/Core/Inc/console.h
@@ -0,0 +1,16 @@
+/**
+ ******************************************************************************
+ * @file    console.h
+ * @author  Aaron Escoboza, Github account: https://github.com/aaron-ev
+ * @brief   Console header file: APIs to handle the console.
+ ******************************************************************************
+ */
+
+#ifndef __CONSOLE__H
+#define __CONSOLE__H
+
+#include "FreeRTOS.h"
+
+BaseType_t xbspConsoleInit(uint16_t usStackSize, UBaseType_t uxPriority, UART_HandleTypeDef *pxUartHandle);
+
+#endif
diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index b80f33b..10c0ffe 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -180,6 +180,8 @@ struct rtc_time_t {
 };
 
 /* constants --------------------------------------------------------*/
+extern UART_HandleTypeDef huart3;
+
 /* macro ------------------------------------------------------------*/
 #define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
 #define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
@@ -188,6 +190,9 @@ struct rtc_time_t {
 #define MAX(x , y)  (((x) > (y)) ? (x) : (y))
 #define MIN(x , y)  (((x) < (y)) ? (x) : (y))
 /* define ------------------------------------------------------------*/
+#define BMC_SOFTWARE_VERSION_MAJOR                   1
+#define BMC_SOFTWARE_VERSION_MINOR                   0
+
 #define MAGIC_NUMBER	0xdeadbeaf
 
 #define AT24C_ADDR (0x50<<1)
@@ -212,9 +217,17 @@ struct rtc_time_t {
 
 
 #define ES_EEPROM_INFO_TEST 0
+/* CLI console settings */
+#define CONSOLE_INSTANCE		USART3
+#define CONSOLE_TASK_PRIORITY		1
+#define CONSOLE_STACK_SIZE		1024//3000
+#define consoleHandle			huart3
+
+#define ES_PRODUCTION_LINE_TEST		0
 
 /* functions prototypes ---------------------------------------------*/
-void hexstr2mac(uint8_t *mac, char *hexstr);
+void hexstr2mac(uint8_t *mac, const char *hexstr);
+uint32_t atoh(const char *in, uint32_t len);
 
 void hf_http_task(void *argument);
 void es_eeprom_wp(uint8_t flag);
diff --git a/Core/Inc/main.h b/Core/Inc/main.h
index 7e76045..4ce6f59 100644
--- a/Core/Inc/main.h
+++ b/Core/Inc/main.h
@@ -48,7 +48,6 @@ extern DMA_HandleTypeDef hdma_spi2_tx;
 extern TIM_HandleTypeDef htim4;
 extern TIM_HandleTypeDef htim5;
 extern UART_HandleTypeDef huart4;
-extern UART_HandleTypeDef huart3;
 extern UART_HandleTypeDef huart6;
 extern WWDG_HandleTypeDef hwwdg;
 extern IWDG_HandleTypeDef hiwdg;
diff --git a/Core/Src/console.c b/Core/Src/console.c
new file mode 100644
index 0000000..4a9f7c7
--- /dev/null
+++ b/Core/Src/console.c
@@ -0,0 +1,1266 @@
+
+/**
+ ******************************************************************************
+ * @file         console.c
+ * @author       Aaron Escoboza, Github account: https://github.com/aaron-ev
+ * @brief        Command Line Interpreter based on FreeRTOS and STM32 HAL layer
+ ******************************************************************************
+ */
+#include "lwip/opt.h"
+#include "lwip/arch.h"
+#include "lwip/api.h"
+
+#include "FreeRTOS.h"
+#include "FreeRTOS_CLI.h"
+#include "task.h"
+#include "queue.h"
+// #include "stm32f401xc.h"
+#include "stm32f4xx_hal.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+#include "hf_common.h"
+#include "web-server.h"
+#include "hf_power_process.h"
+
+#define CONSOLE_VERSION_MAJOR                   1
+#define CONSOLE_VERSION_MINOR                   0
+
+#define MAX_IN_STR_LEN                          300
+#define MAX_OUT_STR_LEN                         600
+#define MAX_RX_QUEUE_LEN                        300
+
+                                                      /* ASCII code definition */
+#define ASCII_TAB                               '\t'  /* Tabulate              */
+#define ASCII_CR                                '\r'  /* Carriage return       */
+#define ASCII_LF                                '\n'  /* Line feed             */
+#define ASCII_BACKSPACE                         '\b'  /* Back space            */
+#define ASCII_FORM_FEED                         '\f'  /* Form feed             */
+#define ASCII_DEL                               127   /* Delete                */
+#define ASCII_CTRL_PLUS_C                         3   /* CTRL + C              */
+#define ASCII_NACK                               21   /* Negative acknowledge  */
+
+char cRxData;
+QueueHandle_t xQueueRxHandle;
+UART_HandleTypeDef *pxUartDevHandle;
+static const char *pcWelcomeMsg = "Welcome to the console. Enter 'help' to view a list of available commands.\r\n";
+
+static const char *prvpcTaskListHeader = "Task states: Bl = Blocked, Re = Ready, Ru = Running, De = Deleted,  Su = Suspended\r\n"\
+                                         "Task name         State  Priority  Stack remaining  CPU usage  Runtime(us)\r\n"\
+                                         "================= =====  ========  ===============  =========  ===========\r\n";
+static const char *prvpcPrompt = "#cmd: ";
+
+/* Command function prototypes */
+static BaseType_t prvCommandCarrierBoardInfoGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandSomBoardInfoGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+static BaseType_t prvCommandAccountGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandAccountSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+static BaseType_t prvCommandNetInfoGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandIPSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandNetMaskSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandGateWaySet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandMacSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+static BaseType_t prvCommandDipSwitchSoftGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandDipSwitchSoftSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+static BaseType_t prvCommandRtcGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandRtcDateSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandRtcTimeSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+// get the temperature and fan speed
+static BaseType_t prvCommandTempGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+// get the overall power consumption, current and voltage
+static BaseType_t prvCommandPwrDissipationGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+// get the power status of the som board: on or off
+static BaseType_t prvCommandSomPwrStatusGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+// power off or power on the som board
+static BaseType_t prvCommandSomPwrStatusSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+// get the software status of the som board: running or stopped
+static BaseType_t prvCommandSomSwWorkStatusGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+// reboot the som board
+static BaseType_t prvCommandReboot(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+// get the software version of the BMC(Baseboard Management Controller, aka mcu software verrsion)
+static BaseType_t prvCommandBMCVersion(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+
+static BaseType_t prvCommandEcho( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandTaskStats( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandHeap(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+static BaseType_t prvCommandTicks(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString);
+
+/**
+*   @brief  This function is executed in case of error occurrence.
+*   @retval None
+*/
+static const char *prvpcMapTaskState(eTaskState eState)
+{
+    switch (eState)
+    {
+        case     eReady: return "Re";
+        case   eRunning: return "Ru";
+        case   eDeleted: return "De";
+        case   eBlocked: return "Bl";
+        case eSuspended: return "S";
+        default: return "??";
+    }
+}
+
+static const CLI_Command_Definition_t xCommands[] =
+{
+    {
+        "stats",
+        "\r\nstats: Displays a table with the state of each FreeRTOS task.\r\n",
+        prvCommandTaskStats,
+        0
+    },
+    {
+        "cbinfo",
+        "\r\ncbinfo: Display carrierboard information.\r\n",
+        prvCommandCarrierBoardInfoGet,
+        0
+    },
+    {
+        "sominfo",
+        "\r\nsominfo: Display somboard information.\r\n",
+        prvCommandSomBoardInfoGet,
+        0
+    },
+    {
+        "account-g",
+        "\r\naccount-g: Show account name and password.\r\n",
+        prvCommandAccountGet,
+        0
+    },
+    {
+        "account-s",
+        "\r\naccount-s <name> <password>: Set account name and password.\r\n",
+        prvCommandAccountSet,
+        2
+    },
+    {
+        "ifconfig",
+        "\r\nifconfig: Display network configuration.\r\n",
+        prvCommandNetInfoGet,
+        0
+    },
+    {
+        "setip",
+        "\r\nsetip <ipaddrr>: Set ip address.\r\n",
+        prvCommandIPSet,
+        1
+    },
+    {
+        "setmask",
+        "\r\nsetmask <netmask>: Set netmask address.\r\n",
+        prvCommandNetMaskSet,
+        1
+    },
+    {
+        "setgateway",
+        "\r\nsetgateway <netmask>: Set gateway address.\r\n",
+        prvCommandGateWaySet,
+        1
+    },
+    {
+        "setmac",
+        "\r\nsetmac <mac,like a1:26:39:91:b0:22>: Set mac address.\r\n",
+        prvCommandMacSet,
+        1
+    },
+    {
+        "bootsel-g",
+        "\r\nbootsel-g: Show software bootsel configuration.\r\n",
+        prvCommandDipSwitchSoftGet,
+        0
+    },
+    {
+        "bootsel-s",
+        "\r\nbootsel-s <hw/sw> <bootsel(hex), like, F>: Set software bootsel configuration.\r\n",
+        prvCommandDipSwitchSoftSet,
+        2
+    },
+    {
+        "date",
+        "\r\ndate: Get the current date and time.\r\n",
+        prvCommandRtcGet,
+        0
+    },
+    {
+        "date-s",
+        "\r\ndate-s <Year> <Month> <Date> <WeekDay 1-7>: Set a new date.\r\n",
+        prvCommandRtcDateSet,
+        4
+    },
+    {
+        "time-s",
+        "\r\ntime-s <Hours> <Minutes> <Seconds>: Set a new time.\r\n",
+        prvCommandRtcTimeSet,
+        3
+    },
+    {
+        "temp",
+        "\r\ntemp: Get the temperature and fan speed.\r\n",
+        prvCommandTempGet,
+        0
+    },
+    {
+        "pd",
+        "\r\npd: Get the power dissipation\r\n",
+        prvCommandPwrDissipationGet,
+        0
+    },
+    {
+        "sompower-g",
+        "\r\nsompower-g: Get the som power status. ON or OFF.\r\n",
+        prvCommandSomPwrStatusGet,
+        0
+    },
+    {
+        "sompower-s",
+        "\r\nsompower-s <1/0>: Power (1)ON or (0)OFF.\r\n",
+        prvCommandSomPwrStatusSet,
+        1
+    },
+    {
+        "somwork",
+        "\r\nsomwork: Get the kernel work status of the som board.\r\n",
+        prvCommandSomSwWorkStatusGet,
+        0
+    },
+    {
+        "reboot",
+        "\r\nreboot: Reboot the kernel on som board.\r\n",
+        prvCommandReboot,
+        0
+    },
+    {
+       "echo",
+       "\r\necho <string to echo>\r\n",
+       prvCommandEcho,
+       1
+    },
+    {
+        "heap",
+        "\r\nheap: Display free heap memory.\r\n",
+        prvCommandHeap,
+        0
+    },
+    {
+        "ticks",
+        "\r\nticks: Display OS tick count and run time in seconds.\r\n",
+        prvCommandTicks,
+        0
+    },
+    {
+        "version",
+        "\r\nversion: Get BMC version\r\n",
+        prvCommandBMCVersion,
+        0
+    },
+    { NULL, NULL, NULL, 0 }
+};
+
+/**
+* @brief Command that gets task statistics.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandTaskStats( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    static uint32_t uTaskIndex = 0;
+    static uint32_t uTotalOfTasks = 0;
+    static uint32_t uTotalRunTime = 1;
+    TaskStatus_t *pxTmpTaskStatus = NULL;
+    static TaskStatus_t *pxTaskStatus = NULL;
+
+    if (pxTaskStatus == NULL)
+    {
+        uTotalOfTasks = uxTaskGetNumberOfTasks();
+        pxTaskStatus = pvPortMalloc(uTotalOfTasks * sizeof(TaskStatus_t));
+        if (pxTaskStatus == NULL)
+        {
+           snprintf(pcWriteBuffer, xWriteBufferLen, "Error: Not enough memory for task allocation");
+           goto out_cmd_task_stats;
+        }
+        uTotalOfTasks = uxTaskGetSystemState(pxTaskStatus, uTotalOfTasks, &uTotalRunTime);
+        uTaskIndex = 0;
+        uTotalRunTime /= 100;
+        snprintf(pcWriteBuffer, xWriteBufferLen, prvpcTaskListHeader);
+    }
+    else
+    {
+        memset(pcWriteBuffer, 0x00, MAX_OUT_STR_LEN);
+        /* Prevent from zero division */
+        if (!uTotalRunTime)
+        {
+            uTotalRunTime = 1;
+        }
+
+        pxTmpTaskStatus = &pxTaskStatus[uTaskIndex];
+        if (pxTmpTaskStatus->ulRunTimeCounter / uTotalRunTime < 1)
+        {
+         snprintf(pcWriteBuffer, xWriteBufferLen,
+                 "%-16s  %5s  %8lu  %14dB       < 1%%  %11lu\r\n",
+                 pxTmpTaskStatus->pcTaskName,
+                 prvpcMapTaskState(pxTmpTaskStatus->eCurrentState),
+                 pxTmpTaskStatus->uxCurrentPriority,
+                 pxTmpTaskStatus->usStackHighWaterMark,
+                 pxTmpTaskStatus->ulRunTimeCounter);
+        }
+        else
+        {
+            snprintf(pcWriteBuffer, xWriteBufferLen,
+                    "%-16s  %5s  %8lu  %14dB  %8lu%%  %11lu\r\n",
+                    pxTmpTaskStatus->pcTaskName,
+                    prvpcMapTaskState(pxTmpTaskStatus->eCurrentState),
+                    pxTmpTaskStatus->uxCurrentPriority,
+                    pxTmpTaskStatus->usStackHighWaterMark,
+                    pxTmpTaskStatus->ulRunTimeCounter / uTotalRunTime,
+                    pxTmpTaskStatus->ulRunTimeCounter);
+        }
+        uTaskIndex++;
+    }
+
+    /* Check if there is more tasks to be process */
+    if (uTaskIndex < uTotalOfTasks)
+       return pdTRUE;
+    else
+    {
+out_cmd_task_stats :
+        if (pxTaskStatus != NULL)
+        {
+            vPortFree(pxTaskStatus);
+            pxTaskStatus = NULL;
+        }
+        return pdFALSE;
+    }
+}
+
+
+/**
+* @brief Command that gets carrier board information.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandCarrierBoardInfoGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    CarrierBoardInfo carrierBoardInfo;
+    char *pcWb = pcWriteBuffer;
+    size_t len, size = xWriteBufferLen;
+
+    es_get_carrier_borad_info(&carrierBoardInfo);
+    len = snprintf(pcWb, size, "[Carrierboard Information:]\r\n");
+    pcWb += len;
+    size -= len;
+    len = snprintf(pcWb, size, "magicNumber:0x%lx\r\n", carrierBoardInfo.magicNumber);
+    pcWb += len;
+    size -= len;
+    len = snprintf(pcWb, size, "formatVersionNumber:0x%x\r\n", carrierBoardInfo.formatVersionNumber);
+    pcWb += len;
+    size -= len;
+    len = snprintf(pcWb, size, "productIdentifier:0x%x\r\n", carrierBoardInfo.productIdentifier);
+    pcWb += len;
+    size -= len;
+    len = snprintf(pcWb, size, "pcbRevision:0x%x\r\n", carrierBoardInfo.pcbRevision);
+    pcWb += len;
+    size -= len;
+    len = snprintf(pcWb, size, "bomRevision:0x%x\r\n", carrierBoardInfo.bomRevision);
+    pcWb += len;
+    size -= len;
+    len = snprintf(pcWb, size, "bomVariant:0x%x\r\n", carrierBoardInfo.bomVariant);
+    pcWb += len;
+    size -= len;
+    len = snprintf(pcWb, size, "SN(hex):");
+    pcWb += len;
+    size -= len;
+    for (int i = 0; i < sizeof(carrierBoardInfo.boardSerialNumber); i++) {
+        pcWb += snprintf(pcWb, size, "%x", carrierBoardInfo.boardSerialNumber[i]);
+        size--;
+    }
+    len = snprintf(pcWb, size, "\r\n");
+    pcWb += len;
+    size -= len;
+    snprintf(pcWb, size, "manufacturingTestStatus:%d\r\n", carrierBoardInfo.manufacturingTestStatus);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that gets som board information.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandSomBoardInfoGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    int ret = HAL_OK;
+    som_info somInfo;
+    som_info *psomInfo = &somInfo;
+    char *pcWb = pcWriteBuffer;
+    size_t len, size = xWriteBufferLen;
+
+    ret = web_cmd_handle(CMD_READ_BOARD_INFO, psomInfo, sizeof(som_info), 1000);
+    if (HAL_OK != ret) {
+        snprintf(pcWriteBuffer, xWriteBufferLen, "Faild to get som info(errcode %d)\n", ret);
+    }
+    else {
+        len = snprintf(pcWb, size, "[Somboard Information:]\r\n");
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "magicNumber:0x%lx\r\n", psomInfo->magic);
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "version:0x%x\r\n", psomInfo->version);
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "id:0x%x\r\n", psomInfo->id);
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "pcb:0x%x\r\n", psomInfo->pcb);
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "bom_revision:0x%x\r\n", psomInfo->bom_revision);
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "bom_variant:0x%x\r\n", psomInfo->bom_variant);
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "SN(hex):");
+        pcWb += len;
+        size -= len;
+        for (int i = 0; i < sizeof(psomInfo->sn); i++) {
+            pcWb += snprintf(pcWb, size, "%x", psomInfo->sn[i]);
+            size--;
+        }
+        len = snprintf(pcWb, size, "\r\n");
+        pcWb += len;
+        size -= len;
+        len = snprintf(pcWb, size, "status:%d\n", psomInfo->status);
+    }
+
+    return pdFALSE;
+}
+
+/**
+* @brief Command that show account info
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandAccountGet(char *pcWriteBuffer, size_t xWriteBufferLen\
+                                     , const char *pcCommandString)
+{
+    char admin_name[32] = {0};
+    char admin_password[32]={0};
+
+    /* Read admin name and password and fill FreeRTOS write buffer */
+    es_get_username_password(admin_name, admin_password);
+
+    snprintf(pcWriteBuffer, xWriteBufferLen, "AdminName: %s  Password: %s\r\n",
+            admin_name, admin_password);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that set account info
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandAccountSet(char *pcWriteBuffer, size_t xWriteBufferLen\
+                                     , const char *pcCommandString)
+{
+    BaseType_t xParamLen;
+    const char * pcAdminName;
+    const char * pcAdminPassword;
+    char admin_name[32] = {0};
+    char admin_password[32]={0};
+
+    pcAdminName = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    /* fill with new accout name */
+    strncpy(admin_name, pcAdminName, xParamLen);
+
+    /* Get Admin password parameter */
+    pcAdminPassword = FreeRTOS_CLIGetParameter(pcCommandString, 2, &xParamLen);
+    strncpy(admin_password, pcAdminPassword, xParamLen);
+
+    /* update the accoutn info finally */
+    es_set_username_password(admin_name, pcAdminPassword);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that display the network configuration info
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandNetInfoGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    char *pcWb = pcWriteBuffer;
+    size_t len, size = xWriteBufferLen;
+    NETInfo netInfo;
+
+    /* Read network information and fill FreeRTOS write buffer */
+    netInfo = get_net_info();
+
+    len = snprintf(pcWb, size, "inet %s  netmask: %s\r\n",
+                    netInfo.ipaddr, netInfo.subnetwork);
+    pcWb += len;
+    size -= len;
+
+    len = snprintf(pcWb, size, "gatway %s\r\n", netInfo.gateway);
+    pcWb += len;
+    size -= len;
+
+    len = snprintf(pcWb, size, "mac %s\r\n", netInfo.macaddr);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that sets a new ip address.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandIPSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+	uint32_t naddr;
+    const char * pcIPaddr;
+    BaseType_t xParamLen;
+
+    pcIPaddr = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+
+	/* set ipaddr */
+	naddr = ipaddr_addr(pcIPaddr);
+	es_set_mcu_ipaddr((uint8_t *)&naddr);
+
+    snprintf(pcWriteBuffer, xWriteBufferLen, "ip addr set to %s(0x%lx)\r\n", pcIPaddr, naddr);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that sets a new netmask address.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandNetMaskSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+	uint32_t naddr;
+    const char * pcIPaddr;
+    BaseType_t xParamLen;
+
+    pcIPaddr = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+
+	/* set ipaddr */
+	naddr = ipaddr_addr(pcIPaddr);
+	es_set_mcu_netmask((uint8_t *)&naddr);
+
+    snprintf(pcWriteBuffer, xWriteBufferLen, "netmask addr set to %s(0x%lx)\r\n", pcIPaddr, naddr);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that sets a new gateway address.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandGateWaySet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+	uint32_t naddr;
+    const char * pcIPaddr;
+    BaseType_t xParamLen;
+
+    pcIPaddr = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+
+	/* set ipaddr */
+	naddr = ipaddr_addr(pcIPaddr);
+	es_set_mcu_gateway((uint8_t *)&naddr);
+
+    snprintf(pcWriteBuffer, xWriteBufferLen, "gateway addr set to %s(0x%lx)\r\n", pcIPaddr, naddr);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that sets mac address.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandMacSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    const char * pcMACaddr;
+    BaseType_t xParamLen;
+	uint8_t mac[6];
+
+    pcMACaddr = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+
+    /* set mac */
+    hexstr2mac(mac, pcMACaddr);
+    es_set_mcu_mac(mac);
+
+    snprintf(pcWriteBuffer, xWriteBufferLen, "MAC addr set to %s(%x:%x:%x:%x:%x:%x)\r\n",
+                pcMACaddr, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Command that show software bootsel configuration
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandDipSwitchSoftGet(char *pcWriteBuffer, size_t xWriteBufferLen\
+                                     , const char *pcCommandString)
+{
+    uint8_t state;
+    int ctl_attr;
+
+    /* Read dip switch ctl attribute */
+    es_get_som_dip_switch_soft_ctl_attr(&ctl_attr);
+
+    /* Read dip switch state and fill FreeRTOS write buffer */
+    es_get_som_dip_switch_soft_state(&state);
+
+    snprintf(pcWriteBuffer, xWriteBufferLen, "Get: Bootsel Controlled by: %s, bootsel[3 2 1 0]:%d %d %d %d\r\n",
+            ctl_attr == 1?"SW":"HW", (0x8&state)>>3, (0x4&state)>>2, (0x2&state)>>1, (0x1&state));
+
+    return pdFALSE;
+
+}
+
+/**
+* @brief Command that set software bootsel configuration
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandDipSwitchSoftSet(char *pcWriteBuffer, size_t xWriteBufferLen\
+                                     , const char *pcCommandString)
+{
+    BaseType_t xParamLen;
+    uint8_t state;
+    int ctl_attr;
+    const char * pcCtlAttr;
+    const char * pcState;
+    int setAttrFlag = 0;
+
+    pcCtlAttr = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    if ((0 == strncmp("sw", pcCtlAttr, xParamLen)) || (0 == strncmp("SW", pcCtlAttr, xParamLen))) {
+        ctl_attr = 1;
+        setAttrFlag = 1;
+    }
+    else if ((0 == strncmp("hw", pcCtlAttr, xParamLen)) || (0 == strncmp("HW", pcCtlAttr, xParamLen))){
+        ctl_attr = 0;
+        setAttrFlag = 1;
+    }
+    else {
+        snprintf(pcWriteBuffer, xWriteBufferLen, "Invalid parameter!\r\n");
+    }
+
+    if (setAttrFlag) {
+        /* set new dip switch ctl attr */
+        es_set_som_dip_switch_soft_ctl_attr(ctl_attr);
+
+        /* get dip switch state parameter */
+        pcState = FreeRTOS_CLIGetParameter(pcCommandString, 2, &xParamLen);
+        state = atoh(pcState, xParamLen) & 0xF;
+        /* set new dip switch state */
+        es_set_som_dip_switch_soft_state(state);
+
+        snprintf(pcWriteBuffer, xWriteBufferLen, "Set: Bootsel Controlled by: %s, bootsel[3 2 1 0]:%d %d %d %d\r\n",
+                ctl_attr == 1?"SW":"HW", (0x8&state)>>3, (0x4&state)>>2, (0x2&state)>>1, (0x1&state));
+    }
+
+    return pdFALSE;
+}
+
+/**
+* @brief Echo command line in UNIX systems.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandEcho( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    const char *pcStrToOutput;
+    BaseType_t xParamLen;
+
+    /* Get the user input and write it back the FreeRTOS write buffer */
+    pcStrToOutput = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    snprintf(pcWriteBuffer, xWriteBufferLen, "%s\n", pcStrToOutput);
+
+    return pdFALSE;
+}
+
+/**
+* @brief Command that gets heap information
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandHeap(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+
+    size_t xHeapFree;
+    size_t xHeapMinMemExisted;
+
+    xHeapFree = xPortGetFreeHeapSize();
+    xHeapMinMemExisted = xPortGetMinimumEverFreeHeapSize();
+    snprintf(pcWriteBuffer, xWriteBufferLen,
+             "Heap size            : %3u bytes (%3d KiB)\r\nRemaining            : %3u bytes (%3d KiB)\r\nMinimum ever existed : %3u bytes (%3d KiB)\r\n",
+             configTOTAL_HEAP_SIZE, configTOTAL_HEAP_SIZE / 1024, xHeapFree, xHeapFree / 1024, xHeapMinMemExisted, xHeapMinMemExisted / 1024);
+
+    return pdFALSE;
+}
+
+/**
+* @brief Command that calculate OS ticks information.
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandTicks(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    uint32_t uMs;
+    uint32_t uSec;
+    TickType_t xTickCount = xTaskGetTickCount();
+
+    uSec = xTickCount / configTICK_RATE_HZ;
+    uMs = xTickCount % configTICK_RATE_HZ;
+    snprintf(pcWriteBuffer, xWriteBufferLen,
+             "Tick rate: %u Hz\r\nTicks: %lu\r\nRun time: %lu.%.3lu seconds\r\n",
+              (unsigned)configTICK_RATE_HZ, xTickCount, uSec, uMs);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Get the current time stored in RTC registers
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandRtcGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+	struct rtc_date_t date = {0};
+	struct rtc_time_t time = {0};
+    char cWeekDay[4] = {0};
+
+	es_get_rtc_date(&date);
+	es_get_rtc_time(&time);
+
+    switch (date.WeekDay)
+    {
+        case 1:
+            strncpy(cWeekDay, "Mon", 4);
+            break;
+        case 2:
+            strncpy(cWeekDay, "Tue", 4);
+            break;
+        case 3:
+            strncpy(cWeekDay, "Wed", 4);
+            break;
+        case 4:
+            strncpy(cWeekDay, "Thu", 4);
+            break;
+        case 5:
+            strncpy(cWeekDay, "Fri", 4);
+            break;
+        case 6:
+            strncpy(cWeekDay, "Sat", 4);
+            break;
+        case 7:
+            strncpy(cWeekDay, "Sun", 4);
+            break;
+        default:
+            break;
+    }
+    snprintf(pcWriteBuffer, xWriteBufferLen, "%u-%u-%u %s %u:%u:%u CST\r\n",
+                date.Year, date.Month, date.Date, cWeekDay,
+                time.Hours, time.Minutes, time.Seconds);
+
+    return pdFALSE;
+}
+
+/**
+* @brief Set a new date in RCT registers
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandRtcDateSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    const char *cYear;
+    const char *cMonth;
+    const char *cDate;
+    const char *cWeekDay;
+    BaseType_t xParamLen;
+    struct rtc_date_t date = {0};
+
+    cYear = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    cMonth = FreeRTOS_CLIGetParameter(pcCommandString, 2, &xParamLen);
+    cDate = FreeRTOS_CLIGetParameter(pcCommandString, 3, &xParamLen);
+    cWeekDay = FreeRTOS_CLIGetParameter(pcCommandString, 4, &xParamLen);
+
+    date.Year = atoi(cYear);
+    date.Month = atoi(cMonth);
+    date.Date = atoi(cDate);
+    date.WeekDay = atoi(cWeekDay);
+
+    /* update time */
+    es_set_rtc_date(&date);
+    snprintf(pcWriteBuffer, xWriteBufferLen, "Date set to: %u-%u-%u WeekDay %d\n",
+            date.Year, date.Month, date.Date, date.WeekDay);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Set a new time in RCT registers
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandRtcTimeSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    const char *cHours;
+    const char *cMinutes;
+    const char *cSeconds;
+    BaseType_t xParamLen;
+    struct rtc_time_t time = {0};
+
+    cHours = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    cMinutes = FreeRTOS_CLIGetParameter(pcCommandString, 2, &xParamLen);
+    cSeconds = FreeRTOS_CLIGetParameter(pcCommandString, 3, &xParamLen);
+
+    time.Hours = atoi(cHours);
+    time.Minutes = atoi(cMinutes);
+    time.Seconds = atoi(cSeconds);
+
+    /* update time */
+    es_set_rtc_time(&time);
+    snprintf(pcWriteBuffer, xWriteBufferLen, "Time (24hr format) set to: %u:%u:%u\n",
+            time.Hours, time.Minutes, time.Seconds);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Show temperature and fan speed
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandTempGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    int ret = HAL_OK;
+    PVTInfo pvtInfo;
+
+    ret = web_cmd_handle(CMD_PVT_INFO, &pvtInfo, sizeof(PVTInfo), 1000);
+    if (HAL_OK != ret) {
+         snprintf(pcWriteBuffer, xWriteBufferLen, "Faild to get PVT info(errcode:%d)\n", ret);
+    }
+    else {
+        snprintf(pcWriteBuffer, xWriteBufferLen,"cpu_temp:%d  npu_temp:%d  fan_speed:%d\n",
+            pvtInfo.cpu_temp, pvtInfo.npu_temp, pvtInfo.fan_speed);
+    }
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Show power consumption(including current and voltage)
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandPwrDissipationGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    uint32_t millivolt = 0, milliCur = 0, microWatt = 0; //millivolt, milliCurrent, milliwatt
+    int pwrStaus;
+
+    pwrStaus = get_som_power_state();
+    if (pwrStaus == SOM_POWER_ON) {
+        get_board_power(&millivolt, &milliCur, &microWatt);
+    }
+    snprintf(pcWriteBuffer, xWriteBufferLen,"consumption:%ld.%3ld(W)  voltage:%ld.%3ld(V)  current:%ld.%3ld(A)\n",
+        microWatt / 1000000, microWatt % 1000000, millivolt / 1000, millivolt % 1000, milliCur / 1000, milliCur % 1000);
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Get the som power status: ON or OFF
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandSomPwrStatusGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    int pwrStaus;
+
+    pwrStaus = get_som_power_state();
+    snprintf(pcWriteBuffer, xWriteBufferLen, "Som Power Status: %s\n", (pwrStaus == SOM_POWER_ON)?"ON":"OFF");
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Power On or OFF the som board
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandSomPwrStatusSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    int ret = 0;
+    const char *cPwrOnOff;
+    BaseType_t xParamLen;
+    uint8_t powerOnOff;
+
+    cPwrOnOff = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    powerOnOff = atoi(cPwrOnOff);
+
+    /* change som power */
+    if (0 == powerOnOff) {
+        if (SOM_POWER_ON == get_som_power_state()) {
+            ret = web_cmd_handle(CMD_POWER_OFF, NULL, 0, 1000);
+            if (HAL_OK != ret) {
+                change_som_power_state(SOM_POWER_OFF);
+                printf("Poweroff SOM error(ret %d), force shutdown it!\n", ret);
+            }
+            // Trigger the Som timer to enusre SOM could poweroff in 5 senconds
+            TriggerSomPowerOffTimer();
+        } else {
+            printf("SOM already power off!\n");
+        }
+    } else {
+        if (SOM_POWER_OFF == get_som_power_state()) {
+            change_som_power_state(SOM_POWER_ON);
+        } else {
+            printf("SOM already power on!\n");
+        }
+    }
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief get the system runnig status of the som board, running or stoppted
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandSomSwWorkStatusGet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    int workStaus;
+
+    workStaus = get_som_daemon_state();
+    snprintf(pcWriteBuffer, xWriteBufferLen, "Som Work Status: %s\n", (workStaus == SOM_DAEMON_ON)?"Running":"Stopped");
+
+    return pdFALSE;
+}
+
+/**
+* @brief reboot the kernel on the som
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandReboot(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    int ret = HAL_OK;
+
+    ret = web_cmd_handle(CMD_RESET, NULL, 0, 1000);
+    if (HAL_OK != ret) {
+        som_reset_control(pdTRUE);
+        osDelay(10);
+        som_reset_control(pdFALSE);
+        printf("Faild to reboot SOM(ret %d), force reset SOM!\n", ret);
+    }
+    // Trigger the Som timer to enusre SOM could reboot in 5 senconds
+    TriggerSomRebootTimer();
+
+    return pdFALSE;
+}
+
+
+/**
+* @brief Get current console version
+* @param *pcWriteBuffer FreeRTOS CLI write buffer.
+* @param xWriteBufferLen Length of write buffer.
+* @param *pcCommandString pointer to the command name.
+* @retval FreeRTOS status
+*/
+static BaseType_t prvCommandBMCVersion(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
+{
+    snprintf(pcWriteBuffer, xWriteBufferLen, "%d.%d\n", (uint8_t)(BMC_SOFTWARE_VERSION_MAJOR), (uint8_t)(BMC_SOFTWARE_VERSION_MINOR));
+    return pdFALSE;
+}
+
+/**
+* @brief Reads from UART RX buffer. Reads one bye at the time.
+* @param *cReadChar pointer to where data will be stored.
+* @retval FreeRTOS status
+*/
+static BaseType_t xConsoleRead(uint8_t *cReadChar, size_t xLen)
+{
+    BaseType_t xRetVal = pdFALSE;
+
+    if (xQueueRxHandle == NULL || cReadChar == NULL)
+    {
+        return xRetVal;
+    }
+
+    /* Block until the there is input from the user */
+    return xQueueReceive(xQueueRxHandle, cReadChar, portMAX_DELAY);
+}
+
+/**
+* @brief Write to UART TX
+* @param *buff buffer to be written.
+* @retval HAL status
+*/
+static HAL_StatusTypeDef vConsoleWrite(const char *buff)
+{
+    HAL_StatusTypeDef status;
+    size_t len = strlen(buff);
+
+    if (pxUartDevHandle == NULL || *buff == '\0' || len < 1)
+    {
+        return HAL_ERROR;
+    }
+
+    status = HAL_UART_Transmit(pxUartDevHandle, (uint8_t *)buff, strlen(buff), portMAX_DELAY);
+    if (status != HAL_OK)
+    {
+    	return HAL_ERROR;
+    }
+    return status;
+}
+
+/**
+* @brief Enables UART RX reception.
+* @param void
+* @retval void
+*/
+void vConsoleEnableRxInterrupt(void)
+{
+    if (pxUartDevHandle == NULL)
+    {
+        return;
+    }
+    /* UART Rx IT is enabled by reading a character */
+    HAL_UART_Receive_IT(pxUartDevHandle,(uint8_t*)&cRxData, 1);
+}
+
+/**
+* @brief Task to handle user commands via serial communication.
+* @param *pvParams Data passed at task creation.
+* @retval void
+*/
+void vTaskConsole(void *pvParams)
+{
+    char cReadCh = '\0';
+    uint8_t uInputIndex = 0;
+    BaseType_t xMoreDataToProcess;
+    char pcInputString[MAX_IN_STR_LEN];
+    char pcPrevInputString[MAX_IN_STR_LEN];
+    char pcOutputString[MAX_OUT_STR_LEN];
+
+    memset(pcInputString, 0x00, MAX_IN_STR_LEN);
+    memset(pcPrevInputString, 0x00, MAX_IN_STR_LEN);
+    memset(pcOutputString, 0x00, MAX_OUT_STR_LEN);
+
+    /* Create a queue to store characters from RX ISR */
+    xQueueRxHandle = xQueueCreate(MAX_RX_QUEUE_LEN, sizeof(char));
+    if (xQueueRxHandle == NULL)
+    {
+        goto out_task_console;
+    }
+
+    vConsoleWrite(pcWelcomeMsg);
+    vConsoleEnableRxInterrupt();
+    vConsoleWrite(prvpcPrompt);
+
+    while(1)
+    {
+        /* Block until there is a new character in RX buffer */
+        xConsoleRead((uint8_t*)(&cReadCh), sizeof(cReadCh));
+
+        switch (cReadCh)
+        {
+            case ASCII_CR:
+            case ASCII_LF:
+                if (uInputIndex != 0)
+                {
+                    vConsoleWrite("\r\n");
+                    strncpy(pcPrevInputString, pcInputString, MAX_IN_STR_LEN);
+                    do
+                    {
+                        xMoreDataToProcess = FreeRTOS_CLIProcessCommand
+                                            (
+                                                pcInputString,    /* Command string*/
+                                                pcOutputString,   /* Output buffer */
+                                                MAX_OUT_STR_LEN   /* Output buffer size */
+                                            );
+                        vConsoleWrite(pcOutputString);
+                    } while (xMoreDataToProcess != pdFALSE);
+                }
+                uInputIndex = 0;
+                memset(pcInputString, 0x00, MAX_IN_STR_LEN);
+                memset(pcOutputString, 0x00, MAX_OUT_STR_LEN);
+                vConsoleWrite("\r\n");
+                vConsoleWrite(prvpcPrompt);
+                break;
+            case ASCII_FORM_FEED:
+                vConsoleWrite("\x1b[2J\x1b[0;0H");
+                vConsoleWrite("\n");
+                vConsoleWrite(prvpcPrompt);
+                break;
+            case ASCII_CTRL_PLUS_C:
+                uInputIndex = 0;
+                memset(pcInputString, 0x00, MAX_IN_STR_LEN);
+                vConsoleWrite("\n");
+                vConsoleWrite(prvpcPrompt);
+                break;
+            case ASCII_DEL:
+            case ASCII_NACK:
+            case ASCII_BACKSPACE:
+                if (uInputIndex > 0)
+                {
+                    uInputIndex--;
+                    pcInputString[uInputIndex] = '\0';
+                    vConsoleWrite("\b \b");
+                }
+                break;
+            case ASCII_TAB:
+                while (uInputIndex)
+                {
+                    uInputIndex--;
+                    vConsoleWrite("\b \b");
+                }
+                strncpy(pcInputString, pcPrevInputString, MAX_IN_STR_LEN);
+                uInputIndex = (unsigned char)strlen(pcInputString);
+                vConsoleWrite(pcInputString);
+                break;
+            default:
+                /* Check if read character is between [Space] and [~] in ASCII table */
+                if (uInputIndex < (MAX_IN_STR_LEN - 1 ) && (cReadCh >= 32 && cReadCh <= 126))
+                {
+                    pcInputString[uInputIndex] = cReadCh;
+                    vConsoleWrite(pcInputString + uInputIndex);
+                    uInputIndex++;
+                }
+                break;
+        }
+    }
+
+out_task_console:
+    if (xQueueRxHandle)
+    {
+        vQueueDelete(xQueueRxHandle);
+    }
+    vTaskDelete(NULL);
+}
+
+/**
+* @brief Initialize the console by registering all commands and creating a task.
+* @param usStackSize Task console stack size
+* @param uxPriority Task console priority
+* @param *pxUartHandle Pointer for uart handle.
+* @retval FreeRTOS status
+*/
+BaseType_t xbspConsoleInit(uint16_t usStackSize, UBaseType_t uxPriority, UART_HandleTypeDef *pxUartHandle)
+{
+    const CLI_Command_Definition_t *pCommand;
+
+    if (pxUartHandle == NULL)
+    {
+        return pdFALSE;
+    }
+    pxUartDevHandle = pxUartHandle;
+
+    /* Register all commands that can be accessed by the user */
+    for (pCommand = xCommands; pCommand->pcCommand != NULL; pCommand++)
+    {
+        FreeRTOS_CLIRegisterCommand(pCommand);
+    }
+    return xTaskCreate(vTaskConsole,"CLI", usStackSize, NULL, uxPriority, NULL);
+}
+
+#if !ES_PRODUCTION_LINE_TEST
+/**
+* @brief Callback for UART RX, triggered any time there is a new character.
+* @param *huart Pointer to the uart handle.
+* @retval void
+*/
+void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
+{
+    BaseType_t pxHigherPriorityTaskWoken = pdFALSE;
+
+    if (xQueueRxHandle != NULL)
+    {
+        xQueueSendToBackFromISR(xQueueRxHandle, &cRxData, &pxHigherPriorityTaskWoken);
+    }
+    vConsoleEnableRxInterrupt();
+}
+#endif
\ No newline at end of file
diff --git a/Core/Src/hf_common.c b/Core/Src/hf_common.c
index 0c6031a..94b13f9 100644
--- a/Core/Src/hf_common.c
+++ b/Core/Src/hf_common.c
@@ -85,6 +85,7 @@ static int buf_compwith_random(void *buf, uint32_t size, uint32_t prime_seed)
 
 static void print_data(uint8_t *p_buf, int len)
 {
+	#if EEPROM_DEBUG_EN
 	int i;
 	for (i = 0; i < len; i++) {
 		printf(" %02x", p_buf[i]);
@@ -92,10 +93,9 @@ static void print_data(uint8_t *p_buf, int len)
 			printf("\n");
 	}
 	printf("\n");
+	#endif
 }
 
-
-
 static u32_t ntohl_seq(uint8_t *p_nlmask)
 {
 	u32_t hlmask = 0, tmp = 0;
@@ -124,7 +124,7 @@ static int hex2num(char c)
 	return -1;
 }
 
-void hexstr2mac(uint8_t *mac, char *hexstr)
+void hexstr2mac(uint8_t *mac, const char *hexstr)
 {
 	int i = 0;
 
@@ -139,6 +139,25 @@ void hexstr2mac(uint8_t *mac, char *hexstr)
 	}
 }
 
+uint32_t atoh(const char *in, uint32_t len)
+{
+	uint32_t sum = 0;
+	unsigned int mult = 1;
+	unsigned char c;
+
+	while (len) {
+		int value;
+
+		c = in[len - 1];
+		value = hex2num(c);
+		if (value >= 0)
+			sum += mult * value;
+		mult *= 16;
+		--len;
+	}
+	return sum;
+}
+
 int _write(int fd, char *ch, int len)
 {
 	uint8_t val = '\r';
@@ -1036,7 +1055,7 @@ int32_t es_get_rtc_time(struct rtc_time_t *stime)
 
 uint32_t es_autoboot(void)
 {
-	int32_t som_pwr_last_state = 0;
+	int som_pwr_last_state = 0;
 	if(is_som_pwr_lost_resume() && !es_get_som_pwr_last_state(&som_pwr_last_state)) {
 		if (som_pwr_last_state){
 			printf("pwr enable and last state is power on\n");
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index 836276a..066d1a0 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -334,7 +334,8 @@ static void pmic_status_led_on(uint8_t turnon)
 void som_reset_control(uint8_t reset)
 {
 	GPIO_InitTypeDef GPIO_InitStruct = {0};
-	int dip_switch_soft_ctl_attr = 0, dip_switch_soft_state = 0;
+	int dip_switch_soft_ctl_attr = 0;
+	uint8_t dip_switch_soft_state = 0;
 	if (reset) {
 		HAL_GPIO_WritePin(MCU_RESET_SOM_N_GPIO_Port, MCU_RESET_SOM_N_Pin, GPIO_PIN_RESET);
 		GPIO_InitStruct.Pin = MCU_RESET_SOM_N_Pin;
diff --git a/Core/Src/main.c b/Core/Src/main.c
index 10d7b2d..5d397b9 100644
--- a/Core/Src/main.c
+++ b/Core/Src/main.c
@@ -19,6 +19,7 @@
 #include "cmsis_os.h"
 #include <stdio.h>
 #include "stm32f4xx_hal_iwdg.h"
+#include "console.h"
 
 /* Private includes ----------------------------------------------------------*/
 #include "hf_common.h"
@@ -32,7 +33,7 @@
 osThreadId_t main_task_handle;
 const osThreadAttr_t main_task_attributes = {
   .name = "MainTask",
-  .stack_size = 1024*4,
+  .stack_size = 1024,
   .priority = (osPriority_t) osPriorityNormal,
 };
 
@@ -180,9 +181,15 @@ void hf_main_task(void *argument)
   http_task_handle = osThreadNew(hf_http_task, NULL, &http_task_attributes);
   key_task_handle = osThreadNew(hf_gpio_task, NULL, &gpio_task_attributes);
   // moniter_task_handle = osThreadNew(MoniterTask, NULL, &MoniterTask_attributes);
-  protocol_task_handle = osThreadNew(protocol_task, NULL, &protocol_task_attributes);
   uart4_protocol_task_handle = osThreadNew(uart4_protocol_task, NULL, &protocol_task_attributes);
   daemon_keelive_task_handle = osThreadNew(deamon_keeplive_task, NULL, &daemon_keeplive_task_attributes);
+  #if ES_PRODUCTION_LINE_TEST
+  protocol_task_handle = osThreadNew(protocol_task, NULL, &protocol_task_attributes);
+  #else
+  if (pdTRUE != xbspConsoleInit(CONSOLE_STACK_SIZE, CONSOLE_TASK_PRIORITY, &consoleHandle)) {
+    printf("Err:Failed to create CLI!\n");
+  }
+  #endif
   // extern void MX_IWDG_Init(void);
 	// MX_IWDG_Init();
 
diff --git a/Core/Src/web-server.c b/Core/Src/web-server.c
index e522b9f..8d35f76 100644
--- a/Core/Src/web-server.c
+++ b/Core/Src/web-server.c
@@ -10182,7 +10182,7 @@ typedef struct  {
     int voltage;		
 } POWERInfo;
 
-POWERInfo get_power_info(){
+POWERInfo get_power_info(void){
 
 	printf("TODO call get_power_info\n");
 
@@ -10195,15 +10195,8 @@ POWERInfo get_power_info(){
 }
 
 
-typedef struct  {
-    char ipaddr[16];    // IPxxx.xxx.xxx.xxx
-    char macaddr[18];   // MACxx:xx:xx:xx:xx:xx
-    char subnetwork[16];
-    char gateway[16];    
-} NETInfo;
-
 
-NETInfo get_net_info() {
+NETInfo get_net_info(void) {
 	NETInfo example;
 	ip4_addr_t ip4_addr;
 	uint8_t buf[4];
@@ -10230,7 +10223,7 @@ NETInfo get_net_info() {
 
 	es_get_mcu_mac(mac);
 	memset(example.macaddr, 0, sizeof(example.macaddr));
-	snprintf(example.macaddr, sizeof(example.macaddr), "%02x.%02x.%02x.%02x.%02x.%02x",
+	snprintf(example.macaddr, sizeof(example.macaddr), "%02x:%02x:%02x:%02x:%02x:%02x",
 			mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
 
 	return example;
@@ -10239,23 +10232,19 @@ NETInfo get_net_info() {
 
 int set_net_info(NETInfo netinfo) {
 	u32_t naddr;
-	u32_t haddr;
 	uint8_t mac[6];
 
 	/* set ipaddr */
 	naddr = ipaddr_addr(netinfo.ipaddr);
-	haddr = PP_NTOHL(naddr);
-	es_set_mcu_ipaddr((uint8_t *)&haddr);
+	es_set_mcu_ipaddr((uint8_t *)&naddr);
 
 	/* set netmask */
 	naddr = ipaddr_addr(netinfo.subnetwork);
-	haddr = PP_NTOHL(naddr);
-	es_set_mcu_netmask((uint8_t *)&haddr);
+	es_set_mcu_netmask((uint8_t *)&naddr);
 
 	/* set gateway */
 	naddr = ipaddr_addr(netinfo.gateway);
-	haddr = PP_NTOHL(naddr);
-	es_set_mcu_gateway((uint8_t *)&haddr);
+	es_set_mcu_gateway((uint8_t *)&naddr);
 
 	/* set mac */
 	hexstr2mac(mac, netinfo.macaddr);
@@ -10265,12 +10254,6 @@ int set_net_info(NETInfo netinfo) {
 }
 
 
-typedef struct {
-	int cpu_temp;
-	int npu_temp;
-	int fan_speed;
-} PVTInfo;
-
 int get_pvt_info(PVTInfo *ppvtInfo)
 {
 	int ret = HAL_OK;
@@ -10312,18 +10295,6 @@ int set_dip_switch(DIPSwitchInfo dipSwitchInfo)
 	return es_set_som_dip_switch_soft_state(som_dip_switch_state);
 }
 
-typedef struct {
-	uint32_t magic;
-	uint8_t version;
-	uint16_t id;
-	uint8_t pcb;
-	uint8_t bom_revision;
-	uint8_t bom_variant;
-	uint8_t sn[18];
-	uint8_t status;
-	uint32_t crc;
-} __attribute__((packed)) som_info;
-
 int get_som_info(som_info *psomInfo)
 {
 	int ret = HAL_OK;
@@ -10331,7 +10302,7 @@ int get_som_info(som_info *psomInfo)
 	if (HAL_OK != ret) {
 		printf("Faild to get som info %d\n", ret);
 	}
-	printf("web call get_som_info, magic %d, version %d, "
+	printf("web call get_som_info, magic %ld, version %d, "
 		"id %d, pcb %d, bom_revision %d, bom_variant %d, "
 		"sn %s, status %d, ret %d\n",
 		psomInfo->magic, psomInfo->version ,
@@ -11439,7 +11410,10 @@ int get_soc_status()
  {
  	int ret=sys_thread_new("http_server_netconn", http_server_netconn_thread, NULL, 1024*4, 4);
 	if (ret<=0){
-		printf("ERROR:create thread http_server_netconn_thread failt \n");
+		printf("ERROR:create thread http_server_netconn_thread failed %d\n", ret);
+	}
+	else {
+		printf("create thread http_server_netconn_thread ok!\n");
 	}
  }
 
diff --git a/Core/Src/web-server.h b/Core/Src/web-server.h
index f7c1a02..4fb64e8 100644
--- a/Core/Src/web-server.h
+++ b/Core/Src/web-server.h
@@ -8,6 +8,33 @@
 #define LED1_ON  do {printf("LED ON\n");} while(0)
 #define LED1_OFF  do {printf("LED OFF\n");} while(0)
 
+typedef struct {
+	uint32_t magic;
+	uint8_t version;
+	uint16_t id;
+	uint8_t pcb;
+	uint8_t bom_revision;
+	uint8_t bom_variant;
+	uint8_t sn[18];
+	uint8_t status;
+	uint32_t crc;
+} __attribute__((packed)) som_info;
+
+typedef struct  {
+    char ipaddr[16];    // IPIPv4xxx.xxx.xxx.xxx
+    char macaddr[18];   // MACxx:xx:xx:xx:xx:xx
+    char subnetwork[16]; // 
+    char gateway[16];    // 
+} NETInfo;
+
+typedef struct {
+	int cpu_temp;
+	int npu_temp;
+	int fan_speed;
+} PVTInfo;
+
 void httpserver_init(void);
 
+NETInfo get_net_info(void);
+
 #endif /* __HTTPSERVER_NETCONN_H__ */
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 1ce0f99..48ca816 100644
--- a/Makefile
+++ b/Makefile
@@ -44,6 +44,7 @@ BUILD_DIR = build
 # C sources
 C_SOURCES =  \
 Core/Src/main.c \
+Core/Src/console.c \
 Core/Src/freertos.c \
 Core/Src/hf_common.c \
 Core/Src/hf_power_process.c \
@@ -89,6 +90,7 @@ Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_iwdg.c \
 Core/Src/system_stm32f4xx.c \
 Middlewares/Third_Party/FreeRTOS/Source/croutine.c \
 Middlewares/Third_Party/FreeRTOS/Source/event_groups.c \
+Middlewares/Third_Party/FreeRTOS/Source/FreeRTOS_CLI.c \
 Middlewares/Third_Party/FreeRTOS/Source/list.c \
 Middlewares/Third_Party/FreeRTOS/Source/queue.c \
 Middlewares/Third_Party/FreeRTOS/Source/stream_buffer.c \
diff --git a/Middlewares/Third_Party/FreeRTOS/Source/FreeRTOS_CLI.c b/Middlewares/Third_Party/FreeRTOS/Source/FreeRTOS_CLI.c
new file mode 100644
index 0000000..9257f5a
--- /dev/null
+++ b/Middlewares/Third_Party/FreeRTOS/Source/FreeRTOS_CLI.c
@@ -0,0 +1,350 @@
+/*
+ * FreeRTOS+CLI V1.0.4
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * https://www.FreeRTOS.org
+ * https://aws.amazon.com/freertos
+ *
+ */
+
+/* Standard includes. */
+#include <string.h>
+#include <stdint.h>
+
+/* FreeRTOS includes. */
+#include "FreeRTOS.h"
+#include "task.h"
+
+/* Utils includes. */
+#include "FreeRTOS_CLI.h"
+
+/* If the application writer needs to place the buffer used by the CLI at a
+fixed address then set configAPPLICATION_PROVIDES_cOutputBuffer to 1 in
+FreeRTOSConfig.h, then declare an array with the following name and size in 
+one of the application files:
+	char cOutputBuffer[ configCOMMAND_INT_MAX_OUTPUT_SIZE ];
+*/
+#ifndef configAPPLICATION_PROVIDES_cOutputBuffer
+	#define configAPPLICATION_PROVIDES_cOutputBuffer 0
+#endif
+
+typedef struct xCOMMAND_INPUT_LIST
+{
+	const CLI_Command_Definition_t *pxCommandLineDefinition;
+	struct xCOMMAND_INPUT_LIST *pxNext;
+} CLI_Definition_List_Item_t;
+
+/*
+ * The callback function that is executed when "help" is entered.  This is the
+ * only default command that is always present.
+ */
+static BaseType_t prvHelpCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString );
+
+/*
+ * Return the number of parameters that follow the command name.
+ */
+static int8_t prvGetNumberOfParameters( const char *pcCommandString );
+
+/* The definition of the "help" command.  This command is always at the front
+of the list of registered commands. */
+static const CLI_Command_Definition_t xHelpCommand =
+{
+	"help",
+	"\r\nhelp:\r\n Lists all the registered commands\r\n\r\n",
+	prvHelpCommand,
+	0
+};
+
+/* The definition of the list of commands.  Commands that are registered are
+added to this list. */
+static CLI_Definition_List_Item_t xRegisteredCommands =
+{
+	&xHelpCommand,	/* The first command in the list is always the help command, defined in this file. */
+	NULL			/* The next pointer is initialised to NULL, as there are no other registered commands yet. */
+};
+
+/* A buffer into which command outputs can be written is declared here, rather
+than in the command console implementation, to allow multiple command consoles
+to share the same buffer.  For example, an application may allow access to the
+command interpreter by UART and by Ethernet.  Sharing a buffer is done purely
+to save RAM.  Note, however, that the command console itself is not re-entrant,
+so only one command interpreter interface can be used at any one time.  For that
+reason, no attempt at providing mutual exclusion to the cOutputBuffer array is
+attempted.
+
+configAPPLICATION_PROVIDES_cOutputBuffer is provided to allow the application
+writer to provide their own cOutputBuffer declaration in cases where the
+buffer needs to be placed at a fixed address (rather than by the linker). */
+#if( configAPPLICATION_PROVIDES_cOutputBuffer == 0 )
+	static char cOutputBuffer[ configCOMMAND_INT_MAX_OUTPUT_SIZE ];
+#else
+	extern char cOutputBuffer[ configCOMMAND_INT_MAX_OUTPUT_SIZE ];
+#endif
+
+
+/*-----------------------------------------------------------*/
+
+BaseType_t FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
+{
+static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
+CLI_Definition_List_Item_t *pxNewListItem;
+BaseType_t xReturn = pdFAIL;
+
+	/* Check the parameter is not NULL. */
+	configASSERT( pxCommandToRegister );
+
+	/* Create a new list item that will reference the command being registered. */
+	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
+	configASSERT( pxNewListItem );
+
+	if( pxNewListItem != NULL )
+	{
+		taskENTER_CRITICAL();
+		{
+			/* Reference the command being registered from the newly created
+			list item. */
+			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
+
+			/* The new list item will get added to the end of the list, so
+			pxNext has nowhere to point. */
+			pxNewListItem->pxNext = NULL;
+
+			/* Add the newly created list item to the end of the already existing
+			list. */
+			pxLastCommandInList->pxNext = pxNewListItem;
+
+			/* Set the end of list marker to the new list item. */
+			pxLastCommandInList = pxNewListItem;
+		}
+		taskEXIT_CRITICAL();
+
+		xReturn = pdPASS;
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+BaseType_t FreeRTOS_CLIProcessCommand( const char * const pcCommandInput, char * pcWriteBuffer, size_t xWriteBufferLen  )
+{
+static const CLI_Definition_List_Item_t *pxCommand = NULL;
+BaseType_t xReturn = pdTRUE;
+const char *pcRegisteredCommandString;
+size_t xCommandStringLength;
+
+	/* Note:  This function is not re-entrant.  It must not be called from more
+	thank one task. */
+
+	if( pxCommand == NULL )
+	{
+		/* Search for the command string in the list of registered commands. */
+		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
+		{
+			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
+			xCommandStringLength = strlen( pcRegisteredCommandString );
+
+			/* To ensure the string lengths match exactly, so as not to pick up
+			a sub-string of a longer command, check the byte after the expected
+			end of the string is either the end of the string or a space before
+			a parameter. */
+			if( strncmp( pcCommandInput, pcRegisteredCommandString, xCommandStringLength ) == 0 )
+			{
+				if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
+				{
+					/* The command has been found.  Check it has the expected
+					number of parameters.  If cExpectedNumberOfParameters is -1,
+					then there could be a variable number of parameters and no
+					check is made. */
+					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
+					{
+						if( prvGetNumberOfParameters( pcCommandInput ) != pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters )
+						{
+							xReturn = pdFALSE;
+						}
+					}
+
+					break;
+				}
+			}
+		}
+	}
+
+	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
+	{
+		/* The command was found, but the number of parameters with the command
+		was incorrect. */
+		strncpy( pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
+		pxCommand = NULL;
+	}
+	else if( pxCommand != NULL )
+	{
+		/* Call the callback function that is registered to this command. */
+		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
+
+		/* If xReturn is pdFALSE, then no further strings will be returned
+		after this one, and	pxCommand can be reset to NULL ready to search
+		for the next entered command. */
+		if( xReturn == pdFALSE )
+		{
+			pxCommand = NULL;
+		}
+	}
+	else
+	{
+		/* pxCommand was NULL, the command was not found. */
+		strncpy( pcWriteBuffer, "Command not recognised.  Enter 'help' to view a list of available commands.\r\n\r\n", xWriteBufferLen );
+		xReturn = pdFALSE;
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+char *FreeRTOS_CLIGetOutputBuffer( void )
+{
+	return cOutputBuffer;
+}
+/*-----------------------------------------------------------*/
+
+const char *FreeRTOS_CLIGetParameter( const char *pcCommandString, UBaseType_t uxWantedParameter, BaseType_t *pxParameterStringLength )
+{
+UBaseType_t uxParametersFound = 0;
+const char *pcReturn = NULL;
+
+	*pxParameterStringLength = 0;
+
+	while( uxParametersFound < uxWantedParameter )
+	{
+		/* Index the character pointer past the current word.  If this is the start
+		of the command string then the first word is the command itself. */
+		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
+		{
+			pcCommandString++;
+		}
+
+		/* Find the start of the next string. */
+		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
+		{
+			pcCommandString++;
+		}
+
+		/* Was a string found? */
+		if( *pcCommandString != 0x00 )
+		{
+			/* Is this the start of the required parameter? */
+			uxParametersFound++;
+
+			if( uxParametersFound == uxWantedParameter )
+			{
+				/* How long is the parameter? */
+				pcReturn = pcCommandString;
+				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
+				{
+					( *pxParameterStringLength )++;
+					pcCommandString++;
+				}
+
+				if( *pxParameterStringLength == 0 )
+				{
+					pcReturn = NULL;
+				}
+
+				break;
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	return pcReturn;
+}
+/*-----------------------------------------------------------*/
+
+static BaseType_t prvHelpCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
+{
+static const CLI_Definition_List_Item_t * pxCommand = NULL;
+BaseType_t xReturn;
+
+	( void ) pcCommandString;
+
+	if( pxCommand == NULL )
+	{
+		/* Reset the pxCommand pointer back to the start of the list. */
+		pxCommand = &xRegisteredCommands;
+	}
+
+	/* Return the next command help string, before moving the pointer on to
+	the next command in the list. */
+	strncpy( pcWriteBuffer, pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
+	pxCommand = pxCommand->pxNext;
+
+	if( pxCommand == NULL )
+	{
+		/* There are no more commands in the list, so there will be no more
+		strings to return after this one and pdFALSE should be returned. */
+		xReturn = pdFALSE;
+	}
+	else
+	{
+		xReturn = pdTRUE;
+	}
+
+	return xReturn;
+}
+/*-----------------------------------------------------------*/
+
+static int8_t prvGetNumberOfParameters( const char *pcCommandString )
+{
+int8_t cParameters = 0;
+BaseType_t xLastCharacterWasSpace = pdFALSE;
+
+	/* Count the number of space delimited words in pcCommandString. */
+	while( *pcCommandString != 0x00 )
+	{
+		if( ( *pcCommandString ) == ' ' )
+		{
+			if( xLastCharacterWasSpace != pdTRUE )
+			{
+				cParameters++;
+				xLastCharacterWasSpace = pdTRUE;
+			}
+		}
+		else
+		{
+			xLastCharacterWasSpace = pdFALSE;
+		}
+
+		pcCommandString++;
+	}
+
+	/* If the command string ended with spaces, then there will have been too
+	many parameters counted. */
+	if( xLastCharacterWasSpace == pdTRUE )
+	{
+		cParameters--;
+	}
+
+	/* The value returned is one less than the number of space delimited words,
+	as the first word should be the command itself. */
+	return cParameters;
+}
+
diff --git a/Middlewares/Third_Party/FreeRTOS/Source/include/FreeRTOS_CLI.h b/Middlewares/Third_Party/FreeRTOS/Source/include/FreeRTOS_CLI.h
new file mode 100644
index 0000000..ce6c801
--- /dev/null
+++ b/Middlewares/Third_Party/FreeRTOS/Source/include/FreeRTOS_CLI.h
@@ -0,0 +1,116 @@
+/*
+ * FreeRTOS+CLI V1.0.4
+ * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * https://www.FreeRTOS.org
+ * https://aws.amazon.com/freertos
+ *
+ */
+
+#ifndef COMMAND_INTERPRETER_H
+#define COMMAND_INTERPRETER_H
+
+/* *INDENT-OFF* */
+#ifdef __cplusplus
+    extern "C" {
+#endif
+/* *INDENT-ON* */
+
+/* The prototype to which callback functions used to process command line
+commands must comply.  pcWriteBuffer is a buffer into which the output from
+executing the command can be written, xWriteBufferLen is the length, in bytes of
+the pcWriteBuffer buffer, and pcCommandString is the entire string as input by
+the user (from which parameters can be extracted).*/
+typedef BaseType_t (*pdCOMMAND_LINE_CALLBACK)( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString );
+
+/* The structure that defines command line commands.  A command line command
+should be defined by declaring a const structure of this type. */
+typedef struct xCOMMAND_LINE_INPUT
+{
+	const char * const pcCommand;				/* The command that causes pxCommandInterpreter to be executed.  For example "help".  Must be all lower case. */
+	const char * const pcHelpString;			/* String that describes how to use the command.  Should start with the command itself, and end with "\r\n".  For example "help: Returns a list of all the commands\r\n". */
+	const pdCOMMAND_LINE_CALLBACK pxCommandInterpreter;	/* A pointer to the callback function that will return the output generated by the command. */
+	int8_t cExpectedNumberOfParameters;			/* Commands expect a fixed number of parameters, which may be zero. */
+} CLI_Command_Definition_t;
+
+/* For backward compatibility. */
+#define xCommandLineInput CLI_Command_Definition_t
+
+/*
+ * Register the command passed in using the pxCommandToRegister parameter.
+ * Registering a command adds the command to the list of commands that are
+ * handled by the command interpreter.  Once a command has been registered it
+ * can be executed from the command line.
+ */
+BaseType_t FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister );
+
+/*
+ * Runs the command interpreter for the command string "pcCommandInput".  Any
+ * output generated by running the command will be placed into pcWriteBuffer.
+ * xWriteBufferLen must indicate the size, in bytes, of the buffer pointed to
+ * by pcWriteBuffer.
+ *
+ * FreeRTOS_CLIProcessCommand should be called repeatedly until it returns pdFALSE.
+ *
+ * pcCmdIntProcessCommand is not reentrant.  It must not be called from more
+ * than one task - or at least - by more than one task at a time.
+ */
+BaseType_t FreeRTOS_CLIProcessCommand( const char * const pcCommandInput, char * pcWriteBuffer, size_t xWriteBufferLen  );
+
+/*-----------------------------------------------------------*/
+
+/*
+ * A buffer into which command outputs can be written is declared in the
+ * main command interpreter, rather than in the command console implementation,
+ * to allow application that provide access to the command console via multiple
+ * interfaces to share a buffer, and therefore save RAM.  Note, however, that
+ * the command interpreter itself is not re-entrant, so only one command
+ * console interface can be used at any one time.  For that reason, no attempt
+ * is made to provide any mutual exclusion mechanism on the output buffer.
+ *
+ * FreeRTOS_CLIGetOutputBuffer() returns the address of the output buffer.
+ */
+char *FreeRTOS_CLIGetOutputBuffer( void );
+
+/*
+ * Return a pointer to the xParameterNumber'th word in pcCommandString.
+ */
+const char *FreeRTOS_CLIGetParameter( const char *pcCommandString, UBaseType_t uxWantedParameter, BaseType_t *pxParameterStringLength );
+
+/* *INDENT-OFF* */
+#ifdef __cplusplus
+    }
+#endif
+/* *INDENT-ON* */
+
+#endif /* COMMAND_INTERPRETER_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
-- 
2.25.1

