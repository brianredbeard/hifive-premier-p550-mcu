From 3f5c4f08d513636e4c21a986364f935c5f03fb39 Mon Sep 17 00:00:00 2001
From: yangwei1 <yangwei1@eswincomputing.com>
Date: Tue, 14 May 2024 15:50:18 +0800
Subject: [PATCH 030/109] WIN2030-15186:feat:support ina226 to get system power
 info Changelogs: get system power info

Change-Id: I9f7c91f987ea5f67a125fe43a26d8a4c0f8f1fbd
---
 Core/Inc/hf_i2c.h           |   4 +
 Core/Inc/hf_power_process.h |  11 ++
 Core/Src/hf_i2c.c           |  36 ++++++-
 Core/Src/hf_power_process.c | 206 +++++++++++++++++++++++++++++++++++-
 Core/Src/web-server.c       |   4 +-
 5 files changed, 255 insertions(+), 6 deletions(-)
 create mode 100644 Core/Inc/hf_power_process.h

diff --git a/Core/Inc/hf_i2c.h b/Core/Inc/hf_i2c.h
index 773075c..57cf27f 100644
--- a/Core/Inc/hf_i2c.h
+++ b/Core/Inc/hf_i2c.h
@@ -20,6 +20,10 @@ int hf_i2c_mem_read(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
 						uint8_t reg_addr, uint8_t *data_ptr, uint32_t len);
 int hf_i2c_mem_write(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
 						uint8_t reg_addr, uint8_t *data_ptr, uint32_t len);
+int hf_i2c_reg_read_block(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
+					uint8_t reg_addr, uint8_t *data_ptr, uint8_t len);
+int hf_i2c_reg_write_block(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
+					 uint8_t reg_addr, uint8_t *data_ptr, uint8_t len);
 #ifdef __cplusplus
 }
 #endif
diff --git a/Core/Inc/hf_power_process.h b/Core/Inc/hf_power_process.h
new file mode 100644
index 0000000..ddb995c
--- /dev/null
+++ b/Core/Inc/hf_power_process.h
@@ -0,0 +1,11 @@
+#ifndef __HF_POWER_PROCESS_H
+#define __HF_POWER_PROCESS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "hf_common.h"
+
+int get_board_power(uint32_t *volt, uint32_t *curr, uint32_t *power);
+int get_som_power(uint32_t *volt, uint32_t *curr, uint32_t *power);
+#endif /* __HF_I2C_H */
\ No newline at end of file
diff --git a/Core/Src/hf_i2c.c b/Core/Src/hf_i2c.c
index ca79b58..2ab9397 100644
--- a/Core/Src/hf_i2c.c
+++ b/Core/Src/hf_i2c.c
@@ -105,4 +105,38 @@ int hf_i2c_mem_write(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
 	if (hi2c->Instance == I2C1)
 		HAL_GPIO_WritePin(EEPROM_WP_GPIO_Port, EEPROM_WP_Pin, GPIO_PIN_SET);
 	return status;
-}
\ No newline at end of file
+}
+
+int hf_i2c_reg_write_block(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
+					 uint8_t reg_addr, uint8_t *data_ptr, uint8_t len)
+{
+	HAL_StatusTypeDef status = HAL_OK;
+
+	status = HAL_I2C_Mem_Write(hi2c, slave_addr, reg_addr, I2C_MEMADD_SIZE_8BIT,
+							   data_ptr, len, 0xff);
+	if (status != HAL_OK) {
+		printf("I2Cx_write_Error(%x) reg %x; status %x\r\n", slave_addr, reg_addr, status);
+		return status;
+	}
+	while (HAL_I2C_GetState(hi2c) != HAL_I2C_STATE_READY);
+	while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
+	while (HAL_I2C_GetState(hi2c) != HAL_I2C_STATE_READY);
+	return status;
+}
+
+int hf_i2c_reg_read_block(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
+					uint8_t reg_addr, uint8_t *data_ptr, uint8_t len)
+{
+	HAL_StatusTypeDef status = HAL_OK;
+	while (HAL_I2C_GetState(hi2c) != HAL_I2C_STATE_READY);
+	status = HAL_I2C_Mem_Read(hi2c, slave_addr, reg_addr, I2C_MEMADD_SIZE_8BIT,
+							  data_ptr, len, 0xff);
+	if (status != HAL_OK){
+		printf("I2Cx_read_Error(%x) reg %x; status %x\r\n", slave_addr, reg_addr, status);
+		return status;
+	}
+	while (HAL_I2C_GetState(hi2c) != HAL_I2C_STATE_READY);
+	while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
+	while (HAL_I2C_GetState(hi2c) != HAL_I2C_STATE_READY);
+	return status;
+}
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index 27d81d4..836276a 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -8,6 +8,7 @@
 #include "hf_common.h"
 #include "hf_i2c.h"
 #include "hf_spi_slv.h"
+#include "hf_power_process.h"
 /* Private typedef -----------------------------------------------------------*/
 // #define AUTO_BOOT
 #define POWER_TESET_MODE
@@ -20,6 +21,45 @@
 
 /* Private macro -------------------------------------------------------------*/
 #define PCA9450_ADDR (0x25u << 1)
+#define INA226_12V_ADDR (0X44U << 1)
+#define PAC1934_ADDR (0X10U << 1)
+
+#define INA2XX_CONFIG 0x00
+#define INA2XX_SHUNT_VOLTAGE 0x01 /* readonly */
+#define INA2XX_BUS_VOLTAGE 0x02	  /* readonly */
+#define INA2XX_POWER 0x03		  /* readonly */
+#define INA2XX_CURRENT 0x04		  /* readonly */
+#define INA2XX_CALIBRATION 0x05
+
+#define INA226_BUS_LSB 1250 /*uV*/
+
+#define INA226_SHUNT_RESISTOR 1000							 /*uOhm*/
+#define INA226_CURRENT_LSB (2500000 / INA226_SHUNT_RESISTOR) /*uA */
+#define INA226_POWER_LSB_FACTOR 25
+
+#define PAC193X_CMD_CTRL 0x1
+#define PAC193X_CMD_VBUS1 0x7
+#define PAC193X_CMD_VSENSE1 0xb
+#define PAC193X_CMD_VPOWER1 0x17
+#define PAC193X_CMD_REFRESH_V 0x1F
+#define PAC193X_CMD_NEG_PWR_ACT 0x23
+#define PAC193X_COSTANT_PWR_M 3200000000ull /* 3.2V^2*1000mO*/
+#define PAC193X_COSTANT_CURRENT_M 100000	/* 100mv*1000mO*/
+#define PAC193X_SHUNT_RESISTOR_M 4			/* mO*/
+
+#define DIV_ROUND_CLOSEST(x, divisor) (        \
+	{                                          \
+		typeof(x) __x = x;                     \
+		typeof(divisor) __d = divisor;         \
+		(((typeof(x))-1) > 0 ||                \
+		 ((typeof(divisor))-1) > 0 ||          \
+		 (((__x) > 0) == ((__d) > 0)))         \
+			? (((__x) + ((__d) / 2)) / (__d))  \
+			: (((__x) - ((__d) / 2)) / (__d)); \
+	})
+#define SWAP16(w) ((((w) & 0xff) << 8) | (((w) & 0xff00) >> 8))
+#define SWAP32(w) ((((w) & 0xff) << 24) | (((w) & 0xff00) << 8) | (((w) & 0xff0000) >> 8) | (((w) & 0xff000000) >> 24))
+
 /* Private variables ---------------------------------------------------------*/
 volatile power_switch_t som_power_state = SOM_POWER_OFF;
 
@@ -178,7 +218,7 @@ void hf_power_task(void *parameter)
 
 void power_test_dome(void)
 {
-	#ifdef POWER_TESET_MODE
+#ifdef POWER_TESET_MODE
 	HAL_StatusTypeDef status = HAL_OK;
 	uint8_t pin_state = 0;
 	printf("atx_power_on\r\n");
@@ -199,20 +239,20 @@ void power_test_dome(void)
 		osDelay(50);
 	}while(status != pdTRUE);
 	i2c_init(I2C1);
-	#endif
+#endif
 }
 
 void set_power_off(void)
 {
 	i2c_deinit(I2C3);
 	som_reset_control(pdTRUE);
-	#ifndef POWER_TESET_MODE
+#ifndef POWER_TESET_MODE
 	i2c_deinit(I2C1); // dvb v2 move to board init
 	pmic_power_on(pdFALSE);
 	osDelay(10);
 	atx_power_on(pdFALSE);
 	osDelay(10);
-	#endif
+#endif
 	pmic_status_led_on(pdFALSE);
 	power_led_on(pdFALSE);
 }
@@ -351,6 +391,164 @@ static int pmic_b6out_105v(void)
 	return reg_dat == read_dat ? 1 : 0;
 }
 
+static int ina226_init(void)
+{
+	uint16_t default_cfg = SWAP16(0x4527);
+	uint16_t calibration_value = SWAP16(2048);
+	int ret = 0;
+
+	ret = hf_i2c_reg_write_block(&hi2c3, INA226_12V_ADDR, INA2XX_CONFIG, (uint8_t *)&default_cfg, 2);
+	if (ret)
+	{
+		printf("init ina226 error1\n");
+		return -1;
+	}
+	ret = hf_i2c_reg_write_block(&hi2c3, INA226_12V_ADDR, INA2XX_CALIBRATION, (uint8_t *)&calibration_value, 2);
+	if (ret)
+	{
+		printf("init ina226 error2\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+int get_board_power(uint32_t *volt, uint32_t *curr, uint32_t *power)
+{
+	uint32_t reg_bus = 0x0;
+	uint32_t reg_power = 0x0;
+	uint32_t reg_curr = 0x0;
+	int ret = 0;
+	static int is_first = 1;
+
+	if (1 == is_first)
+	{
+		/*Write failure, not find wrong reason*/
+		ret = ina226_init();
+		if (ret)
+		{
+			return -1;
+		}
+		is_first = 0;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_BUS_VOLTAGE, (uint8_t *)&reg_bus, 2);
+	if (ret)
+	{
+		printf("get board volt error\n");
+		return -1;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_POWER, (uint8_t *)&reg_power, 2);
+	if (ret)
+	{
+		printf("get board power error\n");
+		return -1;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_CURRENT, (uint8_t *)&reg_curr, 2);
+	if (ret)
+	{
+		printf("get board current error\n");
+		return -1;
+	}
+	reg_bus = SWAP16(reg_bus);
+	reg_curr = SWAP16(reg_curr);
+	reg_power = SWAP16(reg_power);
+
+	*volt = reg_bus * INA226_BUS_LSB;
+	*volt = DIV_ROUND_CLOSEST(*volt, 1000);
+
+	*power = reg_power * INA226_CURRENT_LSB * INA226_POWER_LSB_FACTOR;
+	*curr = reg_curr * INA226_CURRENT_LSB;
+	*curr = DIV_ROUND_CLOSEST(*curr, 1000);
+
+	return 0;
+}
+
+
+int get_som_power(uint32_t *volt, uint32_t *curr, uint32_t *power)
+{
+	uint32_t reg_bus = 0x0;
+	uint32_t reg_power = 0x0;
+	uint32_t reg_curr = 0x0;
+	int ret = 0;
+	static int is_first = 1;
+	uint8_t act_val = 0;
+	uint8_t is_neg = 0;
+	uint8_t ctrl_value = 0x8;
+
+	if (1 == is_first)
+	{
+		/*Write failure, not find wrong reason*/
+		hf_i2c_reg_write(&hi2c3, PAC1934_ADDR, PAC193X_CMD_CTRL, &ctrl_value);
+
+		if (ret)
+		{
+			return -1;
+		}
+		is_first = 0;
+	}
+
+	hf_i2c_reg_write_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_REFRESH_V, (uint8_t *)&ctrl_value, 0);
+	osDelay(1);
+	ret = hf_i2c_reg_read(&hi2c3, PAC1934_ADDR, PAC193X_CMD_NEG_PWR_ACT, &act_val);
+	if (ret)
+	{
+		printf("get PAC1934 act_val error\n");
+		return -1;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VBUS1, (uint8_t *)&reg_bus, 2);
+	if (ret)
+	{
+		printf("get PAC1934 voltage error\n");
+		return -1;
+	}
+	reg_bus = reg_bus & 0XFFFF;
+	reg_bus = SWAP16(reg_bus);
+	if (0x1 == ((act_val >> 3) & 0x1))
+	{
+		*volt = reg_bus * 1000 / 1024;
+		is_neg = 1;
+	}
+	else
+	{
+		*volt = reg_bus * 1000 / 2048;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VSENSE1, (uint8_t *)&reg_curr, 2);
+	reg_curr = SWAP16(reg_curr);
+	if (ret)
+	{
+		printf("get PAC1934 current error\n");
+		return -1;
+	}
+	reg_curr = reg_curr & 0XFFFF;
+	if (0x1 == ((act_val >> 7) & 0x1))
+	{
+		*curr = reg_curr * PAC193X_COSTANT_CURRENT_M / (32768 * PAC193X_SHUNT_RESISTOR_M);
+		is_neg = 1;
+	}
+	else
+	{
+		*curr = reg_curr * PAC193X_COSTANT_CURRENT_M / (65536 * PAC193X_SHUNT_RESISTOR_M);
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VPOWER1, (uint8_t *)&reg_power, 4);
+	reg_power = SWAP32(reg_power);
+	if (ret)
+	{
+		printf("get PAC1934 power error\n");
+		return -1;
+	}
+	reg_power = reg_power >> 4;
+	if (1 == is_neg)
+	{
+		*power = reg_power * PAC193X_COSTANT_PWR_M / (PAC193X_SHUNT_RESISTOR_M * 134217728ULL);
+	}
+	else
+	{
+		*power = reg_power * PAC193X_COSTANT_PWR_M / (PAC193X_SHUNT_RESISTOR_M * 268435456ULL);
+	}
+
+	return 0;
+}
+
 power_switch_t get_som_power_state(void)
 {
 	power_switch_t state;
diff --git a/Core/Src/web-server.c b/Core/Src/web-server.c
index 2e5d19e..bcbd11c 100644
--- a/Core/Src/web-server.c
+++ b/Core/Src/web-server.c
@@ -8,7 +8,7 @@
 #include "string.h"
 #include "hf_common.h"
 #include <assert.h>
-
+#include "hf_power_process.h"
 
 #define SESSION_ID_LENGTH 32
 #define BUF_SIZE 1024
@@ -10655,6 +10655,8 @@ POWERInfo get_power_info(){
 	POWERInfo example = {
         60,5,12
     };
+	get_board_power(&example.voltage,&example.current,&example.consumption);
+	//get_som_power(&example.voltage,&example.current,&example.consumption);
     return example;
 }
 
-- 
2.25.1

