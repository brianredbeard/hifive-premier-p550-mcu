From 2168877cacdcdf39f188cf3ba209f7114fe6e15b Mon Sep 17 00:00:00 2001
From: yuan junhui <yuanjunhui@eswincomputing.com>
Date: Fri, 7 Jun 2024 13:52:07 +0800
Subject: [PATCH 077/109] WIN2030-15099:fix(web-serve console):disable mac
 configuration by web

Changelogs:
1.disable mac modification by web
2.Support som and mcu MAC setting with cli
3.fix bug of get_mcu_server_info()
4.Do NOT set cbinfo with factory setting when failed with both A/B partitions
  checksum.
5.Use xSemaphoreTake to protect eeprom instead of taskENTER_CRITICAL

Change-Id: I767eec4f22218bbf78b87867a951f902ee42f7b4
---
 Core/Inc/hf_common.h           | 146 +++++-----
 Core/Inc/hf_spi_slv.h          |   4 +-
 Core/Inc/main.h                |  42 ++-
 Core/Src/console.c             |  41 ++-
 Core/Src/hf_board_init.c       | 423 +++++++++++++----------------
 Core/Src/hf_common.c           | 111 +++++---
 Core/Src/hf_gpio_process.c     |  60 +----
 Core/Src/hf_http_process.c     |   2 +-
 Core/Src/hf_power_process.c    | 479 ++++++++++++++++++++++++++++-----
 Core/Src/hf_protocol_process.c |   3 +-
 Core/Src/hf_spi_slv.c          |  12 +-
 Core/Src/main.c                |  12 +-
 Core/Src/stm32f4xx_hal_msp.c   |  15 +-
 Core/Src/stm32f4xx_it.c        |  60 ++---
 Core/Src/web-server.c          |  53 ++--
 15 files changed, 872 insertions(+), 591 deletions(-)

diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index 78c8755..d93e5da 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -8,48 +8,42 @@ extern "C" {
 
 /* Includes ------------------------------------------------------------------*/
 #include <stdio.h>
-
+#include "stm32f4xx_hal.h"
 #include "FreeRTOS.h"
 #include "list.h"
-#include "queue.h"
-#include "stm32f4xx_hal.h"
 #include "task.h"
+#include "queue.h"
 
 /* types ------------------------------------------------------------*/
 typedef enum {
-	IDLE_STATE,
-	ATX_PS_ON_STATE,
-	DC_PWR_ON_STATE,
-	DC_PWR_GOOD_STATE,
-	SOM_STATUS_CHECK_STATE,
-	POWERON,
-	STOP_POWER
+  IDLE_STATE,
+  ATX_PS_ON_STATE,
+  ATX_PWR_GOOD_STATE,
+  DC_PWR_GOOD_STATE,
+  SOM_STATUS_CHECK_STATE,
+  RESET_SOM,
+  POWERON,
+  STOP_POWER
 } power_state_t;
 
 typedef enum {
-	KEY_IDLE_STATE = 0,
-	KEY_PRESS_DETECTED_STATE,
-	KEY_RELEASE_DETECTED_STATE,
-	KEY_SHORT_PRESS_STATE,
-	KEY_LONG_PRESS_STATE,
-	KEY_DOUBLE_PRESS_STATE,
-	KEY_PRESS_STATE_END
+  KEY_IDLE_STATE = 0,
+  KEY_PRESS_DETECTED_STATE,
+  KEY_RELEASE_DETECTED_STATE,
+  KEY_SHORT_PRESS_STATE,
+  KEY_LONG_PRESS_STATE,
+  KEY_DOUBLE_PRESS_STATE,
+  KEY_PRESS_STATE_END
 } button_state_t;
 
 typedef enum {
-	SOM_POWER_OFF,
-	SOM_POWER_ON
+  SOM_POWER_OFF,
+  SOM_POWER_ON
 } power_switch_t;
 
 typedef enum {
-	LED_MCU_RUNING = 0x1u,
-	LED_SOM_BOOTING,
-	LED_SOM_KERNEL_RUNING
-} led_status_t;
-
-typedef enum {
-	SOM_DAEMON_OFF,
-	SOM_DAEMON_ON,
+  SOM_DAEMON_OFF,
+  SOM_DAEMON_ON,
 } deamon_stats_t;
 
 #define FRAME_DATA_MAX 250
@@ -63,28 +57,28 @@ typedef enum {
 	CMD_PVT_INFO,
 	CMD_BOARD_STATUS,
 	CMD_POWER_INFO,
-	CMD_RESTART, // cold reboot with power off/on
-				 // You can continue adding other command types
+	CMD_RESTART,    //cold reboot with power off/on
+	// You can continue adding other command types
 } CommandType;
 
 // Message structure
 typedef struct {
-	uint32_t header;			  // Frame header
-	uint32_t xTaskToNotify;		  // id
-	uint8_t msg_type;			  // Message type
-	uint8_t cmd_type;			  // Command type
-	uint8_t cmd_result;			  // command result
-	uint8_t data_len;			  // Data length
+	uint32_t header;	// Frame header
+	uint32_t xTaskToNotify; // id
+	uint8_t msg_type; 	// Message type
+	uint8_t cmd_type; 	// Command type
+	uint8_t cmd_result;  // command result
+	uint8_t data_len; 	// Data length
 	uint8_t data[FRAME_DATA_MAX]; // Data
-	uint8_t checksum;			  // Checksum
-	uint32_t tail;				  // Frame tail
+	uint8_t checksum; 	// Checksum
+	uint32_t tail;		// Frame tail
 } __attribute__((packed)) Message;
 
 // WebCmd structure
 typedef struct {
-	ListItem_t xListItem; // FreeRTOS list item, must be the first member of the struct
+	ListItem_t xListItem; 	// FreeRTOS list item, must be the first member of the struct
 	TaskHandle_t xTaskToNotify;
-	uint8_t cmd_result;			  // command result
+	uint8_t cmd_result;  // command result
 	uint8_t data[FRAME_DATA_MAX]; // command result Data
 } WebCmd;
 
@@ -106,7 +100,7 @@ typedef struct {
 	uint8_t pcbRevision;
 	uint8_t bomRevision;
 	uint8_t bomVariant;
-	char boardSerialNumber[18]; // 18 bytes of serial number, excluding string terminator
+	char boardSerialNumber[18];	// 18 bytes of serial number, excluding string terminator
 	uint8_t manufacturingTestStatus;
 	uint8_t ethernetMAC1[6];	// The MAC of the SOM
 	uint8_t ethernetMAC2[6];	// The MAC of the SOM
@@ -126,12 +120,10 @@ typedef struct {
 } MCUServerInfo;
 
 typedef struct {
-	uint8_t som_pwr_lost_resume_attr;	  // enable(0xE) or disable(0xD) the last power state of the SOM
-	uint8_t som_pwr_last_state;			  // record the latest power state of the SOM: POWER ON(0xE), POWER OFF(0xD)
-	uint8_t som_dip_switch_soft_ctl_attr; // determin whether the bootsel of the SOM is controlled by software(0xE) via
-										  // GPIO or by hardware switch(0xD)
-	uint8_t som_dip_switch_soft_state; // record the DIP Switch software state of the SOM, it is used for SOM bootsel,
-									   // bit0---bit3 stand for the DIP0---DIP3
+	uint8_t som_pwr_lost_resume_attr;	// enable(0xE) or disable(0xD) the last power state of the SOM
+	uint8_t som_pwr_last_state;		// record the latest power state of the SOM: POWER ON(0xE), POWER OFF(0xD)
+	uint8_t som_dip_switch_soft_ctl_attr;	// determin whether the bootsel of the SOM is controlled by software(0xE) via GPIO or by hardware switch(0xD)
+	uint8_t som_dip_switch_soft_state;	// record the DIP Switch software state of the SOM, it is used for SOM bootsel, bit0---bit3 stand for the DIP0---DIP3
 } SomPwrMgtDIPInfo;
 
 struct gpio_cmd {
@@ -182,10 +174,10 @@ struct spi_slv_w32_t {
 };
 
 struct rtc_date_t {
-	uint16_t Year;
-	uint8_t Month;
-	uint8_t Date;
-	uint8_t WeekDay;
+  uint16_t Year;
+  uint8_t Month;
+  uint8_t Date;
+  uint8_t WeekDay;
 };
 
 struct rtc_time_t {
@@ -195,22 +187,26 @@ struct rtc_time_t {
 };
 
 typedef struct {
-	int dip01; // 0 on,1 off
-	int dip02;
-	int dip03;
+    int dip01;//0 on,1 off
+    int dip02;
+    int dip03;
 	int dip04;
-	int swctrl; // 0 hw,1,sw
+	int swctrl;//0 hw,1,sw
 } DIPSwitchInfo;
 /* constants --------------------------------------------------------*/
 extern UART_HandleTypeDef huart3;
 
 /* macro ------------------------------------------------------------*/
-#define __ALIGN_KERNEL(x, a) __ALIGN_KERNEL_MASK(x, (typeof(x))(a)-1)
-#define __ALIGN_KERNEL_MASK(x, mask) (((x) + (mask)) & ~(mask))
-#define ALIGN(x, a) __ALIGN_KERNEL((x), (a))
+#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
+#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
+#define ALIGN(x, a)		__ALIGN_KERNEL((x), (a))
+
+#define MAX(x , y)  (((x) > (y)) ? (x) : (y))
+#define MIN(x , y)  (((x) < (y)) ? (x) : (y))
 
-#define MAX(x, y) (((x) > (y)) ? (x) : (y))
-#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+#define SOM_MAC0_IDX	0
+#define SOM_MAC1_IDX	1
+#define MCU_MAC_IDX	2
 /* define ------------------------------------------------------------*/
 #define BMC_SOFTWARE_VERSION_MAJOR                   1
 #define BMC_SOFTWARE_VERSION_MINOR                   2
@@ -245,26 +241,26 @@ A cbinfo	64		0
 #define DEFAULT_ADMIN_NAME	"admin"
 #define DEFAULT_ADMIN_PASSWORD	"123456"
 
-#define SOM_PWR_LOST_RESUME_ENABLE 0xE // the eeprom internal value. For outside users, the corresponding value is TURE
-#define SOM_PWR_LOST_RESUME_DISABLE 0xD
+#define SOM_PWR_LOST_RESUME_ENABLE	0xE // the eeprom internal value. For outside users, the corresponding value is TURE
+#define SOM_PWR_LOST_RESUME_DISABLE	0xD
 
-#define SOM_PWR_LAST_STATE_ON 0xE // the eeprom internal value. For outside users, the corresponding value is TURE
-#define SOM_PWR_LAST_STATE_OFF 0xD
+#define SOM_PWR_LAST_STATE_ON	0xE // the eeprom internal value. For outside users, the corresponding value is TURE
+#define SOM_PWR_LAST_STATE_OFF	0xD
 
-#define SOM_DIP_SWITCH_SOFT_CTL_ENABLE \
-	0xE // the eeprom internal value. For outside users, the corresponding value is TURE
-#define SOM_DIP_SWITCH_SOFT_CTL_DISABLE 0xD
+#define SOM_DIP_SWITCH_SOFT_CTL_ENABLE	0xE // the eeprom internal value. For outside users, the corresponding value is TURE
+#define SOM_DIP_SWITCH_SOFT_CTL_DISABLE	0xD
+
+#define SOM_DIP_SWITCH_STATE_EMMC	0xE1 // the eeprom internal value. For outside users, the corresponding value is 0x1
 
-#define SOM_DIP_SWITCH_STATE_EMMC 0xE1 // the eeprom internal value. For outside users, the corresponding value is 0x1
 
 #define ES_EEPROM_INFO_TEST 0
 /* CLI console settings */
-#define CONSOLE_INSTANCE USART3
-#define CONSOLE_TASK_PRIORITY 1
-#define CONSOLE_STACK_SIZE 1024 // 3000
-#define consoleHandle huart3
+#define CONSOLE_INSTANCE		USART3
+#define CONSOLE_TASK_PRIORITY		1
+#define CONSOLE_STACK_SIZE		1024//3000
+#define consoleHandle			huart3
 
-#define ES_PRODUCTION_LINE_TEST 0
+#define ES_PRODUCTION_LINE_TEST		0
 
 /* functions prototypes ---------------------------------------------*/
 void hexstr2mac(uint8_t *mac, const char *hexstr);
@@ -279,9 +275,8 @@ int es_init_info_in_eeprom(void);
 
 int es_get_carrier_borad_info(CarrierBoardInfo *pCarrier_board_info);
 int es_set_carrier_borad_info(CarrierBoardInfo *pCarrier_board_info);
-
-int es_get_mcu_mac(uint8_t *p_mac_address);
-int es_set_mcu_mac(uint8_t *p_mac_address);
+int es_get_mcu_mac(uint8_t *p_mac_address, uint8_t index);
+int es_set_mcu_mac(uint8_t *p_mac_address, uint8_t index);
 
 int es_get_mcu_ipaddr(uint8_t *p_ip_address);
 int es_set_mcu_ipaddr(uint8_t *p_ip_address);
@@ -340,7 +335,6 @@ power_info get_power_info(void);
 int xSOMRestartHandle(void);
 int xSOMRebootHandle(void);
 
-void set_mcu_led_status(led_status_t type);
 int es_restore_userdata_to_factory(void);
 
 /* Dynamically change eth */
diff --git a/Core/Inc/hf_spi_slv.h b/Core/Inc/hf_spi_slv.h
index 98a68ab..9f064df 100644
--- a/Core/Inc/hf_spi_slv.h
+++ b/Core/Inc/hf_spi_slv.h
@@ -5,12 +5,12 @@
  extern "C" {
 #endif
 
-#define SPI2_MASTER_CS_LOW()                                                  \
+#define SPI2_FLASH_CS_LOW()                                                  \
 	do {                                                                     \
 		HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_RESET); \
 	} while (0);
 
-#define SPI2_MASTER_CS_HIGH()                                               \
+#define SPI2_FLASH_CS_HIGH()                                               \
 	do {                                                                   \
 		HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_SET); \
 	} while (0);
diff --git a/Core/Inc/main.h b/Core/Inc/main.h
index ca31130..4ce6f59 100644
--- a/Core/Inc/main.h
+++ b/Core/Inc/main.h
@@ -45,10 +45,8 @@ extern DMA_HandleTypeDef hdma_spi1_rx;
 extern DMA_HandleTypeDef hdma_spi1_tx;
 extern DMA_HandleTypeDef hdma_spi2_rx;
 extern DMA_HandleTypeDef hdma_spi2_tx;
-extern TIM_HandleTypeDef htim1;
 extern TIM_HandleTypeDef htim4;
-extern TIM_HandleTypeDef htim9;
-extern TIM_HandleTypeDef htim12;
+extern TIM_HandleTypeDef htim5;
 extern UART_HandleTypeDef huart4;
 extern UART_HandleTypeDef huart6;
 extern WWDG_HandleTypeDef hwwdg;
@@ -68,42 +66,26 @@ int board_init(void);
 /* Private defines -----------------------------------------------------------*/
 #define ATX_PS_ON_Pin GPIO_PIN_3
 #define ATX_PS_ON_GPIO_Port GPIOE
+#define ATX_PWR_OK_Pin GPIO_PIN_4
+#define ATX_PWR_OK_GPIO_Port GPIOE
 #define DCDC_PWR_OK_Pin GPIO_PIN_5
 #define DCDC_PWR_OK_GPIO_Port GPIOE
-#define CHASS_FAN_TACH1_Pin GPIO_PIN_6
-#define CHASS_FAN_TACH1_GPIO_Port GPIOE
 #define MCU_PHY_RESETN_Pin GPIO_PIN_0
 #define MCU_PHY_RESETN_GPIO_Port GPIOC
-#define I2C_MUX_EN_Pin GPIO_PIN_3
-#define I2C_MUX_EN_GPIO_Port GPIOA
-#define KEY_USER_RST_Pin GPIO_PIN_1
-#define KEY_USER_RST_GPIO_Port GPIOB
-#define LED_PWM1_Pin GPIO_PIN_9
-#define LED_PWM1_GPIO_Port GPIOE
-#define LED_PWM2_Pin GPIO_PIN_11
-#define LED_PWM2_GPIO_Port GPIOE
-#define LED_PWM3_Pin GPIO_PIN_13
-#define LED_PWM3_GPIO_Port GPIOE
-#define DC_POWER_EN0_Pin GPIO_PIN_4
-#define DC_POWER_EN0_GPIO_Port GPIOD
-#define DC_POWER_EN1_Pin GPIO_PIN_15
-#define DC_POWER_EN1_GPIO_Port GPIOE
-#define CHASS_FAN_TACH2_Pin GPIO_PIN_14
-#define CHASS_FAN_TACH2_GPIO_Port GPIOB
 #define SPI1_NSS_Pin GPIO_PIN_4
 #define SPI1_NSS_GPIO_Port GPIOA
+#define EEPROM_WP_Pin GPIO_PIN_14
+#define EEPROM_WP_GPIO_Port GPIOB
 #define UART_MUX_SEL_Pin GPIO_PIN_15
 #define UART_MUX_SEL_GPIO_Port GPIOB
 #define PWR_LED_Pin GPIO_PIN_10
 #define PWR_LED_GPIO_Port GPIOD
 #define SLP_LED_Pin GPIO_PIN_11
 #define SLP_LED_GPIO_Port GPIOD
-#define FAN1_PWM_Pin GPIO_PIN_12
-#define FAN1_PWM_GPIO_Port GPIOD
-#define FAN2_PWM_Pin GPIO_PIN_13
-#define FAN2_PWM_GPIO_Port GPIOD
-#define EEPROM_WP_Pin GPIO_PIN_8
-#define EEPROM_WP_GPIO_Port GPIOC
+#define JTAG_MUX_SEL_Pin GPIO_PIN_10
+#define JTAG_MUX_SEL_GPIO_Port GPIOA
+#define JTAG_MUX_EN_Pin GPIO_PIN_11
+#define JTAG_MUX_EN_GPIO_Port GPIOA
 #define PWR_SW_P_Pin GPIO_PIN_12
 #define PWR_SW_P_GPIO_Port GPIOA
 #define PWR_SW_P_EXTI_IRQn EXTI15_10_IRQn
@@ -115,12 +97,18 @@ int board_init(void);
 #define BOOT_SEL2_GPIO_Port GPIOD
 #define BOOT_SEL3_Pin GPIO_PIN_3
 #define BOOT_SEL3_GPIO_Port GPIOD
+#define SOM_PMIC_ON_REQ_Pin GPIO_PIN_4
+#define SOM_PMIC_ON_REQ_GPIO_Port GPIOD
 #define MCU_RESET_SOM_N_Pin GPIO_PIN_5
 #define MCU_RESET_SOM_N_GPIO_Port GPIOD
 #define SOM_RST_OUT_N_Pin GPIO_PIN_6
 #define SOM_RST_OUT_N_GPIO_Port GPIOD
 #define SPI2_NSS_Pin GPIO_PIN_9
 #define SPI2_NSS_GPIO_Port GPIOB
+#define CHASS_FAN_TACH1_Pin GPIO_PIN_0
+#define CHASS_FAN_TACH1_GPIO_Port GPIOE
+#define CHASS_FAN_TACH2_Pin GPIO_PIN_1
+#define CHASS_FAN_TACH2_GPIO_Port GPIOE
 
 #ifdef __cplusplus
 }
diff --git a/Core/Src/console.c b/Core/Src/console.c
index 1cbd2e7..0d52437 100644
--- a/Core/Src/console.c
+++ b/Core/Src/console.c
@@ -187,9 +187,9 @@ static const CLI_Command_Definition_t xCommands[] =
     },
     {
         "setmac",
-        "\r\nsetmac <mac,like a1:26:39:91:b0:22>: Set mac address.\r\n",
+        "\r\nsetmac <index,0-2> <mac,like a1:26:39:91:b0:22>: Set mac address.\r\n",
         prvCommandMacSet,
-        1
+        2
     },
     {
         "bootsel-g",
@@ -627,6 +627,7 @@ static BaseType_t prvCommandNetInfoGet(char *pcWriteBuffer, size_t xWriteBufferL
     char *pcWb = pcWriteBuffer;
     size_t len, size = xWriteBufferLen;
     NETInfo netInfo;
+    uint8_t mac[6];
 
     /* Read network information and fill FreeRTOS write buffer */
     netInfo = get_net_info();
@@ -640,7 +641,19 @@ static BaseType_t prvCommandNetInfoGet(char *pcWriteBuffer, size_t xWriteBufferL
     pcWb += len;
     size -= len;
 
-    len = snprintf(pcWb, size, "mac %s\r\n", netInfo.macaddr);
+    es_get_mcu_mac(mac, SOM_MAC0_IDX);
+    len = snprintf(pcWb, size, "SOM_Mac0: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
+            mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
+    pcWb += len;
+    size -= len;
+
+    es_get_mcu_mac(mac, SOM_MAC1_IDX);
+    len = snprintf(pcWb, size, "SOM_Mac1: %02x:%02x:%02x:%02x:%02x:%02x\r\n",
+            mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
+    pcWb += len;
+    size -= len;
+
+    len = snprintf(pcWb, size, "MCU_Mac:  %s\r\n", netInfo.macaddr);
 
     return pdFALSE;
 }
@@ -707,9 +720,9 @@ static BaseType_t prvCommandNetMaskSet(char *pcWriteBuffer, size_t xWriteBufferL
 
     /* dynamically change netmask */
     netmask.netmask_addr0 = 0xff & naddr;
-    netmask.netmask_addr0 = 0xff & (naddr >> 8);
-    netmask.netmask_addr0 = 0xff & (naddr >> 16);
-    netmask.netmask_addr0 = 0xff & (naddr >> 24);
+    netmask.netmask_addr1 = 0xff & (naddr >> 8);
+    netmask.netmask_addr2 = 0xff & (naddr >> 16);
+    netmask.netmask_addr3 = 0xff & (naddr >> 24);
     es_set_eth(NULL, &netmask, NULL, NULL);
 
     snprintf(pcWriteBuffer, xWriteBufferLen, "netmask addr set to %s(0x%lx)\r\n", pcIPaddr, naddr);
@@ -764,20 +777,26 @@ out:
 static BaseType_t prvCommandMacSet(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
 {
     const char * pcMACaddr;
+    const char * pcMACIdx;
     BaseType_t xParamLen;
     uint8_t mac[6];
+    uint8_t mac_index;
+
+    pcMACIdx = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    mac_index = atoi(pcMACIdx);
 
-    pcMACaddr = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParamLen);
+    pcMACaddr = FreeRTOS_CLIGetParameter(pcCommandString, 2, &xParamLen);
 
     /* set mac */
     hexstr2mac(mac, pcMACaddr);
-    es_set_mcu_mac(mac);
+    if (es_set_mcu_mac(mac, mac_index))
+        goto out;
 
-    snprintf(pcWriteBuffer, xWriteBufferLen, "MAC addr set to %s(%x:%x:%x:%x:%x:%x)\r\n",
-                pcMACaddr, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+    snprintf(pcWriteBuffer, xWriteBufferLen, "MAC[%d] addr set to %s(%x:%x:%x:%x:%x:%x)\r\n",
+                mac_index, pcMACaddr, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 
     printf("The MAC setting will be valid after rebooting the carrier board!!!\n");
-
+out:
     return pdFALSE;
 }
 
diff --git a/Core/Src/hf_board_init.c b/Core/Src/hf_board_init.c
index 577efe2..c23327e 100644
--- a/Core/Src/hf_board_init.c
+++ b/Core/Src/hf_board_init.c
@@ -43,8 +43,7 @@ DMA_HandleTypeDef hdma_spi2_rx;
 DMA_HandleTypeDef hdma_spi2_tx;
 TIM_HandleTypeDef htim1;
 TIM_HandleTypeDef htim4;
-TIM_HandleTypeDef htim9;
-TIM_HandleTypeDef htim12;
+TIM_HandleTypeDef htim5;
 UART_HandleTypeDef huart4;
 UART_HandleTypeDef huart3;
 UART_HandleTypeDef huart6;
@@ -68,23 +67,25 @@ static void MX_RTC_Init(void);
 static void MX_TIM4_Init(void);
 static void MX_SPI1_Init(void);
 static void MX_UART4_Init(void);
-static void MX_TIM1_Init(void);
-static void MX_TIM9_Init(void);
-static void MX_TIM12_Init(void);
 static void MX_CRC_Init(void);
 static void MX_RNG_Init(void);
 void MX_IWDG_Init(void);
+static void MX_TIM5_Init(void);
 
 /* Private user code ---------------------------------------------------------*/
 /* For cross-domain devices, initialize the I2C after the atx is powered on */
 void i2c_init(I2C_TypeDef *Instance)
 {
-	if (Instance == I2C1) {
+	if (Instance == I2C1)
+	{
 		// HAL_GPIO_WritePin(EEPROM_WP_GPIO_Port, EEPROM_WP_Pin, GPIO_PIN_RESET);
 		MX_I2C1_Init();
-	} else if (Instance == I2C3) {
+	}
+	else if (Instance == I2C3)
+	{
 		MX_I2C3_Init();
-	} else {
+	}
+	else {
 		printf("%s : I2C instance err!\n", __func__);
 	}
 }
@@ -103,9 +104,11 @@ void uart_init(USART_TypeDef *Instance)
 {
 	if (Instance == UART4) {
 		MX_UART4_Init();
-		// trigger uart rx
-		HAL_UARTEx_ReceiveToIdle_DMA(&huart4, (uint8_t *)&UART4_RxMsg, sizeof(UART4_RxMsg));
-	} else if (Instance == USART6)
+		//trigger uart rx
+		HAL_UARTEx_ReceiveToIdle_DMA(&huart4, (uint8_t *)&UART4_RxMsg,
+			sizeof(UART4_RxMsg));
+	}
+	else if (Instance == USART6)
 		MX_USART6_UART_Init();
 	else
 		printf("%s : uart instance err!\n", __func__);
@@ -137,18 +140,17 @@ int board_init(void)
 	MX_USART3_UART_Init();
 	MX_RTC_Init();
 	MX_TIM4_Init();
-	// MX_SPI1_Init();
+	MX_SPI1_Init();
 	MX_CRC_Init();
-	// MX_RNG_Init();
-	MX_TIM1_Init();
-	MX_TIM9_Init();
-	MX_TIM12_Init();
-	MX_I2C1_Init();
+	MX_RNG_Init();
+	// MX_TIM5_Init();
 	/* There is leakage, the som must be released before initialization */
 	// MX_UART4_Init();
 	// MX_USART6_UART_Init();
 
-	// MX_I2C3_Init();  // NOT USE
+	/* To ensure that the i2c runs properly, initialize the som after it is powered on */
+	// MX_I2C1_Init();
+	// MX_I2C3_Init();
 
 	/* watch dog */
 	// MX_WWDG_Init();
@@ -356,61 +358,6 @@ static void MX_SPI2_Init(void)
 	}
 }
 
-/**
- * @brief TIM1 Initialization Function
- * @param None
- * @retval None
- */
-uint32_t len_pwm_period = 1000;
-
-static void MX_TIM1_Init(void)
-{
-	/* USER CODE BEGIN TIM1_Init 0 */
-
-	/* USER CODE END TIM1_Init 0 */
-
-	TIM_MasterConfigTypeDef sMasterConfig = {0};
-	TIM_OC_InitTypeDef sConfigOC = {0};
-	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
-
-	/* USER CODE BEGIN TIM1_Init 1 */
-
-	/* USER CODE END TIM1_Init 1 */
-	htim1.Instance = TIM1;
-	htim1.Init.Prescaler = 8;
-	htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
-	htim1.Init.Period = len_pwm_period;
-	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
-	htim1.Init.RepetitionCounter = 0;
-	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
-	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK) {
-		Error_Handler();
-	}
-
-	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
-	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
-	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK) {
-		Error_Handler();
-	}
-	sConfigOC.OCMode = TIM_OCMODE_PWM1;
-	sConfigOC.Pulse = len_pwm_period / 2;
-	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
-	sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
-	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK) {
-		Error_Handler();
-	}
-	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK) {
-		Error_Handler();
-	}
-	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK) {
-		Error_Handler();
-	}
-	/* USER CODE BEGIN TIM1_Init 2 */
-
-	/* USER CODE END TIM1_Init 2 */
-	HAL_TIM_MspPostInit(&htim1);
-}
-
 /**
  * @brief TIM4 Initialization Function
  * @param None
@@ -446,122 +393,111 @@ static void MX_TIM4_Init(void)
 	}
 
 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
-	sConfigOC.Pulse = pwm_period / 2;
+	sConfigOC.Pulse = pwm_period/2;
 	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 	sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
-	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK) {
+	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
+	{
+	  Error_Handler();
+	}
+	sConfigOC.OCMode = TIM_OCMODE_PWM1;
+	sConfigOC.Pulse = pwm_period/2;
+	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
+	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
+	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
+	{
+	  Error_Handler();
+	}
+	sConfigOC.OCMode = TIM_OCMODE_PWM1;
+	sConfigOC.Pulse = pwm_period/2;
+	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
+	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
+	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK) {
 		Error_Handler();
 	}
-
 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
-	sConfigOC.Pulse = pwm_period / 2;
+	sConfigOC.Pulse = pwm_period/2;
 	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
-	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK) {
+	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK) {
 		Error_Handler();
 	}
 
-	/* USER CODE END TIM4_Init 2 */
 	HAL_TIM_MspPostInit(&htim4);
 }
 
-/**
- * @brief TIM9 Initialization Function
- * @param None
- * @retval None
- */
-static void MX_TIM9_Init(void)
-{
-	/* USER CODE BEGIN TIM9_Init 0 */
-
-	/* USER CODE END TIM9_Init 0 */
-
-	TIM_SlaveConfigTypeDef sSlaveConfig = {0};
-	TIM_IC_InitTypeDef sConfigIC = {0};
-
-	/* USER CODE BEGIN TIM9_Init 1 */
-
-	/* USER CODE END TIM9_Init 1 */
-	htim9.Instance = TIM9;
-	htim9.Init.Prescaler = 0;
-	htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
-	htim9.Init.Period = 65535;
-	htim9.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
-	htim9.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
-	if (HAL_TIM_IC_Init(&htim9) != HAL_OK) {
-		Error_Handler();
-	}
-	sSlaveConfig.SlaveMode = TIM_SLAVEMODE_RESET;
-	sSlaveConfig.InputTrigger = TIM_TS_TI2FP2;
-	sSlaveConfig.TriggerPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
-	sSlaveConfig.TriggerPrescaler = TIM_ICPSC_DIV1;
-	sSlaveConfig.TriggerFilter = 0;
-	if (HAL_TIM_SlaveConfigSynchro(&htim9, &sSlaveConfig) != HAL_OK) {
-		Error_Handler();
-	}
-	sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
-	sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
-	sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
-	sConfigIC.ICFilter = 0;
-	if (HAL_TIM_IC_ConfigChannel(&htim9, &sConfigIC, TIM_CHANNEL_1) != HAL_OK) {
-		Error_Handler();
-	}
-	sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
-	sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
-	if (HAL_TIM_IC_ConfigChannel(&htim9, &sConfigIC, TIM_CHANNEL_2) != HAL_OK) {
-		Error_Handler();
-	}
-}
 
 /**
- * @brief TIM12 Initialization Function
- * @param None
- * @retval None
- */
-static void MX_TIM12_Init(void)
+  * @brief TIM5 Initialization Function
+  * @param None
+  * @retval None
+  */
+static void MX_TIM5_Init(void)
 {
-	/* USER CODE BEGIN TIM12_Init 0 */
-
-	/* USER CODE END TIM12_Init 0 */
-
-	TIM_SlaveConfigTypeDef sSlaveConfig = {0};
-	TIM_IC_InitTypeDef sConfigIC = {0};
-
-	/* USER CODE BEGIN TIM12_Init 1 */
 
-	/* USER CODE END TIM12_Init 1 */
-	htim12.Instance = TIM12;
-	htim12.Init.Prescaler = 0;
-	htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
-	htim12.Init.Period = 65535;
-	htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
-	htim12.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
-	if (HAL_TIM_IC_Init(&htim12) != HAL_OK) {
-		Error_Handler();
-	}
-	sSlaveConfig.SlaveMode = TIM_SLAVEMODE_RESET;
-	sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;
-	sSlaveConfig.TriggerPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
-	sSlaveConfig.TriggerPrescaler = TIM_ICPSC_DIV1;
-	sSlaveConfig.TriggerFilter = 0;
-	if (HAL_TIM_SlaveConfigSynchro(&htim12, &sSlaveConfig) != HAL_OK) {
-		Error_Handler();
-	}
-	sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
-	sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
-	sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
-	sConfigIC.ICFilter = 0;
-	if (HAL_TIM_IC_ConfigChannel(&htim12, &sConfigIC, TIM_CHANNEL_1) != HAL_OK) {
-		Error_Handler();
-	}
-	sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
-	sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
-	if (HAL_TIM_IC_ConfigChannel(&htim12, &sConfigIC, TIM_CHANNEL_2) != HAL_OK) {
-		Error_Handler();
-	}
-	/* USER CODE BEGIN TIM12_Init 2 */
+  /* USER CODE BEGIN TIM5_Init 0 */
+
+  /* USER CODE END TIM5_Init 0 */
+
+  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
+  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
+  TIM_IC_InitTypeDef sConfigIC = {0};
+  TIM_MasterConfigTypeDef sMasterConfig = {0};
+
+  /* USER CODE BEGIN TIM5_Init 1 */
+
+  /* USER CODE END TIM5_Init 1 */
+  htim5.Instance = TIM5;
+  htim5.Init.Prescaler = 71;
+  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
+  htim5.Init.Period = 3000;
+  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
+  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
+  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
+  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  if (HAL_TIM_IC_Init(&htim5) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_RESET;
+  sSlaveConfig.InputTrigger = TIM_TS_TI2FP2;
+  sSlaveConfig.TriggerPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
+  sSlaveConfig.TriggerPrescaler = TIM_ICPSC_DIV1;
+  sSlaveConfig.TriggerFilter = 0;
+  if (HAL_TIM_SlaveConfigSynchro(&htim5, &sSlaveConfig) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
+  sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
+  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
+  sConfigIC.ICFilter = 0;
+  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
+  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
+  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
+  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
+  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  /* USER CODE BEGIN TIM5_Init 2 */
+  /* USER CODE END TIM5_Init 2 */
 
-	/* USER CODE END TIM12_Init 2 */
 }
 
 /**
@@ -701,69 +637,95 @@ static void MX_GPIO_Init(void)
 	__HAL_RCC_GPIOD_CLK_ENABLE();
 
 	/*Configure GPIO pin Output Level */
-	HAL_GPIO_WritePin(GPIOE, ATX_PS_ON_Pin | DC_POWER_EN1_Pin, GPIO_PIN_RESET);
+	HAL_GPIO_WritePin(ATX_PS_ON_GPIO_Port, ATX_PS_ON_Pin, GPIO_PIN_RESET);
 
 	/*Configure GPIO pin Output Level */
-	HAL_GPIO_WritePin(MCU_PHY_RESETN_GPIO_Port, MCU_PHY_RESETN_Pin, GPIO_PIN_RESET);
+	HAL_GPIO_WritePin(GPIOA, SPI1_NSS_Pin, GPIO_PIN_SET);
+	HAL_GPIO_WritePin(GPIOA, JTAG_MUX_SEL_Pin | JTAG_MUX_EN_Pin, GPIO_PIN_RESET);
 
 	/*Configure GPIO pin Output Level */
-	HAL_GPIO_WritePin(UART_MUX_SEL_GPIO_Port, UART_MUX_SEL_Pin, GPIO_PIN_RESET);
+	HAL_GPIO_WritePin(GPIOB, EEPROM_WP_Pin, GPIO_PIN_SET);
+	HAL_GPIO_WritePin(GPIOB, UART_MUX_SEL_Pin, GPIO_PIN_RESET);
+	HAL_GPIO_WritePin(GPIOB, SPI2_NSS_Pin, GPIO_PIN_RESET);
 
 	/*Configure GPIO pin Output Level */
-	HAL_GPIO_WritePin(GPIOD, PWR_LED_Pin | DC_POWER_EN0_Pin | MCU_RESET_SOM_N_Pin, GPIO_PIN_RESET);
-	HAL_GPIO_WritePin(GPIOD, SLP_LED_Pin, GPIO_PIN_SET);
+	HAL_GPIO_WritePin(GPIOD, PWR_LED_Pin | SLP_LED_Pin | SOM_PMIC_ON_REQ_Pin | MCU_RESET_SOM_N_Pin, GPIO_PIN_RESET);
 
 	/*Configure GPIO pin Output Level */
-	HAL_GPIO_WritePin(EEPROM_WP_GPIO_Port, EEPROM_WP_Pin, GPIO_PIN_SET);
+	HAL_GPIO_WritePin(MCU_PHY_RESETN_GPIO_Port, MCU_PHY_RESETN_Pin, GPIO_PIN_RESET);
 
-	/*Configure GPIO pin Output Level */
-	HAL_GPIO_WritePin(GPIOD, BOOT_SEL0_Pin | BOOT_SEL1_Pin | BOOT_SEL2_Pin | BOOT_SEL3_Pin, GPIO_PIN_SET);
 
-	HAL_GPIO_WritePin(GPIOA, SPI1_NSS_Pin, GPIO_PIN_SET);
-	HAL_GPIO_WritePin(GPIOB, SPI2_NSS_Pin, GPIO_PIN_RESET);
+/* eth reset to 0*/
+	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_RESET);
 
-	/*Configure GPIO pins : ATX_PS_ON_Pin DC_POWER_EN1_Pin */
-	GPIO_InitStruct.Pin = ATX_PS_ON_Pin | DC_POWER_EN1_Pin;
+	GPIO_InitStruct.Pin = GPIO_PIN_0;
 	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 	GPIO_InitStruct.Pull = GPIO_NOPULL;
 	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
-	HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
+	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 
-	/*Configure GPIO pin : DCDC_PWR_OK_Pin */
-	GPIO_InitStruct.Pin = DCDC_PWR_OK_Pin;
-	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+	/*Configure GPIO pin : MCU_PHY_RESETN_Pin */
+	GPIO_InitStruct.Pin = MCU_PHY_RESETN_Pin;
+	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	HAL_GPIO_Init(DCDC_PWR_OK_GPIO_Port, &GPIO_InitStruct);
+	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
+	HAL_GPIO_Init(MCU_PHY_RESETN_GPIO_Port, &GPIO_InitStruct);
 
-	/*Configure GPIO pins : MCU_PHY_RESETN_Pin EEPROM_WP_Pin */
-	GPIO_InitStruct.Pin = MCU_PHY_RESETN_Pin | EEPROM_WP_Pin;
+	/*Configure GPIO pin : ATX_PS_ON_Pin */
+	GPIO_InitStruct.Pin = ATX_PS_ON_Pin;
 	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 	GPIO_InitStruct.Pull = GPIO_NOPULL;
 	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
-	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+	HAL_GPIO_Init(ATX_PS_ON_GPIO_Port, &GPIO_InitStruct);
 
-	/*Configure GPIO pin : I2C_MUX_EN_Pin */
-	GPIO_InitStruct.Pin = I2C_MUX_EN_Pin;
+	/*Configure GPIO pins : ATX_PWR_OK_Pin DCDC_PWR_OK_Pin CHASS_FAN_TACH1_Pin CHASS_FAN_TACH2_Pin */
+	GPIO_InitStruct.Pin = ATX_PWR_OK_Pin | DCDC_PWR_OK_Pin | CHASS_FAN_TACH1_Pin | CHASS_FAN_TACH2_Pin;
 	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	HAL_GPIO_Init(I2C_MUX_EN_GPIO_Port, &GPIO_InitStruct);
+	HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
+
+	/*Configure GPIO pin : SPI1_NSS_Pin */
+	GPIO_InitStruct.Pin = SPI1_NSS_Pin;
+	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
+	GPIO_InitStruct.Pull = GPIO_NOPULL;
+	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+	HAL_GPIO_Init(SPI1_NSS_GPIO_Port, &GPIO_InitStruct);
 
-	/*Configure GPIO pin : UART_MUX_SEL_Pin */
-	GPIO_InitStruct.Pin = UART_MUX_SEL_Pin;
+	/*Configure GPIO pins : EEPROM_WP_Pin UART_MUX_SEL_Pin */
+	GPIO_InitStruct.Pin = EEPROM_WP_Pin | UART_MUX_SEL_Pin;
 	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 	GPIO_InitStruct.Pull = GPIO_NOPULL;
 	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
-	HAL_GPIO_Init(UART_MUX_SEL_GPIO_Port, &GPIO_InitStruct);
+	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 
-	/*Configure GPIO pins : PWR_LED_Pin SLP_LED_Pin BOOT_SEL0_Pin BOOT_SEL1_Pin
-							BOOT_SEL2_Pin BOOT_SEL3_Pin DC_POWER_EN0_Pin MCU_RESET_SOM_N_Pin */
-	GPIO_InitStruct.Pin = PWR_LED_Pin | SLP_LED_Pin | BOOT_SEL0_Pin | BOOT_SEL1_Pin | BOOT_SEL2_Pin | BOOT_SEL3_Pin |
-						  DC_POWER_EN0_Pin | MCU_RESET_SOM_N_Pin;
+	/*Configure GPIO pins : PWR_LED_Pin SOM_PMIC_ON_REQ_Pin MCU_RESET_SOM_N_Pin */
+	GPIO_InitStruct.Pin = PWR_LED_Pin | SLP_LED_Pin | SOM_PMIC_ON_REQ_Pin | MCU_RESET_SOM_N_Pin;
 	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 	GPIO_InitStruct.Pull = GPIO_NOPULL;
 	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 
+	/*Configure GPIO pins : SLP_LED_Pin */
+	GPIO_InitStruct.Pin = SLP_LED_Pin;
+	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+	GPIO_InitStruct.Pull = GPIO_NOPULL;
+	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
+	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+
+	/*Configure GPIO pins : BOOT_SEL0_Pin BOOT_SEL1_Pin BOOT_SEL2_Pin BOOT_SEL3_Pin*/
+	GPIO_InitStruct.Pin = BOOT_SEL0_Pin | BOOT_SEL1_Pin | BOOT_SEL2_Pin | BOOT_SEL3_Pin;
+	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+	GPIO_InitStruct.Pull = GPIO_NOPULL;
+	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
+	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+
+	/*Configure GPIO pins : JTAG_MUX_SEL_Pin JTAG_MUX_EN_Pin */
+	GPIO_InitStruct.Pin = JTAG_MUX_SEL_Pin | JTAG_MUX_EN_Pin;
+	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
+	GPIO_InitStruct.Pull = GPIO_NOPULL;
+	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
+	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
+
 	/*Configure GPIO pin : PWR_SW_P_Pin */
 	GPIO_InitStruct.Pin = PWR_SW_P_Pin;
 	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
@@ -776,12 +738,6 @@ static void MX_GPIO_Init(void)
 	GPIO_InitStruct.Pull = GPIO_NOPULL;
 	HAL_GPIO_Init(SOM_RST_OUT_N_GPIO_Port, &GPIO_InitStruct);
 
-	/*Configure GPIO pin : KEY_USER_RST_Pin */
-	GPIO_InitStruct.Pin = KEY_USER_RST_Pin;
-	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
-	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	HAL_GPIO_Init(KEY_USER_RST_GPIO_Port, &GPIO_InitStruct);
-
 	/*Configure GPIO pin : SPI2_NSS_Pin */
 	GPIO_InitStruct.Pin = SPI2_NSS_Pin;
 	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
@@ -790,36 +746,35 @@ static void MX_GPIO_Init(void)
 	HAL_GPIO_Init(SPI2_NSS_GPIO_Port, &GPIO_InitStruct);
 
 	/*
-	PB6     ------> I2C1_SCL
-	PB7     ------> I2C1_SDA
+    PB6     ------> I2C1_SCL
+    PB7     ------> I2C1_SDA
+    */
 	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
-	GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
-	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
-	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
-	*/
-
-	/**I2C3 GPIO Configuration
-	PC9     ------> I2C3_SDA
-	PA8     ------> I2C3_SCL
-	*/
-	GPIO_InitStruct.Pin = GPIO_PIN_9;
-	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
-	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-
-	GPIO_InitStruct.Pin = GPIO_PIN_8;
-	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
-	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
+    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
+    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStruct.Pull = GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
+
+    /**I2C3 GPIO Configuration
+    PC9     ------> I2C3_SDA
+    PA8     ------> I2C3_SCL
+    */
+	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_9, GPIO_PIN_RESET);
+    GPIO_InitStruct.Pin = GPIO_PIN_9;
+    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStruct.Pull = GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_8, GPIO_PIN_RESET);
+    GPIO_InitStruct.Pin = GPIO_PIN_8;
+    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
+    GPIO_InitStruct.Pull = GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 
 	/* EXTI interrupt init*/
-	HAL_NVIC_SetPriority(EXTI1_IRQn, 5, 0);
-	HAL_NVIC_EnableIRQ(EXTI1_IRQn);
-
 	HAL_NVIC_SetPriority(EXTI9_5_IRQn, 5, 0);
 	HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 
diff --git a/Core/Src/hf_common.c b/Core/Src/hf_common.c
index ad52be9..6c2f912 100644
--- a/Core/Src/hf_common.c
+++ b/Core/Src/hf_common.c
@@ -26,7 +26,7 @@
 #define EEPROM_TEST_DEBUG 0
 #define SET_MAGIC_NUM_DEBUG 0
 
-#if 0
+#if 1
 #define esENTER_CRITICAL(MUTEX, DELAY)	xSemaphoreTake(MUTEX, DELAY)
 #define esEXIT_CRITICAL(MUTEX)		xSemaphoreGive(MUTEX)
 #else
@@ -40,7 +40,6 @@ static CarrierBoardInfo *pgCarrier_Board_Info = (CarrierBoardInfo *)gCbinfoArray
 static MCUServerInfo gMCU_Server_Info;
 static SomPwrMgtDIPInfo gSOM_PwgMgtDIP_Info;
 static SemaphoreHandle_t gEEPROM_Mutex;
-static uint32_t gMagicNumber = 0;
 
 /* function prototypes -----------------------------------------------*/
 #if EEPROM_TEST_DEBUG
@@ -258,13 +257,13 @@ static int restore_cbinfo_to_factory(uint32_t *pCbinfoArray)
 	pCarrier_Board_Info->ethernetMAC3[5] = MAC_ADDR5;
 
 	pCarrier_Board_Info->crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)pCbinfoArray, sizeof(CarrierBoardInfo)/4 - 1);
-
+#if 0
 	/* write to main partition */
 	write_cbinfo(pCarrier_Board_Info, cbinfo_main);
 
 	/* write to backup partition */
 	write_cbinfo(pCarrier_Board_Info, cbinfo_backup);
-
+#endif
 	esEXIT_CRITICAL(gEEPROM_Mutex);
 
 	return 0;
@@ -351,6 +350,7 @@ static int get_carrier_board_info(void)
 			write_cbinfo(pgCarrier_Board_Info, cbinfo_backup);
 		}
 	}
+
 	return 0;
 }
 
@@ -371,14 +371,14 @@ static int get_mcu_server_info(void)
 	}
 	eeprom_debug("print MCUServerInfo:\n");
 	print_data((uint8_t *)&gMCU_Server_Info, sizeof(MCUServerInfo));
-	if ((0 == strlen(gMCU_Server_Info.AdminName)) | (gMagicNumber != MAGIC_NUMBER)) {
+	if ((0 == strlen(gMCU_Server_Info.AdminName)) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		memset(gMCU_Server_Info.AdminName, 0, sizeof(gMCU_Server_Info.AdminName));
 		strcpy(gMCU_Server_Info.AdminName, DEFAULT_ADMIN_NAME);
 		eeprom_debug("No valid admin_name in EEPROM, set to %s!\n", gMCU_Server_Info.AdminName);
 	}
 
-	if ((0 == strlen(gMCU_Server_Info.AdminPassword)) | (gMagicNumber != MAGIC_NUMBER)) {
+	if ((0 == strlen(gMCU_Server_Info.AdminPassword)) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		memset(gMCU_Server_Info.AdminPassword, 0, sizeof(gMCU_Server_Info.AdminPassword));
 		strcpy(gMCU_Server_Info.AdminPassword, DEFAULT_ADMIN_PASSWORD);
@@ -387,7 +387,7 @@ static int get_mcu_server_info(void)
 		print_data((uint8_t *)&gMCU_Server_Info, sizeof(MCUServerInfo));
 	}
 
-	if ((0 == gMCU_Server_Info.ip_address[0]) | (gMagicNumber != MAGIC_NUMBER)) {
+	if ((0 == gMCU_Server_Info.ip_address[0]) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		gMCU_Server_Info.ip_address[0] = IP_ADDR0;
 		gMCU_Server_Info.ip_address[1] = IP_ADDR1;
@@ -397,7 +397,7 @@ static int get_mcu_server_info(void)
 	}
 
 	hlmask = ntohl_seq(gMCU_Server_Info.netmask_address);
-	if (!ip4_addr_netmask_valid(hlmask) | (gMagicNumber != MAGIC_NUMBER)) {
+	if (!ip4_addr_netmask_valid(hlmask) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		gMCU_Server_Info.netmask_address[0] = NETMASK_ADDR0;
 		gMCU_Server_Info.netmask_address[1] = NETMASK_ADDR1;
@@ -406,7 +406,7 @@ static int get_mcu_server_info(void)
 		eeprom_debug("No valid netmask in EEPROM, set to default!\n");
 	}
 
-	if ((0 == gMCU_Server_Info.gateway_address[0]) | (gMagicNumber != MAGIC_NUMBER)) {
+	if ((0 == gMCU_Server_Info.gateway_address[0]) || (pgCarrier_Board_Info->magicNumber != MAGIC_NUMBER)) {
 		skip_update_eeprom = 0;
 		gMCU_Server_Info.gateway_address[0] = GATEWAY_ADDR0;
 		gMCU_Server_Info.gateway_address[1] = GATEWAY_ADDR1;
@@ -575,20 +575,38 @@ int es_set_carrier_borad_info(CarrierBoardInfo *pCarrier_Board_Info)
 	return 0;
 }
 
-int es_get_mcu_mac(uint8_t *p_mac_address)
+int es_get_mcu_mac(uint8_t *p_mac_address, uint8_t index)
 {
 	if (NULL == p_mac_address)
 		return -1;
 
+	if (index > 2) {
+		printf("Invalid mac index!!! Should be within(0-2)\n");
+		return -1;
+	}
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
-	memcpy(p_mac_address, pgCarrier_Board_Info->ethernetMAC3, sizeof(pgCarrier_Board_Info->ethernetMAC3));
+	switch (index) {
+		case 0:
+			memcpy(p_mac_address, pgCarrier_Board_Info->ethernetMAC1, sizeof(pgCarrier_Board_Info->ethernetMAC1));
+			break;
+		case 1:
+			memcpy(p_mac_address, pgCarrier_Board_Info->ethernetMAC2, sizeof(pgCarrier_Board_Info->ethernetMAC2));
+			break;
+		case 2:
+			memcpy(p_mac_address, pgCarrier_Board_Info->ethernetMAC3, sizeof(pgCarrier_Board_Info->ethernetMAC3));
+			break;
+		default:
+			break;
+	}
 	esEXIT_CRITICAL(gEEPROM_Mutex);
 
 	return 0;
 }
 
-int es_set_mcu_mac(uint8_t *p_mac_address)
+int es_set_mcu_mac(uint8_t *p_mac_address, uint8_t index)
 {
+	int update_mac = 0;
+
 	if (NULL == p_mac_address)
 		return -1;
 
@@ -596,9 +614,41 @@ int es_set_mcu_mac(uint8_t *p_mac_address)
 		return -1;
 	}
 
+	if (index > 2) {
+		printf("Invalid mac index!!! Should be within(0-2)\n");
+		return -1;
+	}
+
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
-	if (0 != memcmp(pgCarrier_Board_Info->ethernetMAC3, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC3))) {
-		memcpy(pgCarrier_Board_Info->ethernetMAC3, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC3));
+	switch (index) {
+		case 0:
+			if (0 != memcmp(pgCarrier_Board_Info->ethernetMAC1, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC1))) {
+				memcpy(pgCarrier_Board_Info->ethernetMAC1, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC1));
+				update_mac = 1;
+			}
+			break;
+		case 1:
+		{
+			if (0 != memcmp(pgCarrier_Board_Info->ethernetMAC2, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC2))) {
+				memcpy(pgCarrier_Board_Info->ethernetMAC2, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC2));
+				update_mac = 1;
+			}
+			break;
+		}
+		case 2:
+		{
+			if (0 != memcmp(pgCarrier_Board_Info->ethernetMAC3, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC3))) {
+				memcpy(pgCarrier_Board_Info->ethernetMAC3, p_mac_address, sizeof(pgCarrier_Board_Info->ethernetMAC3));
+				update_mac = 1;
+			}
+			break;
+		}
+		default:
+			break;
+	}
+	if (update_mac) {
+		pgCarrier_Board_Info->crc32Checksum = HAL_CRC_Calculate(&hcrc, (uint32_t *)gCbinfoArray, sizeof(CarrierBoardInfo)/4 - 1);
+
 		hf_i2c_mem_write(&hi2c1, AT24C_ADDR, CARRIER_BOARD_INFO_EEPROM_MAIN_OFFSET,
 					(uint8_t *)pgCarrier_Board_Info, sizeof(CarrierBoardInfo));
 
@@ -1044,13 +1094,13 @@ int es_eeprom_info_test(void)
 	eeprom_debug("Get admin_name:%s, admin_password:%s\n", admin_name, admin_password);
 
 	/* mac test */
-	es_get_mcu_mac(mac);
+	es_get_mcu_mac(mac, MCU_MAC_IDX);
 	eeprom_debug("Get mac:%x:%x:%x:%x:%x:%x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 
 	mac[0] = 0xde; // original MAC_ADDR0 0x94U
-	es_set_mcu_mac(mac);
+	es_set_mcu_mac(mac, MCU_MAC_IDX);
 	eeprom_debug("Set mac:%x:%x:%x:%x:%x:%x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
-	es_get_mcu_mac(mac);
+	es_get_mcu_mac(mac, MCU_MAC_IDX);
 	eeprom_debug("Get mac:%x:%x:%x:%x:%x:%x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 
 	/* ipaddr test */
@@ -1334,33 +1384,6 @@ uint32_t es_autoboot(void)
 	return 0;
 }
 
-void set_mcu_led_status(led_status_t type)
-{
-	if( LED_MCU_RUNING == type) {
-		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
-		HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);
-		HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);
-	}
-	else if( LED_SOM_BOOTING == type) {
-		HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
-		HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);
-	}
-	else if( LED_SOM_KERNEL_RUNING == type)
-	{
-		if(HAL_TIM_CHANNEL_STATE_BUSY == HAL_TIM_GetChannelState(&htim1, TIM_CHANNEL_2))
-		{
-			// HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);
-			HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);
-			HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
-		} else {
-			if(HAL_TIM_CHANNEL_STATE_BUSY == HAL_TIM_GetChannelState(&htim1, TIM_CHANNEL_3))
-				HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);
-			else
-				HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
-		}
-	}
-}
-
 int es_restore_userdata_to_factory(void)
 {
 	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
diff --git a/Core/Src/hf_gpio_process.c b/Core/Src/hf_gpio_process.c
index a970395..5d79a1e 100644
--- a/Core/Src/hf_gpio_process.c
+++ b/Core/Src/hf_gpio_process.c
@@ -10,15 +10,14 @@
 
 /* Private define ------------------------------------------------------------*/
 #define SHORT_CLICK_THRESHOLD 50
-#define LONG_PRESS_THRESHOLD 4000
+#define LONG_PRESS_THRESHOLD 3000
 #define PRESS_Time 50
 #define BUTTON_ERROR_Time 10000
 
-#define FLAGS_KEY			0x00000001U
-#define FLAGS_SOM_RST_OUT	0x00000010U
-#define FLAGS_MCU_RESET_SOM	0x00000100U
-#define FLAGS_KEY_USER_RST	0x00001000U
-#define FLAGS_ALL			0x00000FFFU
+#define FLAGS_KEY 0x00000001U
+#define FLAGS_SOM_RST_OUT 0x00000010U
+#define FLAGS_MCU_RESET_SOM 0x00000100U
+#define FLAGS_ALL 0x00000FFFU
 
 #define KEY_PUSHDOWN GPIO_PIN_RESET
 #define KEY_RELEASE GPIO_PIN_SET
@@ -46,8 +45,6 @@ void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
 	} else if (MCU_RESET_SOM_N_Pin == GPIO_Pin) {
 		// printf("MCU_RESET_SOM_N_Pin it   som key reset\n");
 		osEventFlagsSet(gpio_eventflags_id, FLAGS_MCU_RESET_SOM);
-	} else if (KEY_USER_RST_Pin == GPIO_Pin) {
-		osEventFlagsSet(gpio_eventflags_id, FLAGS_KEY_USER_RST);
 	}
 }
 
@@ -158,49 +155,6 @@ static void som_rst_feedback_process(void)
 	som_reset_control(pdFALSE);
 }
 
-#define USER_RST_THRESHOLD 10000
-static void key_user_rst_process(void)
-{
-	uint8_t key_status = KEY_PUSHDOWN;
-	button_state_t button_state = KEY_IDLE_STATE;
-	TickType_t pressStartTime = 0;
-	TickType_t currentTime = 0;
-	int ret = 0;
-
-	while (key_status == KEY_PUSHDOWN) {
-		currentTime = xTaskGetTickCount();
-		switch (button_state) {
-		case KEY_IDLE_STATE:
-			button_state = KEY_PRESS_DETECTED_STATE;
-			pressStartTime = currentTime;
-			break;
-		case KEY_PRESS_DETECTED_STATE:
-			if (get_key_status() == KEY_RELEASE) {
-				button_state = KEY_RELEASE_DETECTED_STATE;
-			} else if((currentTime - pressStartTime) > USER_RST_THRESHOLD) {
-				button_state = KEY_RELEASE_DETECTED_STATE;
-			}
-			break;
-		case KEY_RELEASE_DETECTED_STATE:
-			if((currentTime - pressStartTime) >= USER_RST_THRESHOLD)
-			{
-				// TODO : user reset function
-				es_restore_userdata_to_factory();
-			}
-			button_state = KEY_PRESS_STATE_END;
-			break;
-		case KEY_PRESS_STATE_END:
-			if (get_key_status() == KEY_RELEASE) {
-				// printf("sw IDLE_STATE\n");
-				key_status = KEY_RELEASE;
-				button_state = IDLE_STATE;
-			}
-			break;
-		}
-		osDelay(1);
-	}
-}
-
 void hf_gpio_task(void *parameter)
 {
 	int flags = 0;
@@ -215,8 +169,6 @@ void hf_gpio_task(void *parameter)
 				som_rst_feedback_process();
 			if (FLAGS_MCU_RESET_SOM & flags)
 				mcu_reset_som_process();
-			if (FLAGS_KEY_USER_RST & flags)
-				key_user_rst_process();
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/Core/Src/hf_http_process.c b/Core/Src/hf_http_process.c
index 46496a2..e5736b1 100644
--- a/Core/Src/hf_http_process.c
+++ b/Core/Src/hf_http_process.c
@@ -21,7 +21,7 @@ void eth_get_address(void)
 
   es_get_mcu_netmask(netmask_address);
 
-  es_get_mcu_mac(mac_address);
+  es_get_mcu_mac(mac_address, MCU_MAC_IDX);
 }
 
 extern struct netif gnetif;
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index 2c559fe..7b2f450 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -7,28 +7,76 @@
 /* Private includes ----------------------------------------------------------*/
 #include "hf_common.h"
 #include "hf_i2c.h"
-#include "hf_power_process.h"
 #include "hf_spi_slv.h"
-
+#include "hf_power_process.h"
 /* Private typedef -----------------------------------------------------------*/
 // #define AUTO_BOOT
+#define POWER_TESET_MODE
 /* Private define ------------------------------------------------------------*/
+#define ATX_POWER_GOOD GPIO_PIN_RESET
+#define ATX_POWER_FAIL GPIO_PIN_SET
+
 #define DC_POWER_GOOD GPIO_PIN_SET
 #define DC_POWER_FAIL GPIO_PIN_RESET
 
 /* Private macro -------------------------------------------------------------*/
+#define PCA9450_ADDR (0x25u << 1)
+#define INA226_12V_ADDR (0X44U << 1)
+#define PAC1934_ADDR (0X10U << 1)
+
+#define INA2XX_CONFIG 0x00
+#define INA2XX_SHUNT_VOLTAGE 0x01 /* readonly */
+#define INA2XX_BUS_VOLTAGE 0x02	  /* readonly */
+#define INA2XX_POWER 0x03		  /* readonly */
+#define INA2XX_CURRENT 0x04		  /* readonly */
+#define INA2XX_CALIBRATION 0x05
+
+#define INA226_BUS_LSB 1250 /*uV*/
+
+#define INA226_SHUNT_RESISTOR 1000							 /*uOhm*/
+#define INA226_CURRENT_LSB (2500000 / INA226_SHUNT_RESISTOR) /*uA */
+#define INA226_POWER_LSB_FACTOR 25
+
+#define PAC193X_CMD_CTRL 0x1
+#define PAC193X_CMD_VBUS1 0x7
+#define PAC193X_CMD_VSENSE1 0xb
+#define PAC193X_CMD_VPOWER1 0x17
+#define PAC193X_CMD_REFRESH_V 0x1F
+#define PAC193X_CMD_NEG_PWR_ACT 0x23
+#define PAC193X_COSTANT_PWR_M 3200000000ull /* 3.2V^2*1000mO*/
+#define PAC193X_COSTANT_CURRENT_M 100000	/* 100mv*1000mO*/
+#define PAC193X_SHUNT_RESISTOR_M 4			/* mO*/
+
+#define DIV_ROUND_CLOSEST(x, divisor) (        \
+	{                                          \
+		typeof(x) __x = x;                     \
+		typeof(divisor) __d = divisor;         \
+		(((typeof(x))-1) > 0 ||                \
+		 ((typeof(divisor))-1) > 0 ||          \
+		 (((__x) > 0) == ((__d) > 0)))         \
+			? (((__x) + ((__d) / 2)) / (__d))  \
+			: (((__x) - ((__d) / 2)) / (__d)); \
+	})
+#define SWAP16(w) ((((w) & 0xff) << 8) | (((w) & 0xff00) >> 8))
+#define SWAP32(w) ((((w) & 0xff) << 24) | (((w) & 0xff00) << 8) | (((w) & 0xff0000) >> 8) | (((w) & 0xff000000) >> 24))
+
 /* Private variables ---------------------------------------------------------*/
 volatile power_switch_t som_power_state = SOM_POWER_OFF;
 
 static uint8_t get_dc_power_status(void);
+static void pmic_status_led_on(uint8_t turnon);
+static uint8_t get_atx_power_status(void);
+static void pmic_power_on(uint8_t turnon);
 static void atx_power_on(uint8_t turnon);
-static void dc_power_on(uint8_t turnon);
-static void chass_led_ctl(uint8_t turnon);
-void set_power_off(void);
+static void power_led_on(uint8_t turnon);
+static int pmic_b6out_105v(void);
 power_switch_t get_som_power_state(void);
+void set_power_off(void);
 
-#define MAXTRYCOUNT 10
+// #define MAXTRYCOUNT		10
+#define MAXTRYCOUNT		40
 int try_count = 0;
+#ifndef POWER_TESET_MODE
 void hf_power_task(void *parameter)
 {
 	HAL_StatusTypeDef status = HAL_OK;
@@ -38,43 +86,60 @@ void hf_power_task(void *parameter)
 #ifdef AUTO_BOOT
 	change_som_power_state(SOM_POWER_ON);
 #endif
-	init_bootsel();
-
-	if(es_autoboot())
-		change_som_power_state(SOM_POWER_ON);
-	else
-		change_som_power_state(SOM_POWER_OFF);
+	power_led_on(pdFALSE);
 	while (1) {
 		switch (power_state) {
 		case ATX_PS_ON_STATE:
-			printf("ATX_PS_ON\r\n");
+			printf("ATX_PS_ON_STATE\r\n");
 			atx_power_on(pdTRUE);
-			power_state = DC_PWR_ON_STATE;
-			break;
-		case DC_PWR_ON_STATE:
-			printf("DC_PWR_ON\r\n");
-			dc_power_on(pdTRUE);
 			power_state = DC_PWR_GOOD_STATE;
+			break;
 		case DC_PWR_GOOD_STATE:
 			printf("DC_PWR_GOOD_STATE\r\n");
 			try_count = MAXTRYCOUNT;
-			do {
-				osDelay(200);
+			do
+			{
 				pin_state = get_dc_power_status();
+				osDelay(100);
 			} while (pin_state != pdTRUE && try_count--);
-			if (try_count <= 0) {
+
+			if(try_count <= 0)
+			{
 				printf("DC_PWR_STATE fail\r\n");
-				change_som_power_state(SOM_POWER_OFF);
 				power_state = STOP_POWER;
-			} else
+			}
+			if (pin_state == pdTRUE) {
+				i2c_init(I2C3);
+				i2c_init(I2C1); // dvb v2 move to board init
 				power_state = SOM_STATUS_CHECK_STATE;
+			}
 			break;
 		case SOM_STATUS_CHECK_STATE:
 			printf("SOM_STATUS_CHECK_STATE\r\n");
+			pmic_power_on(pdTRUE);
+			try_count = MAXTRYCOUNT;
+			do
+			{
+				osDelay(200);
+				status = pmic_b6out_105v();
+				osDelay(50);
+				printf("pmic_b6out_105v status %x\r\n",status);
+			}while(status != pdTRUE && try_count--);
+			if(try_count <= 0)
+			{
+				printf("SOM_STATUS_CHECK_STATE fail\r\n");
+				power_state = STOP_POWER;
+				break;
+			}
 			som_reset_control(pdFALSE);
+			SPI2_FLASH_CS_HIGH();
+			pmic_status_led_on(pdTRUE);
+			power_led_on(pdTRUE);
 			power_state = POWERON;
 			printf("POWERON\r\n");
 			break;
+		case RESET_SOM:
+			break;
 		case POWERON:
 			if (get_som_power_state() == SOM_POWER_OFF) {
 				power_state = STOP_POWER;
@@ -94,19 +159,111 @@ void hf_power_task(void *parameter)
 		osDelay(100);
 	}
 }
+#else
+void hf_power_task(void *parameter)
+{
+	power_state_t power_state = IDLE_STATE;
+
+	printf("hf_power_task started!!!\r\n");
+	osDelay(1000);
+
+	/* init bootsel according to the switch attr in eepprom */
+	init_bootsel();
+
+	if(es_autoboot())
+		change_som_power_state(SOM_POWER_ON);
+	else
+		change_som_power_state(SOM_POWER_OFF);
+
+#ifdef AUTO_BOOT
+	change_som_power_state(SOM_POWER_ON);
+#endif
+	power_led_on(pdFALSE);
+	while (1) {
+		taskENTER_CRITICAL();
+		switch (power_state) {
+		case ATX_PS_ON_STATE:
+			printf("ATX_PS_ON_STATE\r\n");
+			power_state = DC_PWR_GOOD_STATE;
+			break;
+		case DC_PWR_GOOD_STATE:
+			printf("DC_PWR_GOOD_STATE\r\n");
+			power_state = SOM_STATUS_CHECK_STATE;
+			break;
+		case SOM_STATUS_CHECK_STATE:
+			printf("SOM_STATUS_CHECK_STATE\r\n");
+			som_reset_control(pdFALSE);
+			pmic_status_led_on(pdTRUE);
+			power_led_on(pdTRUE);
+			power_state = POWERON;
+			printf("POWERON\r\n");
+			break;
+		case RESET_SOM:
+			break;
+		case POWERON:
+			if (get_som_power_state() == SOM_POWER_OFF) {
+				power_state = STOP_POWER;
+			}
+			break;
+		case STOP_POWER:
+			printf("STOP_POWER\r\n");
+			set_power_off();
+			power_state = IDLE_STATE;
+			break;
+		case IDLE_STATE:
+			if (get_som_power_state() == SOM_POWER_ON) {
+				power_state = ATX_PS_ON_STATE;
+			}
+			break;
+		}
+		taskEXIT_CRITICAL();
+		osDelay(100);
+	}
+}
+#endif
+
+void power_test_dome(void)
+{
+#ifdef POWER_TESET_MODE
+	HAL_StatusTypeDef status = HAL_OK;
+	uint8_t pin_state = 0;
+	printf("atx_power_on\r\n");
+	atx_power_on(pdTRUE);
+	do
+	{
+		pin_state = get_dc_power_status();
+		osDelay(100);
+	} while (pin_state != pdTRUE);
+	printf("dc_power good\r\n");
+	osDelay(100);
+	i2c_init(I2C3);
+	pmic_power_on(pdTRUE);
+	do
+	{
+		osDelay(200);
+		status = pmic_b6out_105v();
+		osDelay(50);
+	}while(status != pdTRUE);
+	i2c_init(I2C1);
+#endif
+}
 
 void set_power_off(void)
 {
+	i2c_deinit(I2C3);
 	som_reset_control(pdTRUE);
-	osDelay(10);
-	dc_power_on(pdFALSE);
+#ifndef POWER_TESET_MODE
+	i2c_deinit(I2C1); // dvb v2 move to board init
+	pmic_power_on(pdFALSE);
 	osDelay(10);
 	atx_power_on(pdFALSE);
 	osDelay(10);
-	set_mcu_led_status(LED_MCU_RUNING);
-	chass_led_ctl(pdFALSE);
+#endif
+	pmic_status_led_on(pdFALSE);
+	power_led_on(pdFALSE);
 }
 
+
 /**
  * @brief  atx power switch .
  * @param  turnon turn on/off atx power 1:turnon; 0:turnoff.
@@ -120,16 +277,32 @@ static void atx_power_on(uint8_t turnon)
 		HAL_GPIO_WritePin(ATX_PS_ON_GPIO_Port, ATX_PS_ON_Pin, GPIO_PIN_RESET);
 }
 
-static void dc_power_on(uint8_t turnon)
+/**
+ * @brief  pmic power switch.
+ * @param  turnon turn on/off pmic power 1:turnon; 0:turnoff.
+ * @retval None
+ */
+static void pmic_power_on(uint8_t turnon)
 {
-	if (turnon) {
-		HAL_GPIO_WritePin(DC_POWER_EN0_GPIO_Port, DC_POWER_EN0_Pin, GPIO_PIN_SET);
-		// HAL_GPIO_WritePin(DC_POWER_EN1_GPIO_Port, DC_POWER_EN1_Pin, GPIO_PIN_SET);
-	} else {
-		HAL_GPIO_WritePin(DC_POWER_EN0_GPIO_Port, DC_POWER_EN0_Pin, GPIO_PIN_RESET);
-		// HAL_GPIO_WritePin(DC_POWER_EN1_GPIO_Port, DC_POWER_EN1_Pin, GPIO_PIN_RESET);
-	}
+	if (turnon)
+		HAL_GPIO_WritePin(SOM_PMIC_ON_REQ_GPIO_Port, SOM_PMIC_ON_REQ_Pin, GPIO_PIN_SET);
+	else
+		HAL_GPIO_WritePin(SOM_PMIC_ON_REQ_GPIO_Port, SOM_PMIC_ON_REQ_Pin, GPIO_PIN_RESET);
 }
+
+/**
+ * @brief  pmic power switch.
+ * @param  None
+ * @retval uint8_t atx power status. pdTRUE : atx power on; pdFALSE : atx power off
+ */
+static uint8_t get_atx_power_status(void)
+{
+	if (ATX_POWER_GOOD == HAL_GPIO_ReadPin(ATX_PWR_OK_GPIO_Port, ATX_PWR_OK_Pin))
+		return pdTRUE;
+	else
+		return pdFALSE;
+}
+
 /**
  * @brief  dcdc power switch.
  * @param  None
@@ -143,6 +316,22 @@ static uint8_t get_dc_power_status(void)
 		return pdFALSE;
 }
 
+/**
+ * @brief  pmic status led switch.
+ * @param  turnon pmic status led on/off; pdTRUE : led on; pdFALSE : led off
+ * @retval None
+ */
+static void pmic_status_led_on(uint8_t turnon)
+{
+	if (turnon) {
+		if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3) != HAL_OK)
+			printf("HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_3) err\n");
+	} else {
+		if (HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_3) != HAL_OK)
+			printf("HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_3) err\n");
+	}
+}
+
 /**
  * @brief  mcu reset som control.
  * @param  reset pdTRUE : reset; pdFALSE : release
@@ -160,16 +349,19 @@ void som_reset_control(uint8_t reset)
 		GPIO_InitStruct.Pull = GPIO_NOPULL;
 		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 		HAL_GPIO_Init(MCU_RESET_SOM_N_GPIO_Port, &GPIO_InitStruct);
+		i2c_deinit(I2C3);
 		uart_deinit(UART4);
 		uart_deinit(USART6);
-		SPI2_MASTER_CS_LOW();
-		set_bootsel(0, 0);
+		SPI2_FLASH_CS_LOW();
+		// set_bootsel(0, 0);
 	} else {
-	// 	GPIO_InitStruct.Pin = BOOT_SEL0_Pin | BOOT_SEL1_Pin | BOOT_SEL2_Pin | BOOT_SEL3_Pin;
-	// 	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
-	// 	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	// 	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
-	// 	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+		/*
+		if(!es_get_som_dip_switch_soft_ctl_attr(&dip_switch_soft_ctl_attr) && !es_get_som_dip_switch_soft_state(&dip_switch_soft_state))
+			if(dip_switch_soft_ctl_attr == 1)
+				set_bootsel(1, dip_switch_soft_state);
+			else
+				set_bootsel(0, 0);
+		*/
 		HAL_GPIO_WritePin(MCU_RESET_SOM_N_GPIO_Port, MCU_RESET_SOM_N_Pin, GPIO_PIN_SET);
 		GPIO_InitStruct.Pin = MCU_RESET_SOM_N_Pin;
 		GPIO_InitStruct.Pull = GPIO_NOPULL;
@@ -178,14 +370,13 @@ void som_reset_control(uint8_t reset)
 		HAL_GPIO_Init(MCU_RESET_SOM_N_GPIO_Port, &GPIO_InitStruct);
 		uart_init(UART4);
 		uart_init(USART6);
-		SPI2_MASTER_CS_HIGH();
-		set_mcu_led_status(LED_SOM_BOOTING);
-		chass_led_ctl(pdTRUE);
+		i2c_init(I2C3);
+		SPI2_FLASH_CS_HIGH();
 	}
 }
 
 /**
- * @brief  chass power led control.
+ * @brief  power led control.
  * @param  turnon pdTRUE : power led on; pdFALSE : power led off
  * @retval None
  */
@@ -199,30 +390,192 @@ static void power_led_on(uint8_t turnon)
 }
 
 /**
- * @brief  chass power led control.
- * @param  turnon pdTRUE : power led on; pdFALSE : power led off
- * @retval None
+ * @brief  set pmic buck6 output voltage to 1.05v.
+ * @param  None
+ * @retval int
  */
-static void sleep_led_on(uint8_t turnon)
+static int pmic_b6out_105v(void)
 {
-	if (turnon) {
-		HAL_GPIO_WritePin(SLP_LED_GPIO_Port, SLP_LED_Pin, GPIO_PIN_SET);
-	} else {
-		HAL_GPIO_WritePin(SLP_LED_GPIO_Port, SLP_LED_Pin, GPIO_PIN_RESET);
+	uint8_t reg_add = 0x1e, reg_dat = 0x12, read_dat;
+	hf_i2c_reg_write(&hi2c3, PCA9450_ADDR, reg_add, &reg_dat);
+	hf_i2c_reg_read(&hi2c3, PCA9450_ADDR, reg_add, &read_dat);
+	return reg_dat == read_dat ? 1 : 0;
+}
+
+static int ina226_init(void)
+{
+	uint16_t default_cfg = SWAP16(0x4527);
+	uint16_t calibration_value = SWAP16(2048);
+	int ret = 0;
+
+	ret = hf_i2c_reg_write_block(&hi2c3, INA226_12V_ADDR, INA2XX_CONFIG, (uint8_t *)&default_cfg, 2);
+	if (ret)
+	{
+		printf("init ina226 error1\n");
+		return -1;
+	}
+	ret = hf_i2c_reg_write_block(&hi2c3, INA226_12V_ADDR, INA2XX_CALIBRATION, (uint8_t *)&calibration_value, 2);
+	if (ret)
+	{
+		printf("init ina226 error2\n");
+		return -1;
 	}
+
+	return 0;
 }
 
-static void chass_led_ctl(uint8_t turnon)
+int get_board_power(uint32_t *volt, uint32_t *curr, uint32_t *power)
 {
-	if (turnon) {
-		sleep_led_on(!turnon);
-		osDelay(10);
-		power_led_on(turnon);
-	} else {
-		power_led_on(!turnon);
-		osDelay(10);
-		sleep_led_on(turnon);
+	uint32_t reg_bus = 0x0;
+	uint32_t reg_power = 0x0;
+	uint32_t reg_curr = 0x0;
+	int ret = 0;
+	static int is_first = 1;
+	struct rtc_time_t time = {0};
+
+	es_get_rtc_time(&time);
+
+	taskENTER_CRITICAL();
+	if (1 == is_first)
+	{
+		/*Write failure, not find wrong reason*/
+		ret = ina226_init();
+		if (ret)
+		{
+			ret = -1;
+			goto out;
+		}
+		is_first = 0;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_BUS_VOLTAGE, (uint8_t *)&reg_bus, 2);
+	if (ret)
+	{
+		printf("get board volt error(%02u:%02u:%02u CST)\n", time.Hours, time.Minutes, time.Seconds);
+		ret = -1;
+		goto out;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_POWER, (uint8_t *)&reg_power, 2);
+	if (ret)
+	{
+		printf("get board power error(%02u:%02u:%02u CST)\n", time.Hours, time.Minutes, time.Seconds);
+		ret = -1;
+		goto out;
 	}
+	ret = hf_i2c_reg_read_block(&hi2c3, INA226_12V_ADDR, INA2XX_CURRENT, (uint8_t *)&reg_curr, 2);
+	if (ret)
+	{
+		printf("get board current error(%02u:%02u:%02u CST)\n", time.Hours, time.Minutes, time.Seconds);
+		ret = -1;
+		goto out;
+	}
+	reg_bus = SWAP16(reg_bus);
+	reg_curr = SWAP16(reg_curr);
+	reg_power = SWAP16(reg_power);
+
+	*volt = reg_bus * INA226_BUS_LSB;
+	*volt = DIV_ROUND_CLOSEST(*volt, 1000);
+
+	*power = reg_power * INA226_CURRENT_LSB * INA226_POWER_LSB_FACTOR;
+	*curr = reg_curr * INA226_CURRENT_LSB;
+	*curr = DIV_ROUND_CLOSEST(*curr, 1000);
+
+out:
+	taskEXIT_CRITICAL();
+	return ret;
+}
+
+
+int get_som_power(uint32_t *volt, uint32_t *curr, uint32_t *power)
+{
+	uint32_t reg_bus = 0x0;
+	uint32_t reg_power = 0x0;
+	uint32_t reg_curr = 0x0;
+	int ret = 0;
+	static int is_first = 1;
+	uint8_t act_val = 0;
+	uint8_t is_neg = 0;
+	uint8_t ctrl_value = 0x8;
+
+	taskENTER_CRITICAL();
+	if (1 == is_first)
+	{
+		/*Write failure, not find wrong reason*/
+		hf_i2c_reg_write(&hi2c3, PAC1934_ADDR, PAC193X_CMD_CTRL, &ctrl_value);
+
+		if (ret)
+		{
+			ret = -1;
+			goto out;
+		}
+		is_first = 0;
+	}
+
+	hf_i2c_reg_write_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_REFRESH_V, (uint8_t *)&ctrl_value, 0);
+	osDelay(1);
+	ret = hf_i2c_reg_read(&hi2c3, PAC1934_ADDR, PAC193X_CMD_NEG_PWR_ACT, &act_val);
+	if (ret)
+	{
+		printf("get PAC1934 act_val error\n");
+		ret = -1;
+		goto out;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VBUS1, (uint8_t *)&reg_bus, 2);
+	if (ret)
+	{
+		printf("get PAC1934 voltage error\n");
+		ret = -1;
+		goto out;
+	}
+	reg_bus = reg_bus & 0XFFFF;
+	reg_bus = SWAP16(reg_bus);
+	if (0x1 == ((act_val >> 3) & 0x1))
+	{
+		*volt = reg_bus * 1000 / 1024;
+		is_neg = 1;
+	}
+	else
+	{
+		*volt = reg_bus * 1000 / 2048;
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VSENSE1, (uint8_t *)&reg_curr, 2);
+	reg_curr = SWAP16(reg_curr);
+	if (ret)
+	{
+		printf("get PAC1934 current error\n");
+		ret = -1;
+		goto out;
+	}
+	reg_curr = reg_curr & 0XFFFF;
+	if (0x1 == ((act_val >> 7) & 0x1))
+	{
+		*curr = reg_curr * PAC193X_COSTANT_CURRENT_M / (32768 * PAC193X_SHUNT_RESISTOR_M);
+		is_neg = 1;
+	}
+	else
+	{
+		*curr = reg_curr * PAC193X_COSTANT_CURRENT_M / (65536 * PAC193X_SHUNT_RESISTOR_M);
+	}
+	ret = hf_i2c_reg_read_block(&hi2c3, PAC1934_ADDR, PAC193X_CMD_VPOWER1, (uint8_t *)&reg_power, 4);
+	reg_power = SWAP32(reg_power);
+	if (ret)
+	{
+		printf("get PAC1934 power error\n");
+		ret = -1;
+		goto out;
+	}
+	reg_power = reg_power >> 4;
+	if (1 == is_neg)
+	{
+		*power = reg_power * PAC193X_COSTANT_PWR_M / (PAC193X_SHUNT_RESISTOR_M * 134217728ULL);
+	}
+	else
+	{
+		*power = reg_power * PAC193X_COSTANT_PWR_M / (PAC193X_SHUNT_RESISTOR_M * 268435456ULL);
+	}
+
+out:
+	taskEXIT_CRITICAL();
+	return ret;
 }
 
 power_switch_t get_som_power_state(void)
diff --git a/Core/Src/hf_protocol_process.c b/Core/Src/hf_protocol_process.c
index 95c5a5c..5c9ca03 100644
--- a/Core/Src/hf_protocol_process.c
+++ b/Core/Src/hf_protocol_process.c
@@ -624,8 +624,7 @@ void deamon_keeplive_task(void *argument)
 				change_som_daemon_state(SOM_DAEMON_OFF);
 			}
 		} else {
-			change_som_daemon_state(SOM_DAEMON_ON);
-			set_mcu_led_status(LED_SOM_KERNEL_RUNING);
+			change_som_daemon_state(SOM_DAEMON_ON);;
 			count = 0;
 		}
 		if (old_status != get_som_daemon_state()) {
diff --git a/Core/Src/hf_spi_slv.c b/Core/Src/hf_spi_slv.c
index c5dac15..12e1d24 100644
--- a/Core/Src/hf_spi_slv.c
+++ b/Core/Src/hf_spi_slv.c
@@ -8,31 +8,31 @@ uint32_t get_regval(uint8_t reg);
 HAL_StatusTypeDef spi_transmit(uint8_t *pData, uint16_t Size)
 {
 	HAL_StatusTypeDef ret;
-	SPI2_MASTER_CS_LOW();
+	SPI2_FLASH_CS_LOW();
 	ret = HAL_SPI_Transmit(&hspi2, pData, Size, 0xff);
-	SPI2_MASTER_CS_HIGH();
+	SPI2_FLASH_CS_HIGH();
 	return ret;
 }
 
 HAL_StatusTypeDef spi_transmit_recive(uint8_t *pSndData, uint16_t SndSize, uint8_t *pRcvData, uint16_t RcvSize)
 {
 	HAL_StatusTypeDef ret;
-	SPI2_MASTER_CS_LOW();
+	SPI2_FLASH_CS_LOW();
 	ret = HAL_SPI_Transmit(&hspi2, pSndData, SndSize, 0xff);
 	if (ret != HAL_OK) {
 		return ret;
 	}
 	ret = HAL_SPI_Receive(&hspi2, pRcvData, RcvSize, 0xff);
-	SPI2_MASTER_CS_HIGH();
+	SPI2_FLASH_CS_HIGH();
 	return ret;
 }
 
 HAL_StatusTypeDef spi_recive(uint8_t *pData, uint16_t Size)
 {
 	HAL_StatusTypeDef ret;
-	SPI2_MASTER_CS_LOW();
+	SPI2_FLASH_CS_LOW();
 	ret = HAL_SPI_Receive(&hspi2, pData, Size, 0xff);
-	SPI2_MASTER_CS_HIGH();
+	SPI2_FLASH_CS_HIGH();
 	return ret;
 }
 void spi_addr_cfg(uint8_t *cmd, uint64_t addr)
diff --git a/Core/Src/main.c b/Core/Src/main.c
index fb863ac..60456e4 100644
--- a/Core/Src/main.c
+++ b/Core/Src/main.c
@@ -124,6 +124,13 @@ int main(void)
 
   }
 }
+static void mcu_status_led_on(uint8_t turnon)
+{
+  if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_4) != HAL_OK) {
+    printf("HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_4) err\n");
+    Error_Handler();
+  }
+}
 /**
   * @brief  Function implementing the defaultTask thread.
   * @param  argument: Not used
@@ -135,6 +142,9 @@ extern void hf_gpio_task (void* parameter);
 void hf_main_task(void *argument)
 {
   printf("HiFive 106SC!\n");
+  extern void power_test_dome(void);
+  mcu_status_led_on(pdTRUE);
+  power_test_dome();
 
   /* get board info from eeprom where the MAC is stored */
   if(es_init_info_in_eeprom()) {
@@ -159,7 +169,7 @@ void hf_main_task(void *argument)
   #endif
   // extern void MX_IWDG_Init(void);
   // MX_IWDG_Init();
-  set_mcu_led_status(LED_MCU_RUNING);
+
 
   for(;;)
   {
diff --git a/Core/Src/stm32f4xx_hal_msp.c b/Core/Src/stm32f4xx_hal_msp.c
index 003ab2c..d15b58c 100644
--- a/Core/Src/stm32f4xx_hal_msp.c
+++ b/Core/Src/stm32f4xx_hal_msp.c
@@ -75,7 +75,7 @@ extern DMA_HandleTypeDef hdma_usart6_tx;
 /* USER CODE END 0 */
 
 void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
-/**
+                    /**
   * Initializes the Global MSP.
   */
 void HAL_MspInit(void)
@@ -282,6 +282,9 @@ void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
     GPIO_InitStruct.Pull = GPIO_NOPULL;
     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
     HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
+  /* USER CODE BEGIN I2C1_MspDeInit 1 */
+
+  /* USER CODE END I2C1_MspDeInit 1 */
   }
   else if(hi2c->Instance==I2C3)
   {
@@ -311,6 +314,9 @@ void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
     GPIO_InitStruct.Pull = GPIO_NOPULL;
     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
     HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
+  /* USER CODE BEGIN I2C3_MspDeInit 1 */
+
+  /* USER CODE END I2C3_MspDeInit 1 */
   }
 }
 
@@ -760,9 +766,8 @@ void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
     /**TIM1 GPIO Configuration
     PE9     ------> TIM1_CH1
     PE11     ------> TIM1_CH2
-    PE13     ------> TIM1_CH3
     */
-    GPIO_InitStruct.Pin = LED_PWM1_Pin|LED_PWM2_Pin|LED_PWM3_Pin;
+    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_11;
     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     GPIO_InitStruct.Pull = GPIO_NOPULL;
     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
@@ -783,8 +788,10 @@ void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
     /**TIM4 GPIO Configuration
     PD12     ------> TIM4_CH1
     PD13     ------> TIM4_CH2
+    PD14     ------> TIM4_CH3
+    PD15     ------> TIM4_CH4
     */
-    GPIO_InitStruct.Pin = FAN1_PWM_Pin|FAN2_PWM_Pin;
+    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     GPIO_InitStruct.Pull = GPIO_NOPULL;
     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
diff --git a/Core/Src/stm32f4xx_it.c b/Core/Src/stm32f4xx_it.c
index c2b7f63..30778e9 100644
--- a/Core/Src/stm32f4xx_it.c
+++ b/Core/Src/stm32f4xx_it.c
@@ -72,8 +72,7 @@ extern WWDG_HandleTypeDef hwwdg;
 extern TIM_HandleTypeDef htim1;
 extern TIM_HandleTypeDef htim2;
 extern TIM_HandleTypeDef htim4;
-extern TIM_HandleTypeDef htim9;
-extern TIM_HandleTypeDef htim12;
+extern TIM_HandleTypeDef htim5;
 /* USER CODE BEGIN EV */
 
 /* USER CODE END EV */
@@ -264,6 +263,20 @@ void TIM1_UP_TIM10_IRQHandler(void)
   /* USER CODE END TIM1_UP_TIM10_IRQn 1 */
 }
 
+
+/**
+  * @brief This function handles TIM5 global interrupt.
+  */
+void TIM5_IRQHandler(void)
+{
+  /* USER CODE BEGIN TIM5_IRQn 0 */
+
+  /* USER CODE END TIM5_IRQn 0 */
+  HAL_TIM_IRQHandler(&htim5);
+  /* USER CODE BEGIN TIM5_IRQn 1 */
+
+  /* USER CODE END TIM5_IRQn 1 */
+}
 /******************************************************************************/
 /* STM32F4xx Peripheral Interrupt Handlers                                    */
 /* Add here the Interrupt Handlers for the used peripherals.                  */
@@ -356,20 +369,6 @@ void DMA1_Stream4_IRQHandler(void)
   /* USER CODE END DMA1_Stream4_IRQn 1 */
 }
 
-/**
-  * @brief This function handles EXTI line1 interrupt.
-  */
-void EXTI1_IRQHandler(void)
-{
-  /* USER CODE BEGIN EXTI1_IRQn 0 */
-
-  /* USER CODE END EXTI1_IRQn 0 */
-  HAL_GPIO_EXTI_IRQHandler(KEY_USER_RST_Pin);
-  /* USER CODE BEGIN EXTI1_IRQn 1 */
-
-  /* USER CODE END EXTI1_IRQn 1 */
-}
-
 /**
   * @brief This function handles EXTI line[9:5] interrupts.
   */
@@ -385,21 +384,6 @@ void EXTI9_5_IRQHandler(void)
   /* USER CODE END EXTI9_5_IRQn 1 */
 }
 
-/**
-  * @brief This function handles TIM1 break interrupt and TIM9 global interrupt.
-  */
-void TIM1_BRK_TIM9_IRQHandler(void)
-{
-  /* USER CODE BEGIN TIM1_BRK_TIM9_IRQn 0 */
-
-  /* USER CODE END TIM1_BRK_TIM9_IRQn 0 */
-  HAL_TIM_IRQHandler(&htim1);
-  HAL_TIM_IRQHandler(&htim9);
-  /* USER CODE BEGIN TIM1_BRK_TIM9_IRQn 1 */
-
-  /* USER CODE END TIM1_BRK_TIM9_IRQn 1 */
-}
-
 /**
   * @brief This function handles TIM2 global interrupt.
   */
@@ -428,20 +412,6 @@ void TIM4_IRQHandler(void)
   /* USER CODE END TIM4_IRQn 1 */
 }
 
-/**
-  * @brief This function handles TIM8 break interrupt and TIM12 global interrupt.
-  */
-void TIM8_BRK_TIM12_IRQHandler(void)
-{
-  /* USER CODE BEGIN TIM8_BRK_TIM12_IRQn 0 */
-
-  /* USER CODE END TIM8_BRK_TIM12_IRQn 0 */
-  HAL_TIM_IRQHandler(&htim12);
-  /* USER CODE BEGIN TIM8_BRK_TIM12_IRQn 1 */
-
-  /* USER CODE END TIM8_BRK_TIM12_IRQn 1 */
-}
-
 /**
   * @brief This function handles EXTI line[15:10] interrupts.
   */
diff --git a/Core/Src/web-server.c b/Core/Src/web-server.c
index 37d1b96..fd0495c 100644
--- a/Core/Src/web-server.c
+++ b/Core/Src/web-server.c
@@ -9102,14 +9102,9 @@ const unsigned char info_html[] ="<html lang=\"en\"> \
 															data: {\n \
 																ipaddr: ipaddr,\n \
 																gateway: gateway,\n \
-																subnetwork: subnetwork, \n \
-																macaddr: macaddr \n \
+																subnetwork: subnetwork \n \
 															},\n \
 															beforeSend: function() { \n \
-																if(!(macaddr.length>0 && isValidMacAddress(macaddr))){\n \
-																	alert('macaddr illegal!' );\n \
-																	return false;\n \
-																}\n \
 																if(!(ipaddr.length>0 && validateIPAddress(ipaddr))){\n \
 																	alert('ipaddr illegal!' );\n \
 																	return false;\n \
@@ -9911,7 +9906,7 @@ const unsigned char info_html[] ="<html lang=\"en\"> \
 										<div class=\"net-work\" > \
 											<h3>Network System</h3> \
 											<div class=\"network-row\"> \
-											<label>Mac Address:</label> <input type=\"text\" id=\"macaddr\" value=\"0\" style=\"width: 180px;\"> <br> \
+											<label>Mac Address:</label> <input type=\"text\" id=\"macaddr\" value=\"0\" style=\"width: 180px;\" disabled> <br> \
 											</div>  \
 											<div class=\"network-row\"> \
 											<label> IP Address :</label> <input type=\"text\" id=\"ipaddr\" value=\"0\" style=\"width: 180px;\"> <br> \
@@ -10570,7 +10565,7 @@ NETInfo get_net_info(void) {
 	p_addr = ip4addr_ntoa(&ip4_addr);
 	strcpy(example.gateway, p_addr);
 
-	es_get_mcu_mac(mac);
+	es_get_mcu_mac(mac, MCU_MAC_IDX);
 	memset(example.macaddr, 0, sizeof(example.macaddr));
 	snprintf(example.macaddr, sizeof(example.macaddr), "%02x:%02x:%02x:%02x:%02x:%02x",
 			mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
@@ -10581,23 +10576,43 @@ NETInfo get_net_info(void) {
 
 int set_net_info(NETInfo netinfo) {
 	u32_t naddr;
-	uint8_t mac[6];
+	// uint8_t mac[6];
+	struct ip_t ip;
+	struct netmask_t netmask;
+	struct getway_t gw;
 
 	/* set ipaddr */
 	naddr = ipaddr_addr(netinfo.ipaddr);
 	es_set_mcu_ipaddr((uint8_t *)&naddr);
+	/* Prepare ip struct for validating eth settings */
+	ip.ip_addr0 = 0xff & naddr;
+	ip.ip_addr1 = 0xff & (naddr >> 8);
+	ip.ip_addr2 = 0xff & (naddr >> 16);
+	ip.ip_addr3 = 0xff & (naddr >> 24);
 
 	/* set netmask */
 	naddr = ipaddr_addr(netinfo.subnetwork);
 	es_set_mcu_netmask((uint8_t *)&naddr);
+	/* Prepare netmask struct for validating eth settings */
+	netmask.netmask_addr0 = 0xff & naddr;
+	netmask.netmask_addr1 = 0xff & (naddr >> 8);
+	netmask.netmask_addr2 = 0xff & (naddr >> 16);
+	netmask.netmask_addr3 = 0xff & (naddr >> 24);
 
 	/* set gateway */
 	naddr = ipaddr_addr(netinfo.gateway);
 	es_set_mcu_gateway((uint8_t *)&naddr);
-
-	/* set mac */
-	hexstr2mac(mac, netinfo.macaddr);
-	es_set_mcu_mac(mac);
+	/* Prepare gateway struct for validating eth settings */
+	gw.getway_addr0 = 0xff & naddr;
+	gw.getway_addr1 = 0xff & (naddr >> 8);
+	gw.getway_addr2 = 0xff & (naddr >> 16);
+	gw.getway_addr3 = 0xff & (naddr >> 24);
+
+	/* Dynamically validate eth settings finally */
+	es_set_eth(&ip, &netmask, &gw, NULL);
+	// /* set mac is not permitted throug web page */
+	// hexstr2mac(mac, netinfo.macaddr);
+	// es_set_mcu_mac(mac, MCU_MAC_IDX);
 
 	return 0;
 }
@@ -11487,7 +11502,7 @@ http_server_netconn_serve(struct netconn *conn)
 					char* ipaddr=NULL;
 					char* gateway=NULL;
 					char* subnetwork=NULL;
-					char* macaddr=NULL;
+					// char* macaddr=NULL;
 
 					kv_pair *current = params.head;
 					while (current) {
@@ -11497,23 +11512,19 @@ http_server_netconn_serve(struct netconn *conn)
 							gateway= current->value;
 						}else if(strcmp(current->key,"subnetwork")==0){
 							subnetwork= current->value;
-						}else if(strcmp(current->key,"macaddr")==0){
-							macaddr= current->value;
 						}
 						current = current->next;
 					}
-					LWIP_ASSERT("ipaddr!=NULL&&gateway!=NULL&&subnetwork!=NULL&&macaddr!=NULL", ipaddr!=NULL&&gateway!=NULL&&subnetwork!=NULL&&macaddr!=NULL);
-					unescape_colon(macaddr);
-					LWIP_ASSERT("strlen(ipaddr)<16 && strlen(macaddr)<18 &&strlen(subnetwork)<16 && strlen(gateway)<16 ", strlen(ipaddr)<16 && strlen(macaddr)<18 &&strlen(subnetwork)<16 && strlen(gateway)<16 );
+					LWIP_ASSERT("ipaddr!=NULL&&gateway!=NULL&&subnetwork!=NULL", ipaddr!=NULL&&gateway!=NULL&&subnetwork!=NULL);
+					// unescape_colon(macaddr);
+					LWIP_ASSERT("strlen(ipaddr)<16  &&strlen(subnetwork)<16 && strlen(gateway)<16 ", strlen(ipaddr)<16  &&strlen(subnetwork)<16 && strlen(gateway)<16 );
 
 					NETInfo netinfo;
 					strncpy(netinfo.ipaddr, ipaddr, strlen(ipaddr));
-					strncpy(netinfo.macaddr, macaddr, strlen(macaddr));
 					strncpy(netinfo.subnetwork, subnetwork, strlen(subnetwork));
 					strncpy(netinfo.gateway, gateway, strlen(gateway));
 
 					netinfo.ipaddr[strlen(ipaddr)] = '\0';
-					netinfo.macaddr[strlen(macaddr)] = '\0';
 					netinfo.subnetwork[strlen(subnetwork)] = '\0';
 					netinfo.gateway[strlen(gateway)] = '\0';
 
-- 
2.25.1

