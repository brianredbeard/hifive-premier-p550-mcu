From 994c72824f9ab6e3cc1b2798e102b97991a418dc Mon Sep 17 00:00:00 2001
From: linmin <linmin@eswincomputing.com>
Date: Wed, 28 Aug 2024 19:32:57 +0800
Subject: [PATCH 103/109] WIN2030-15279:feat(bmc2.6):Check CBInfo when SOM is
 powered up

Changelogs:
1.Check carrier board info every time when SOM is powered up.
  If the CBInfo in eeprom is corrupted, recover it.
2.If hf_i2c_mem_write/read() returns error, retry serveral times.
  This is because that the SCL of I2C line will be pulled down
  for 250ms by SOM when SOM is powered down. This will cause
  the MCU I2C bus status to fall into busy status.

Signed-off-by: linmin <linmin@eswincomputing.com>
Change-Id: Id1c4a6110233a126f30218bcc7dfbf929f121538
---
 Core/Inc/hf_common.h        |   3 +-
 Core/Src/hf_common.c        | 119 ++++++++++++++++++++++++++++++++++++
 Core/Src/hf_gpio_process.c  |   7 ++-
 Core/Src/hf_i2c.c           |  98 ++++++++++++++++++-----------
 Core/Src/hf_power_process.c |   9 ++-
 5 files changed, 194 insertions(+), 42 deletions(-)

diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index b016de2..c921e9e 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -237,7 +237,7 @@ extern UART_HandleTypeDef huart6;
 #endif
 /* define ------------------------------------------------------------*/
 #define BMC_SOFTWARE_VERSION_MAJOR                   2
-#define BMC_SOFTWARE_VERSION_MINOR                   5
+#define BMC_SOFTWARE_VERSION_MINOR                   6
 
 #define MAGIC_NUMBER	0x45505EF1
 
@@ -317,6 +317,7 @@ void eth_get_address(void);
 
 /* eeprom APIs */
 int es_init_info_in_eeprom(void);
+int es_check_carrier_board_info(void);
 
 int es_get_carrier_borad_info(CarrierBoardInfo *pCarrier_board_info);
 int es_set_carrier_borad_info(CarrierBoardInfo *pCarrier_board_info);
diff --git a/Core/Src/hf_common.c b/Core/Src/hf_common.c
index d7c0b06..6a7cc05 100644
--- a/Core/Src/hf_common.c
+++ b/Core/Src/hf_common.c
@@ -273,6 +273,36 @@ static int restore_cbinfo_to_factory(CarrierBoardInfo *pCarrier_Board_Info)
 	return 0;
 }
 
+static int restore_cbinfo_to_factory_without_mutext(CarrierBoardInfo *pCarrier_Board_Info)
+{
+	char sn[] = "sn1234567890abcdef";
+
+	memset(pCarrier_Board_Info, 0, sizeof(CarrierBoardInfo));
+	pCarrier_Board_Info->magicNumber = MAGIC_NUMBER;
+
+	pCarrier_Board_Info->formatVersionNumber = 0x3;
+	pCarrier_Board_Info->productIdentifier = 0x4;
+	pCarrier_Board_Info->pcbRevision = 0x10;
+	pCarrier_Board_Info->bomRevision = 0x10;
+	pCarrier_Board_Info->bomVariant = 0x10;
+
+	memcpy(pCarrier_Board_Info->boardSerialNumber, sn, sizeof(pCarrier_Board_Info->boardSerialNumber));
+
+	pCarrier_Board_Info->manufacturingTestStatus = 0x10;
+
+	pCarrier_Board_Info->ethernetMAC3[0] = MAC_ADDR0;
+	pCarrier_Board_Info->ethernetMAC3[1] = MAC_ADDR1;
+	pCarrier_Board_Info->ethernetMAC3[2] = MAC_ADDR2;
+	pCarrier_Board_Info->ethernetMAC3[3] = MAC_ADDR3;
+	pCarrier_Board_Info->ethernetMAC3[4] = MAC_ADDR4;
+	pCarrier_Board_Info->ethernetMAC3[5] = MAC_ADDR5;
+
+	pCarrier_Board_Info->crc32Checksum = hf_crc32((uint8_t *)pCarrier_Board_Info, sizeof(CarrierBoardInfo) - 4);
+
+
+	return 0;
+}
+
 static int print_cbinfo(CarrierBoardInfo *pCarrierBoardInfo)
 {
 	char boardSn[19] = {0};
@@ -1520,3 +1550,92 @@ int es_set_som_console_cfg(int som_console_cfg)
 
 	return 0;
 }
+
+/* This API is called every time when som is powered up */
+int es_check_carrier_board_info(void)
+{
+	int ret = 0;
+	uint32_t crc32Checksum;
+	CarrierBoardInfo CbinfoMain;
+	CarrierBoardInfo CbinfoBackup;
+	uint8_t reg_addr = 0;
+
+	esENTER_CRITICAL(gEEPROM_Mutex, portMAX_DELAY);
+	/* read main partintion */
+	reg_addr = CARRIER_BOARD_INFO_EEPROM_MAIN_OFFSET;
+	ret = hf_i2c_mem_read(&hi2c1, AT24C_ADDR, reg_addr,
+				(uint8_t *)&CbinfoMain, sizeof(CarrierBoardInfo));
+	if(ret) {
+		printf("Failed to read cbinfo_main\n");
+		goto out;
+	}
+	print_cbinfo(&CbinfoMain);
+	print_data((uint8_t *)&CbinfoMain, sizeof(CarrierBoardInfo));
+	/* calculate crc32 checksum of main partition */
+	crc32Checksum = hf_crc32((uint8_t *)&CbinfoMain, sizeof(CarrierBoardInfo) - 4);
+	if (crc32Checksum != CbinfoMain.crc32Checksum) { //main partition is bad
+		printf("Bad main checksum,0x%lx is NOT equal to calculated value:0x%lx\n", CbinfoMain.crc32Checksum, crc32Checksum);
+		eeprom_debug("%s:%d\n", __func__, __LINE__);
+		print_data((uint8_t *)&CbinfoMain, sizeof(CarrierBoardInfo));
+		/* try to read and check the backup partition */
+		reg_addr = CARRIER_BOARD_INFO_EEPROM_BACKUP_OFFSET;
+		ret = hf_i2c_mem_read(&hi2c1, AT24C_ADDR, reg_addr,
+					(uint8_t *)&CbinfoBackup, sizeof(CarrierBoardInfo));
+		if(ret) {
+			printf("Failed to read cbinfo_backup\n");
+			goto out;
+		}
+
+		crc32Checksum = hf_crc32((uint8_t *)&CbinfoBackup, sizeof(CarrierBoardInfo) - 4);
+		if (crc32Checksum != CbinfoBackup.crc32Checksum) { // backup patition is also bad
+			/* restore to factory settings */
+			printf("Bad backup checksum,0x%lx is also NOT equal to calculated value:0x%lx\n", CbinfoBackup.crc32Checksum, crc32Checksum);
+			restore_cbinfo_to_factory_without_mutext(&gCarrier_Board_Info);
+			printf("Restored cbinfo to factory settings\n");
+		}
+		else { // backup partion is ok
+			/* recover the main partition with the backup value */
+			printf("Recover main with backup settings\n");
+			/* update the global variable gCarrier_Board_Info with the backup value */
+			memcpy(&gCarrier_Board_Info, &CbinfoBackup, sizeof(CarrierBoardInfo));
+			/* recover main partion with the values of backup */
+			reg_addr = CARRIER_BOARD_INFO_EEPROM_MAIN_OFFSET;
+			ret = hf_i2c_mem_write(&hi2c1, AT24C_ADDR, reg_addr,
+						(uint8_t *)&CbinfoBackup, sizeof(CarrierBoardInfo));
+			if(ret) {
+				printf("Failed to write cbinfo_main\n");
+				goto out;
+			}
+		}
+	}
+	else { // main partition is ok
+		/* check backup partion, if it's bad, recover it with main value */
+		reg_addr = CARRIER_BOARD_INFO_EEPROM_BACKUP_OFFSET;
+		ret = hf_i2c_mem_read(&hi2c1, AT24C_ADDR, reg_addr,
+					(uint8_t *)&CbinfoBackup, sizeof(CarrierBoardInfo));
+		if(ret) {
+			printf("Failed to read cbinfo_backup\n");
+			goto out;
+		}
+		print_cbinfo(&CbinfoBackup);
+		crc32Checksum = hf_crc32((uint8_t *)&CbinfoBackup, sizeof(CarrierBoardInfo) - 4);
+		if (crc32Checksum != CbinfoBackup.crc32Checksum) {
+			/* recover the backup partition with the main value */
+			printf("Bad backup checksum,0x%lx is NOT equal to calculated value:0x%lx\n", CbinfoBackup.crc32Checksum, crc32Checksum);
+			printf("Recover backup with main settings\n");
+			reg_addr = CARRIER_BOARD_INFO_EEPROM_BACKUP_OFFSET;
+			ret = hf_i2c_mem_write(&hi2c1, AT24C_ADDR, reg_addr,
+						(uint8_t *)&CbinfoMain, sizeof(CarrierBoardInfo));
+			if(ret) {
+				printf("Failed to write cbinfo_backup\n");
+				goto out;
+			}
+		}
+		else {
+			printf("cbinfo checksum ok!!!!\n");
+		}
+	}
+out:
+	esEXIT_CRITICAL(gEEPROM_Mutex);
+	return ret;
+}
\ No newline at end of file
diff --git a/Core/Src/hf_gpio_process.c b/Core/Src/hf_gpio_process.c
index e7a13fd..7cacaab 100644
--- a/Core/Src/hf_gpio_process.c
+++ b/Core/Src/hf_gpio_process.c
@@ -155,11 +155,16 @@ static void mcu_reset_som_process(void)
 {
 	bmc_debug("%s %d mcu reset som\n", __func__, __LINE__);
 	StopSomRebootTimer();
+	/* Check the carrier board info once the SOM is powered up. If the carrier board info
+	   in the EEPROM is corrupted, it will be recoverd with the backup.
+	*/
+	es_check_carrier_board_info();
 }
 
 static void som_rst_feedback_process(void)
 {
-	bmc_debug("%s %d som reset\n", __func__, __LINE__);
+	bmc_debug("%s %d som reset, get_som_power_state()=%d\n",
+		__func__, __LINE__, get_som_power_state());
 	if (get_som_power_state() == SOM_DAEMON_ON) {
 		som_reset_control(pdTRUE);
 		osDelay(2);
diff --git a/Core/Src/hf_i2c.c b/Core/Src/hf_i2c.c
index 7af04c2..9b15b98 100644
--- a/Core/Src/hf_i2c.c
+++ b/Core/Src/hf_i2c.c
@@ -11,6 +11,8 @@
 #include "stm32f4xx_hal.h"
 #include "main.h"
 #include <stdio.h>
+#include "cmsis_os.h"
+
 void hf_i2c_reinit(I2C_HandleTypeDef *hi2c)
 {
 	if (hi2c->Instance == I2C1)
@@ -60,24 +62,31 @@ int hf_i2c_mem_read(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
 					uint8_t reg_addr, uint8_t *data_ptr, uint32_t len)
 {
 	HAL_StatusTypeDef status = HAL_OK;
+	uint32_t retry_cnt = 0;
 
-	status = HAL_I2C_Mem_Read(hi2c, slave_addr, reg_addr, I2C_MEMADD_SIZE_8BIT,
+	do {
+		retry_cnt++;
+		status = HAL_I2C_Mem_Read(hi2c, slave_addr, reg_addr, I2C_MEMADD_SIZE_8BIT,
 					data_ptr, len, 1000);
-	if (status != HAL_OK)
-	{
-		printf("I2Cx_read_Error(%x) reg %x; status %x\r\n", slave_addr, reg_addr, status);
-		hf_i2c_reinit(hi2c);
-		return status;
-	}
+		if ((status != HAL_OK))
+		{
+			printf("I2Cx_read_Error(%x) reg %x; status %x, tried times: %ld\r\n", slave_addr, reg_addr, status, retry_cnt);
+			osDelay(pdMS_TO_TICKS(50));
+			hf_i2c_reinit(hi2c);
+		}
+	}while((HAL_OK != status) && (retry_cnt < 10));
+
 	return status;
 }
 
 int hf_i2c_mem_write(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
 					  uint8_t reg_addr, uint8_t *data_ptr, uint32_t len)
 {
-	int i, j = 0, offset;
+	int i, offset;
 	int unaligned_bytes = 0, aligned_bytes; // the reg_addr offset that is not aligned with 8Bytes
 	HAL_StatusTypeDef status = HAL_OK;
+	uint32_t retry_cnt = 6;
+
 	// printf("slave_addr %x, reg_addr %x len %ld\n",slave_addr, reg_addr, len);
 	if (hi2c->Instance == I2C1)
 		HAL_GPIO_WritePin(EEPROM_WP_GPIO_Port, EEPROM_WP_Pin, GPIO_PIN_RESET);
@@ -86,47 +95,66 @@ int hf_i2c_mem_write(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
 	unaligned_bytes = ALIGN(reg_addr, 8) - reg_addr;
 	unaligned_bytes = MIN(unaligned_bytes, len);
 	for (i = 0; i < unaligned_bytes; i++) {
-		status = HAL_I2C_Mem_Write(hi2c, slave_addr, reg_addr + i,
-								I2C_MEMADD_SIZE_8BIT, data_ptr + i, 1,
-								1000);
-		if (status != HAL_OK)
-		{
-			printf("I2Cx_write_Error(slave_addr:%x, errcode:%d) %d;\r\n", slave_addr, status, j);
-			hf_i2c_reinit(hi2c);
+		retry_cnt = 0;
+		do {
+			retry_cnt++;
+			status = HAL_I2C_Mem_Write(hi2c, slave_addr, reg_addr + i,
+									I2C_MEMADD_SIZE_8BIT, data_ptr + i, 1,
+									1000);
+			if (status != HAL_OK)
+			{
+				printf("I2Cx_write_Error(%x) reg %x; status %x, tried times: %ld\r\n", slave_addr, reg_addr + i, status, retry_cnt);
+				osDelay(pdMS_TO_TICKS(50));
+				hf_i2c_reinit(hi2c);
+			}
+		}while((HAL_OK != status) && (retry_cnt < 6));
+		// while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
+		if (HAL_OK != status)
 			goto out;
-		}
-		while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
 	}
 	offset = i;
 	// 8 bytes page write
 	aligned_bytes = ((len - unaligned_bytes) / 8) * 8;
 	for (i = 0; i < aligned_bytes;) {
-		status = HAL_I2C_Mem_Write(hi2c, slave_addr, reg_addr + offset + i,
-								I2C_MEMADD_SIZE_8BIT, data_ptr + offset + i, 8,
-								1000);
-		if (status != HAL_OK)
-		{
-			printf("I2Cx_write_Error(slave_addr:%x, errcode:%d) %d;\r\n", slave_addr, status, j);
-			hf_i2c_reinit(hi2c);
+		retry_cnt = 0;
+		do {
+			retry_cnt++;
+			status = HAL_I2C_Mem_Write(hi2c, slave_addr, reg_addr + offset + i,
+									I2C_MEMADD_SIZE_8BIT, data_ptr + offset + i, 8,
+									1000);
+			if (status != HAL_OK)
+			{
+				printf("I2Cx_write_Error(%x) reg %x; status %x, tried times: %ld\r\n", slave_addr, reg_addr + offset + i, status, retry_cnt);
+				osDelay(pdMS_TO_TICKS(50));
+				hf_i2c_reinit(hi2c);
+			}
+		}while((HAL_OK != status) && (retry_cnt < 6));
+		// while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
+		if (HAL_OK != status)
 			goto out;
-		}
-		while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
+
 		i = i + 8;
 	}
 	offset = offset + i;
 	// the left bytes
 	unaligned_bytes = len - unaligned_bytes - aligned_bytes;
 	for (i = 0; i < unaligned_bytes; i++) {
-		status = HAL_I2C_Mem_Write(hi2c, slave_addr, reg_addr + offset + i,
-								I2C_MEMADD_SIZE_8BIT, data_ptr + offset + i, 1,
-								1000);
-		if (status != HAL_OK)
-		{
-			printf("I2Cx_write_Error(slave_addr:%x, errcode:%d) %d;\r\n", slave_addr, status, j);
-			hf_i2c_reinit(hi2c);
+		retry_cnt = 0;
+		do {
+			retry_cnt++;
+			status = HAL_I2C_Mem_Write(hi2c, slave_addr, reg_addr + offset + i,
+									I2C_MEMADD_SIZE_8BIT, data_ptr + offset + i, 1,
+									1000);
+			if (status != HAL_OK)
+			{
+				printf("I2Cx_write_Error(%x) reg %x; status %x, tried times: %ld\r\n", slave_addr, reg_addr + offset + i, status, retry_cnt);
+				osDelay(pdMS_TO_TICKS(50));
+				hf_i2c_reinit(hi2c);
+			}
+		}while((HAL_OK != status) && (retry_cnt < 6));
+		// while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
+		if (HAL_OK != status)
 			goto out;
-		}
-		while (HAL_I2C_IsDeviceReady(hi2c, slave_addr, 0xff, 0xff) == HAL_TIMEOUT);
 	}
 out:
 	if (hi2c->Instance == I2C1)
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index 3348c7a..8f3189d 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -125,6 +125,10 @@ void hf_power_task(void *parameter)
 			break;
 		case SOM_STATUS_CHECK_STATE:
 			printf("SOM_STATUS_CHECK_STATE\r\n");
+			/* Check the carrier board info once the SOM is powered up. If the carrier board info
+			in the EEPROM is corrupted, it will be recoverd with the backup.
+			*/
+			es_check_carrier_board_info();
 			som_reset_control(pdFALSE);
 			power_state = POWERON;
 			printf("POWERON\r\n");
@@ -218,11 +222,6 @@ void som_reset_control(uint8_t reset)
 		uart_deinit(USART6);
 		SPI2_MASTER_CS_LOW();
 	} else {
-	// 	GPIO_InitStruct.Pin = BOOT_SEL0_Pin | BOOT_SEL1_Pin | BOOT_SEL2_Pin | BOOT_SEL3_Pin;
-	// 	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
-	// 	GPIO_InitStruct.Pull = GPIO_NOPULL;
-	// 	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
-	// 	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 		HAL_GPIO_WritePin(MCU_RESET_SOM_N_GPIO_Port, MCU_RESET_SOM_N_Pin, GPIO_PIN_SET);
 		GPIO_InitStruct.Pin = MCU_RESET_SOM_N_Pin;
 		GPIO_InitStruct.Pull = GPIO_NOPULL;
-- 
2.25.1

