From 00d9b937a00005498b18af89705611d56b2052e2 Mon Sep 17 00:00:00 2001
From: xuxiang <xuxiang@eswincomputing.com>
Date: Mon, 22 Apr 2024 11:16:19 +0800
Subject: [PATCH 002/109] WIN2030-15279 : feat : add protocol lib and
 production test cmd

Changelogs:
1. add protocol lib
2. Add a production test cmd

Change-Id: I0843959c3d506c60c9f4b2934d6760e9c5a66f56
---
 Core/Inc/hf_common.h             |  10 +
 Core/Inc/main.h                  |   1 +
 Core/Inc/stm32f4xx_hal_conf.h    |   2 +-
 Core/Inc/stm32f4xx_it.h          |   1 +
 Core/Src/hf_board_init.c         | 138 ++++++++----
 Core/Src/hf_gpio_process.c       |  10 -
 Core/Src/hf_http_process.c       |  39 +++-
 Core/Src/hf_it_callback.c        |  26 +++
 Core/Src/hf_power_process.c      |   1 -
 Core/Src/hf_protocol_process.c   | 359 +++++++++++++++++++++++++++++++
 Core/Src/main.c                  | 104 ++++++---
 Core/Src/protocol_lib/protocol.c | 190 +---------------
 Core/Src/protocol_lib/protocol.h | 130 ++++++++---
 Core/Src/stm32f4xx_hal_msp.c     |  47 ++++
 Core/Src/stm32f4xx_it.c          |  15 ++
 LWIP/App/lwip.c                  | 205 +++++++++---------
 LWIP/App/lwip.h                  |  38 ++++
 LWIP/Target/ethernetif.c         |  14 +-
 Makefile                         |   3 +-
 19 files changed, 918 insertions(+), 415 deletions(-)
 create mode 100644 Core/Src/hf_protocol_process.c

diff --git a/Core/Inc/hf_common.h b/Core/Inc/hf_common.h
index 87ffd89..8a7d6d1 100644
--- a/Core/Inc/hf_common.h
+++ b/Core/Inc/hf_common.h
@@ -21,6 +21,16 @@ typedef enum {
   STOP_POWER
 } power_state_t;
 
+typedef enum {
+  KEY_IDLE_STATE = 0,
+  KEY_PRESS_DETECTED_STATE,
+  KEY_RELEASE_DETECTED_STATE,
+  KEY_SHORT_PRESS_STATE,
+  KEY_LONG_PRESS_STATE,
+  KEY_DOUBLE_PRESS_STATE,
+  KEY_PRESS_STATE_END
+} button_state_t;
+
 typedef enum {
   SOM_POWER_OFF,
   SOM_POWER_ON
diff --git a/Core/Inc/main.h b/Core/Inc/main.h
index 2d192a7..025b9cd 100644
--- a/Core/Inc/main.h
+++ b/Core/Inc/main.h
@@ -46,6 +46,7 @@ extern DMA_HandleTypeDef hdma_spi1_tx;
 extern DMA_HandleTypeDef hdma_spi2_rx;
 extern DMA_HandleTypeDef hdma_spi2_tx;
 extern TIM_HandleTypeDef htim4;
+extern TIM_HandleTypeDef htim5;
 extern UART_HandleTypeDef huart4;
 extern UART_HandleTypeDef huart3;
 extern UART_HandleTypeDef huart6;
diff --git a/Core/Inc/stm32f4xx_hal_conf.h b/Core/Inc/stm32f4xx_hal_conf.h
index e622882..509d524 100644
--- a/Core/Inc/stm32f4xx_hal_conf.h
+++ b/Core/Inc/stm32f4xx_hal_conf.h
@@ -190,7 +190,7 @@
 #define  USE_HAL_SPDIFRX_REGISTER_CALLBACKS     0U /* SPDIFRX register callback disabled   */
 #define  USE_HAL_SMBUS_REGISTER_CALLBACKS       0U /* SMBUS register callback disabled     */
 #define  USE_HAL_SPI_REGISTER_CALLBACKS         0U /* SPI register callback disabled       */
-#define  USE_HAL_TIM_REGISTER_CALLBACKS         0U /* TIM register callback disabled       */
+#define  USE_HAL_TIM_REGISTER_CALLBACKS         1U /* TIM register callback disabled       */
 #define  USE_HAL_UART_REGISTER_CALLBACKS        1U /* UART register callback disabled      */
 #define  USE_HAL_USART_REGISTER_CALLBACKS       1U /* USART register callback disabled     */
 #define  USE_HAL_WWDG_REGISTER_CALLBACKS        0U /* WWDG register callback disabled      */
diff --git a/Core/Inc/stm32f4xx_it.h b/Core/Inc/stm32f4xx_it.h
index c7cb1d6..4143322 100644
--- a/Core/Inc/stm32f4xx_it.h
+++ b/Core/Inc/stm32f4xx_it.h
@@ -61,6 +61,7 @@ void DMA1_Stream4_IRQHandler(void);
 void EXTI9_5_IRQHandler(void);
 void TIM1_UP_TIM10_IRQHandler(void);
 void TIM4_IRQHandler(void);
+void TIM5_IRQHandler(void);
 void EXTI15_10_IRQHandler(void);
 void DMA2_Stream0_IRQHandler(void);
 void DMA2_Stream1_IRQHandler(void);
diff --git a/Core/Src/hf_board_init.c b/Core/Src/hf_board_init.c
index 49ef2f4..8ad36f2 100644
--- a/Core/Src/hf_board_init.c
+++ b/Core/Src/hf_board_init.c
@@ -42,6 +42,7 @@ DMA_HandleTypeDef hdma_spi1_tx;
 DMA_HandleTypeDef hdma_spi2_rx;
 DMA_HandleTypeDef hdma_spi2_tx;
 TIM_HandleTypeDef htim4;
+TIM_HandleTypeDef htim5;
 UART_HandleTypeDef huart4;
 UART_HandleTypeDef huart3;
 UART_HandleTypeDef huart6;
@@ -68,6 +69,7 @@ static void MX_UART4_Init(void);
 static void MX_CRC_Init(void);
 static void MX_RNG_Init(void);
 void MX_IWDG_Init(void);
+static void MX_TIM5_Init(void);
 
 /* Private user code ---------------------------------------------------------*/
 /* For cross-domain devices, initialize the I2C after the atx is powered on */
@@ -136,7 +138,7 @@ int board_init(void)
 	MX_SPI1_Init();
 	MX_CRC_Init();
 	MX_RNG_Init();
-
+	// MX_TIM5_Init();
 	/* There is leakage, the som must be released before initialization */
 	// MX_UART4_Init();
 	// MX_USART6_UART_Init();
@@ -149,15 +151,6 @@ int board_init(void)
 	// MX_WWDG_Init();
 	// MX_IWDG_Init();
 
-	// HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6 | GPIO_PIN_7, GPIO_PIN_RESET);
-	// GPIO_InitTypeDef GPIO_InitStruct = {0};
-	// GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7;
-	// GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
-	// GPIO_InitStruct.Pull = GPIO_NOPULL;
-	// GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-	// HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
-	// HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6 | GPIO_PIN_7, GPIO_PIN_RESET);
-
 	printf("\r\n%s %d %s %s\r\n", __func__, __LINE__, __DATE__, __TIME__);
 	return 0;
 }
@@ -299,8 +292,6 @@ void MX_IWDG_Init(void)
  */
 static void MX_RTC_Init(void)
 {
-
-
 	/** Initialize RTC Only */
 	hrtc.Instance = RTC;
 	hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
@@ -432,6 +423,7 @@ static void MX_SPI2_Init(void)
  * @param None
  * @retval None
  */
+uint32_t pwm_period = 1000;
 static void MX_TIM4_Init(void)
 {
 	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
@@ -439,9 +431,9 @@ static void MX_TIM4_Init(void)
 	TIM_OC_InitTypeDef sConfigOC = {0};
 
 	htim4.Instance = TIM4;
-	htim4.Init.Prescaler = 0;
+	htim4.Init.Prescaler = 8;
 	htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
-	htim4.Init.Period = 65535;
+	htim4.Init.Period = pwm_period;
 	htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 	htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 	if (HAL_TIM_Base_Init(&htim4) != HAL_OK) {
@@ -454,39 +446,37 @@ static void MX_TIM4_Init(void)
 	if (HAL_TIM_PWM_Init(&htim4) != HAL_OK) {
 		Error_Handler();
 	}
-	if (HAL_TIM_OC_Init(&htim4) != HAL_OK) {
-		Error_Handler();
-	}
 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 	if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK) {
 		Error_Handler();
 	}
-	// sConfigOC.OCMode = TIM_OCMODE_PWM1;
-	// sConfigOC.Pulse = 0;
-	// sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
-	// sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
-	// if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
-	// {
-	//   Error_Handler();
-	// }
-	// sConfigOC.OCMode = TIM_OCMODE_PWM1;
-	// sConfigOC.Pulse = 0;
-	// sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
-	// sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
-	// if (HAL_TIM_OC_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
-	// {
-	//   Error_Handler();
-	// }
+
 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
-	sConfigOC.Pulse = 30000;
+	sConfigOC.Pulse = pwm_period/2;
+	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
+	sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
+	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
+	{
+	  Error_Handler();
+	}
+	sConfigOC.OCMode = TIM_OCMODE_PWM1;
+	sConfigOC.Pulse = pwm_period/2;
+	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
+	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
+	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
+	{
+	  Error_Handler();
+	}
+	sConfigOC.OCMode = TIM_OCMODE_PWM1;
+	sConfigOC.Pulse = pwm_period/2;
 	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK) {
 		Error_Handler();
 	}
 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
-	sConfigOC.Pulse = 30000;
+	sConfigOC.Pulse = pwm_period/2;
 	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 	if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK) {
@@ -494,11 +484,79 @@ static void MX_TIM4_Init(void)
 	}
 
 	HAL_TIM_MspPostInit(&htim4);
-	// if (HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_3) != HAL_OK)
-	// {
-	//   printf("HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_3) err\n");
-	//   Error_Handler();
-	// }
+}
+
+
+/**
+  * @brief TIM5 Initialization Function
+  * @param None
+  * @retval None
+  */
+static void MX_TIM5_Init(void)
+{
+
+  /* USER CODE BEGIN TIM5_Init 0 */
+
+  /* USER CODE END TIM5_Init 0 */
+
+  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
+  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
+  TIM_IC_InitTypeDef sConfigIC = {0};
+  TIM_MasterConfigTypeDef sMasterConfig = {0};
+
+  /* USER CODE BEGIN TIM5_Init 1 */
+
+  /* USER CODE END TIM5_Init 1 */
+  htim5.Instance = TIM5;
+  htim5.Init.Prescaler = 71;
+  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
+  htim5.Init.Period = 3000;
+  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
+  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
+  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
+  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  if (HAL_TIM_IC_Init(&htim5) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_RESET;
+  sSlaveConfig.InputTrigger = TIM_TS_TI2FP2;
+  sSlaveConfig.TriggerPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
+  sSlaveConfig.TriggerPrescaler = TIM_ICPSC_DIV1;
+  sSlaveConfig.TriggerFilter = 0;
+  if (HAL_TIM_SlaveConfigSynchro(&htim5, &sSlaveConfig) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
+  sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
+  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
+  sConfigIC.ICFilter = 0;
+  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
+  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
+  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
+  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
+  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  /* USER CODE BEGIN TIM5_Init 2 */
+  /* USER CODE END TIM5_Init 2 */
 
 }
 
diff --git a/Core/Src/hf_gpio_process.c b/Core/Src/hf_gpio_process.c
index ceef3de..ad47308 100644
--- a/Core/Src/hf_gpio_process.c
+++ b/Core/Src/hf_gpio_process.c
@@ -22,16 +22,6 @@
 #define KEY_PUSHDOWN GPIO_PIN_RESET
 #define KEY_RELEASE GPIO_PIN_SET
 /* Private macro -------------------------------------------------------------*/
-typedef enum {
-  KEY_IDLE_STATE = 0,
-  KEY_PRESS_DETECTED_STATE,
-  KEY_RELEASE_DETECTED_STATE,
-  KEY_SHORT_PRESS_STATE,
-  KEY_LONG_PRESS_STATE,
-  KEY_DOUBLE_PRESS_STATE,
-  KEY_PRESS_STATE_END
-} button_state_t;
-
 /* Private variables ---------------------------------------------------------*/
 extern power_switch_t som_power_state;
 
diff --git a/Core/Src/hf_http_process.c b/Core/Src/hf_http_process.c
index 3609a32..b5c3289 100644
--- a/Core/Src/hf_http_process.c
+++ b/Core/Src/hf_http_process.c
@@ -6,10 +6,46 @@
 #include "dhcp.h"
 extern struct netif gnetif;
 struct dhcp *dhcp;
-
+uint8_t ip_address[4] = {0};
+uint8_t netmask_address[4] = {0};
+uint8_t getway_address[4] = {0};
+uint8_t mac_address[6] = {0};
+void eth_get_address(void)
+{
+  if(!ip_address[0])
+  {
+    ip_address[0] = IP_ADDR0;
+    ip_address[1] = IP_ADDR1;
+    ip_address[2] = IP_ADDR2;
+    ip_address[3] = IP_ADDR3;
+  }
+  if(!getway_address[0])
+  {
+    getway_address[0] = GATEWAY_ADDR0;
+    getway_address[1] = GATEWAY_ADDR1;
+    getway_address[2] = GATEWAY_ADDR2;
+    getway_address[3] = GATEWAY_ADDR3;
+  }
+  if(!ip4_addr_netmask_valid(netmask_address))
+  {
+    netmask_address[0] = NETMASK_ADDR0;
+    netmask_address[1] = NETMASK_ADDR1;
+    netmask_address[2] = NETMASK_ADDR2;
+    netmask_address[3] = NETMASK_ADDR3;
+  }
+  if (!is_valid_ethaddr(mac_address)) {
+    mac_address[0] = MAC_ADDR0;
+    mac_address[1] = MAC_ADDR1;
+    mac_address[2] = MAC_ADDR2;
+    mac_address[3] = MAC_ADDR3;
+    mac_address[4] = MAC_ADDR4;
+    mac_address[5] = MAC_ADDR5;
+  }
+}
 void hf_http_task(void *argument)
 {
   /* init code for LWIP */
+  eth_get_address();
   MX_LWIP_Init();
   httpd_init();
   // /* Infinite loop */
@@ -18,7 +54,6 @@ void hf_http_task(void *argument)
   printf("Static IP address: %s\n", ip4addr_ntoa(&gnetif.ip_addr));
   printf("Subnet mask: %s\n", ip4addr_ntoa(&gnetif.netmask));
   printf("Default gateway: %s\n", ip4addr_ntoa(&gnetif.gw));
-
   for(;;)
   {
     osDelay(1000);
diff --git a/Core/Src/hf_it_callback.c b/Core/Src/hf_it_callback.c
index f766d3e..ee205ce 100644
--- a/Core/Src/hf_it_callback.c
+++ b/Core/Src/hf_it_callback.c
@@ -89,6 +89,32 @@ void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
 	}
 }
 
+
+/**
+  * @brief  Input Capture callback in non-blocking mode
+  * @param  htim TIM IC handle
+  * @retval None
+  */
+uint32_t PWM2_T_Count =0;
+uint32_t PWM2_D_Count =0;
+
+__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
+{
+  /* Prevent unused argument(s) compilation warning */
+  UNUSED(htim);
+	if(htim->Instance == TIM5)
+	{
+		if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
+		{
+			PWM2_T_Count = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
+		}
+		else if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)   // 通道2
+		{
+			PWM2_D_Count = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
+		}
+	}
+}
+
 #ifdef USE_FULL_ASSERT
 /**
  * @brief  Reports the name of the source file and the source line number
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index 96bb8dc..f1ff30f 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -18,7 +18,6 @@
 
 /* Private macro -------------------------------------------------------------*/
 #define PCA9450_ADDR (0x25u << 1)
-
 /* Private variables ---------------------------------------------------------*/
 power_switch_t som_power_state = SOM_POWER_OFF;
 
diff --git a/Core/Src/hf_protocol_process.c b/Core/Src/hf_protocol_process.c
new file mode 100644
index 0000000..ca2d8c6
--- /dev/null
+++ b/Core/Src/hf_protocol_process.c
@@ -0,0 +1,359 @@
+#include "cmsis_os2.h"
+#include "hf_common.h"
+#include "main.h"
+#include "protocol.h"
+#include "stm32f4xx.h"
+#include "stm32f4xx_hal.h"
+
+#define head_meg "\xA5\x5A\xAA\x55"
+#define end_msg "\x0D\x0A\x0D\x0A"
+#define req_ok "\x6B\x6F"
+#define req_fail "\x6C\x69\x61\x66"
+
+uint32_t RxBuf_SIZE = 64;
+uint8_t RxBuf[96];
+b_frame_class_t frame_uart3;
+
+extern uint8_t ip_address[4];
+extern uint8_t netmask_address[4];
+extern uint8_t getway_address[4];
+extern uint8_t mac_address[6];
+extern osThreadId_t http_task_handle;
+extern osThreadAttr_t http_task_attributes;
+
+void es_send_req(b_frame_class_t *pframe, uint8_t req_cmd, int8_t *frame_data, uint8_t len)
+{
+	uint8_t buf[MAX_FRAME_LEN] = {0};
+	uint8_t b_len, xor = 0;
+	printf("%s\n", frame_data);
+	for (int i = 0; i < len; i++) {
+		xor ^= frame_data[i];
+	}
+	memcpy(buf, pframe->frame_info.head, pframe->frame_info.head_len);
+	b_len = pframe->frame_info.head_len;
+
+	memcpy(buf + b_len, &req_cmd, 1);
+	b_len += 1;
+
+	memcpy(buf + b_len, &len, 1);
+	b_len += 1;
+	memcpy(buf + b_len, frame_data, len);
+	b_len += len;
+
+	memcpy(buf + b_len, &xor, 1);
+	b_len += 1;
+
+	memcpy(buf + b_len, pframe->frame_info.end, pframe->frame_info.end_len);
+	b_len += pframe->frame_info.end_len;
+	printf("len = %d \n", len);
+	printf("xor = %d \n", xor);
+	return 0;
+
+	HAL_UART_Transmit(&huart3, buf, b_len, HAL_MAX_DELAY); // transmit the full sentence again
+}
+
+int32_t es_set_gpio(struct gpio_cmd *gpio)
+{
+	GPIO_TypeDef *gpio_group;
+	GPIO_InitTypeDef GPIO_InitStruct = {0};
+	if (gpio->group == 0)
+		gpio_group = GPIOA;
+	else if (gpio->group == 1)
+		gpio_group = GPIOB;
+	else if (gpio->group == 2)
+		gpio_group = GPIOC;
+	else if (gpio->group == 3)
+		gpio_group = GPIOD;
+	else if (gpio->group == 4)
+		gpio_group = GPIOE;
+	else if (gpio->group == 5)
+		gpio_group = GPIOF;
+	else if (gpio->group == 6)
+		gpio_group = GPIOG;
+	else if (gpio->group == 7)
+		gpio_group = GPIOH;
+	else if (gpio->group == 8)
+		gpio_group = GPIOI;
+	else
+		return HAL_ERROR;
+	// printf("%s %d\n", __func__, __LINE__);
+
+	HAL_GPIO_WritePin(gpio_group, gpio->pin_num, gpio->value);
+
+	GPIO_InitStruct.Pin = gpio->pin_num;
+	GPIO_InitStruct.Mode = gpio->driection;
+	GPIO_InitStruct.Pull = GPIO_NOPULL;
+	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
+	HAL_GPIO_Init(gpio_group, &GPIO_InitStruct);
+	return HAL_OK;
+}
+
+int32_t es_set_eth(struct ip_t *ip, struct netmask_t *netmask, struct getway_t *gw, struct eth_mac_t *mac)
+{
+	if (http_task_handle)
+		osThreadTerminate(http_task_handle);
+	if (ip != NULL) {
+		ip_address[0] = ip->ip_addr0;
+		ip_address[1] = ip->ip_addr1;
+		ip_address[2] = ip->ip_addr2;
+		ip_address[3] = ip->ip_addr3;
+		// printf("IP_ADDR0:%d IP_ADDR1: %d IP_ADDR2: %d IP_ADDR3 %d\n", \
+			ip_address[0], ip_address[1], ip_address[2], ip_address[3]);
+	}
+	if (netmask != NULL) {
+		netmask_address[0] = netmask->netmask_addr0;
+		netmask_address[1] = netmask->netmask_addr1;
+		netmask_address[2] = netmask->netmask_addr2;
+		netmask_address[3] = netmask->netmask_addr3;
+		// printf("NETMASK_ADDR0:%d NETMASK_ADDR1: %d NETMASK_ADDR2: %d NETMASK_ADDR3 %d\n", \
+		netmask_address[0], netmask_address[1], netmask_address[2], netmask_address[3]);
+	}
+	if (gw != NULL) {
+		getway_address[0] = gw->getway_addr0;
+		getway_address[1] = gw->getway_addr1;
+		getway_address[2] = gw->getway_addr2;
+		getway_address[3] = gw->getway_addr3;
+		// printf("GETWAY_ADDR0:%d GETWAY_ADDR1: %dGETWAY_ADDR2: %d GETWAY_ADDR3 %d\n", \
+			getway_address[0], getway_address[1], getway_address[2], getway_address[3]);
+	}
+	if (mac != NULL) {
+		mac_address[0] = mac->eth_mac_addr0;
+		mac_address[1] = mac->eth_mac_addr1;
+		mac_address[2] = mac->eth_mac_addr2;
+		mac_address[3] = mac->eth_mac_addr3;
+		mac_address[4] = mac->eth_mac_addr4;
+		mac_address[5] = mac->eth_mac_addr5;
+		// printf("GETWAY_ADDR0:%d GETWAY_ADDR1: %dGETWAY_ADDR2: %d GETWAY_ADDR3 %d\n", \
+			getway_address[0], getway_address[1], getway_address[2], getway_address[3]);
+	}
+	http_task_handle = osThreadNew(hf_http_task, NULL, &http_task_attributes);
+	return HAL_OK;
+}
+
+int32_t es_set_rtc_date(struct rtc_date_t *sdate)
+{
+	RTC_DateTypeDef sDate = {0};
+	sDate.Year = sdate->Year;
+	sDate.Month = sdate->Month;
+	sDate.Date = sdate->Date;
+	sDate.WeekDay = sdate->WeekDay;
+
+	if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
+		return HAL_ERROR;
+	return HAL_OK;
+}
+
+int32_t es_set_rtc_time(struct rtc_time_t *stime)
+{
+	RTC_TimeTypeDef sTime = {0};
+	sTime.Hours = stime->Hours;
+	sTime.Minutes = stime->Minutes;
+	sTime.Seconds = stime->Seconds;
+	sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
+	sTime.StoreOperation = RTC_STOREOPERATION_SET;
+	if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
+		return HAL_ERROR;
+	return HAL_OK;
+}
+
+int32_t es_get_rtc_date(struct rtc_date_t *sdate)
+{
+	RTC_DateTypeDef GetData;
+	if (HAL_RTC_GetDate(&hrtc, &GetData, RTC_FORMAT_BIN) != HAL_OK)
+		return HAL_ERROR;
+	printf("yy/mm/dd  %02d/%02d/%02d\r\n", 2000 + GetData.Year, GetData.Month, GetData.Date);
+	sdate->Year = 2000 + GetData.Year;
+	sdate->Month = GetData.Month;
+	sdate->Date = GetData.Date;
+	sdate->WeekDay = GetData.WeekDay;
+	return HAL_OK;
+}
+
+extern uint32_t pwm_period;
+int32_t es_set_fan_duty(struct fan_control_t *fan)
+{
+	TIM_OC_InitTypeDef sConfigOC = {0};
+	if(fan->duty > 100)
+		return HAL_ERROR;
+
+	if (fan->fan_num == 0) {
+		if (HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_1) != HAL_OK)
+			return HAL_ERROR;
+
+		sConfigOC.OCMode = TIM_OCMODE_PWM1;
+		sConfigOC.Pulse = fan->duty*pwm_period/100;
+		sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
+		sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
+		if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
+			return HAL_ERROR;
+		
+		if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1) != HAL_OK)
+			return HAL_ERROR;
+	} else if (fan->fan_num == 1) {
+		if (HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_2) != HAL_OK)
+			return HAL_ERROR;
+
+		sConfigOC.OCMode = TIM_OCMODE_PWM1;
+		sConfigOC.Pulse = fan->duty*pwm_period/100;
+		sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
+		sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
+		if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
+			return HAL_ERROR;
+		
+		if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2) != HAL_OK)
+			return HAL_ERROR;
+	} else {
+		return HAL_ERROR;
+	}
+	return HAL_OK;
+}
+
+int32_t es_get_fan_duty(struct fan_control_t *fan)
+{
+	if (fan->fan_num == 0) {
+		fan->duty = 50;
+	} else if (fan->fan_num == 1) {
+		fan->duty = 60;
+	} else {
+		return HAL_ERROR;
+	}
+	return HAL_OK;
+}
+
+int32_t es_get_rtc_time(struct rtc_time_t *stime)
+{
+	RTC_TimeTypeDef GetTime;
+	if (HAL_RTC_GetTime(&hrtc, &GetTime, RTC_FORMAT_BIN) != HAL_OK)
+		return HAL_ERROR;
+	printf(" hh:mm:ss %02d:%02d:%02d\r\n", GetTime.Hours, GetTime.Minutes, GetTime.Seconds);
+	stime->Hours = GetTime.Hours;
+	stime->Minutes = GetTime.Minutes;
+	stime->Seconds = GetTime.Seconds;
+	return HAL_OK;
+}
+
+void es_process_cmd(b_frame_class_t *pframe)
+{
+	uint8_t cmd = pframe->frame.cmd;
+	// printf("%s %d cmd %x\n", __func__, __LINE__, cmd);
+	switch (cmd) {
+	case CMD_EEPROM_WP:
+		es_eeprom_wp(pframe->frame.data.value);
+		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_GPIO:
+		if (es_set_gpio(&pframe->frame.data.gpio) != HAL_OK)
+			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
+		else
+			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_SET_IP:
+		es_set_eth(&pframe->frame.data.ip, NULL, NULL, NULL);
+		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_SET_NETMASK:
+		es_set_eth(NULL, &pframe->frame.data.netmask, NULL, NULL);
+		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_SET_GATWAY:
+		es_set_eth(NULL, NULL, &pframe->frame.data.getway, NULL);
+		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_SET_MAC:
+		es_set_eth(NULL, NULL, NULL, &pframe->frame.data.mac);
+		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_SET_DATE:
+		if (es_set_rtc_date(&pframe->frame.data.rtc_date) != HAL_OK)
+			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
+		else
+			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_SET_TIME:
+		if (es_set_rtc_time(&pframe->frame.data.rtc_date) != HAL_OK)
+			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
+		else
+			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_SET_FAN_DUTY:
+		if (es_set_fan_duty(&pframe->frame.data.fan) != HAL_OK)
+			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
+		else
+			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		break;
+	case CMD_GET_DATE:
+		if (es_get_rtc_date(&pframe->frame.data.rtc_date) != HAL_OK)
+			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
+		else
+			es_send_req(pframe, CMD_GET_DATE, &pframe->frame.data.rtc_date, sizeof(struct rtc_date_t));
+		// printf("yy/mm/dd  %02d/%02d/%02d %02d\r\n", 2000 + pframe->frame.data.rtc_date.Year, pframe->frame.data.rtc_date.Month, \
+				pframe->frame.data.rtc_date.Date, pframe->frame.data.rtc_date.WeekDay);
+		break;
+	case CMD_GET_TIME:
+		if (es_get_rtc_time(&pframe->frame.data.rtc_time) != HAL_OK)
+			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
+		else
+			es_send_req(pframe, CMD_GET_TIME, &pframe->frame.data.rtc_time, sizeof(struct rtc_time_t));
+		// printf(" hh:mm:ss %02d:%02d:%02d\r\n", pframe->frame.data.rtc_time.Hours,\
+						pframe->frame.data.rtc_time.Minutes, pframe->frame.data.rtc_time.Seconds);
+		break;
+	case CMD_GET_FAN_DUTY:
+		if (es_get_fan_duty(&pframe->frame.data.fan) != HAL_OK)
+			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
+		else
+			es_send_req(pframe, CMD_GET_FAN_DUTY, &pframe->frame.data.fan, sizeof(struct fan_control_t));
+		break;
+	default:;
+		break;
+	}
+}
+
+void protocol_task(void *argument)
+{
+	// printf("%s %d\n", __func__, __LINE__);
+	b_frame_t frame_info;
+	frame_info.head = head_meg;
+	frame_info.head_len = sizeof(head_meg) - 1;
+	frame_info.end = end_msg;
+	frame_info.end_len = sizeof(end_msg) - 1;
+	frame_info.pname = "uart3";
+	frame_uart3._in_frame_buffer_size = 256;
+	es_frame_init(&frame_uart3, &frame_info);
+	/* enable uart3 dma rx */
+	HAL_UARTEx_ReceiveToIdle_DMA(&huart3, RxBuf, RxBuf_SIZE);
+
+	uint8_t protocol_status = 0;
+	for (;;) {
+		switch (protocol_status) {
+		case CHECK_HEAD:
+			if (!es_check_head(&frame_uart3))
+				protocol_status = CHECK_CMD;
+			break;
+		case CHECK_CMD:
+			// printf("%s CHECK_CMD\n", __func__);
+			if (!es_get_cmd_and_data(&frame_uart3)) {
+				protocol_status = CHECK_TAIL;
+			} else {
+				es_send_req(&frame_uart3, CMD_RES, req_fail, sizeof(req_fail) - 1);
+				protocol_status = CHECK_HEAD;
+			}
+			break;
+		case CHECK_TAIL:
+			// printf("%s CHECK_TAIL\n", __func__);
+			if (!es_check_tail(&frame_uart3)) {
+				protocol_status = PROCESS_CMD;
+			} else {
+				es_send_req(&frame_uart3, CMD_RES, req_fail, sizeof(req_fail) - 1);
+				protocol_status = CHECK_HEAD;
+			}
+			break;
+		case PROCESS_CMD:
+			es_process_cmd(&frame_uart3);
+			protocol_status = CHECK_HEAD;
+			break;
+		default:
+			protocol_status = CHECK_HEAD;
+		}
+		osDelay(900);
+	}
+}
\ No newline at end of file
diff --git a/Core/Src/main.c b/Core/Src/main.c
index 60a7efb..a63e651 100644
--- a/Core/Src/main.c
+++ b/Core/Src/main.c
@@ -32,7 +32,7 @@
 osThreadId_t main_task_handle;
 const osThreadAttr_t main_task_attributes = {
   .name = "MainTask",
-  .stack_size = 1024*2,
+  .stack_size = 1024*4,
   .priority = (osPriority_t) osPriorityNormal,
 };
 
@@ -91,7 +91,6 @@ int main(void)
 
   /* configure the system clock and Initialize all configured peripherals. */
   board_init();
-  printf("\r\n%s %d %s %s\r\n",__func__, __LINE__, __DATE__, __TIME__);
 
   /* Init scheduler */
   osKernelInitialize();
@@ -133,6 +132,7 @@ static void mcu_status_led_on(uint8_t turnon)
   * @param  argument: Not used
   * @retval None
   */
+extern void get_rtc_info(void);
 extern void hf_power_task (void* parameter);
 extern void hf_gpio_task (void* parameter);
 void hf_main_task(void *argument)
@@ -141,52 +141,86 @@ void hf_main_task(void *argument)
   power_task_handle = osThreadNew(hf_power_task, NULL, &power_task_attributes);
   key_task_handle = osThreadNew(hf_gpio_task, NULL, &gpio_task_attributes);
   http_task_handle = osThreadNew(hf_http_task, NULL, &http_task_attributes);
-  moniter_task_handle = osThreadNew(MoniterTask, NULL, &MoniterTask_attributes);
-  // protocol_task_handle = osThreadNew(protocol_task, NULL, &protocol_task_attributes);
-  printf("HiFive 106SC \n");
+  // moniter_task_handle = osThreadNew(MoniterTask, NULL, &MoniterTask_attributes);
+  protocol_task_handle = osThreadNew(protocol_task, NULL, &protocol_task_attributes);
   osDelay(900);
+  printf("HiFive 106SC \n");
   // extern void MX_IWDG_Init(void);
 
 	// MX_IWDG_Init();
 
+	
   mcu_status_led_on(pdTRUE);
+  // extern uint32_t PWM2_T_Count;
+  // extern uint32_t PWM2_D_Count;
+  // uint32_t uiFrequency;
   for(;;)
   {
-
+	  HAL_Delay(500);
+		// uiFrequency = 1000000 / PWM2_D_Count;
+		// printf("占空:%dus    周期:%dus    频率:%dHz    \r\n", PWM2_T_Count, PWM2_D_Count, uiFrequency);
+    // PWM2_T_Count = 0;
+    // PWM2_D_Count = 0;
+    // uiFrequency = 0;
     // HAL_IWDG_Refresh(&hiwdg);
+    // get_rtc_info();
     osDelay(800);
   }
 }
 
-
 #if 0
+void fan_info(void)
+{
+  if (HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1) != HAL_OK)
+	{
+	  printf("HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1) err\n");
+	  Error_Handler();
+	}
+	if (HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_2) != HAL_OK)
+	{
+	  printf("HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_2) err\n");
+	  Error_Handler();
+	}
+
+  if (HAL_TIM_IC_Start_IT(&htim5,TIM_CHANNEL_1) != HAL_OK)
+	{
+	  printf("HAL_TIM_IC_Start(&htim5,TIM_CHANNEL_1) err\n");
+	  Error_Handler();
+	}
+	if (HAL_TIM_IC_Start_IT(&htim5,TIM_CHANNEL_2) != HAL_OK)
+	{
+		printf("HAL_TIM_IC_Start(&htim5,TIM_CHANNEL_2) err\n");
+		Error_Handler();
+	}
+}
+
 void get_rtc_info(void)
 {
   RTC_DateTypeDef GetData;
   RTC_TimeTypeDef GetTime;
-  RTC_AlarmTypeDef alarm1;
-  RTC_AlarmTypeDef alarm2;
   HAL_RTC_GetTime(&hrtc, &GetTime, RTC_FORMAT_BIN);
   /* Get the RTC current Date */
   HAL_RTC_GetDate(&hrtc, &GetData, RTC_FORMAT_BIN);
 
   /* Display date Format : yy/mm/dd */
-  printf("%02d/%02d/%02d\r\n",2000 + GetData.Year, GetData.Month, GetData.Date);
+  printf("yy/mm/dd  %02d/%02d/%02d\r\n",2000 + GetData.Year, GetData.Month, GetData.Date);
   /* Display time Format : hh:mm:ss */
-  printf("%02d:%02d:%02d\r\n",GetTime.Hours, GetTime.Minutes, GetTime.Seconds);
-
-  HAL_RTC_GetAlarm(&hrtc, &alarm1, RTC_ALARM_A, RTC_FORMAT_BIN);
-  HAL_RTC_GetAlarm(&hrtc, &alarm2, RTC_ALARM_B, RTC_FORMAT_BIN);
-  printf("alarm1 info :\n");
-  printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n", 
-        alarm1.AlarmMask, alarm1.AlarmSubSecondMask, alarm1.AlarmDateWeekDaySel, alarm1.AlarmDateWeekDay, alarm1.Alarm );
-  printf("%02d/%02d/%02d\r\n",alarm1.AlarmTime.Hours, alarm1.AlarmTime.Minutes, alarm1.AlarmTime.Seconds);
-
-  printf("alarm2 info :\n");
-  printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n", 
-        alarm2.AlarmMask, alarm2.AlarmSubSecondMask, alarm2.AlarmDateWeekDaySel, alarm2.AlarmDateWeekDay, alarm2.Alarm );
-  printf("%02d/%02d/%02d\r\n",alarm2.AlarmTime.Hours, alarm2.AlarmTime.Minutes, alarm2.AlarmTime.Seconds);
-  printf("\r\n");
+  printf(" hh:mm:ss %02d:%02d:%02d\r\n",GetTime.Hours, GetTime.Minutes, GetTime.Seconds);
+
+  // RTC_AlarmTypeDef alarm1;
+  // RTC_AlarmTypeDef alarm2;
+  // HAL_RTC_GetAlarm(&hrtc, &alarm1, RTC_ALARM_A, RTC_FORMAT_BIN);
+  // HAL_RTC_GetAlarm(&hrtc, &alarm2, RTC_ALARM_B, RTC_FORMAT_BIN);
+  // printf("alarm1 info :\n");
+  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n", 
+  //       alarm1.AlarmMask, alarm1.AlarmSubSecondMask, alarm1.AlarmDateWeekDaySel, alarm1.AlarmDateWeekDay, alarm1.Alarm );
+  // printf("%02d/%02d/%02d\r\n",alarm1.AlarmTime.Hours, alarm1.AlarmTime.Minutes, alarm1.AlarmTime.Seconds);
+
+  // printf("alarm2 info :\n");
+  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n", 
+  //       alarm2.AlarmMask, alarm2.AlarmSubSecondMask, alarm2.AlarmDateWeekDaySel, alarm2.AlarmDateWeekDay, alarm2.Alarm );
+  // printf("%02d/%02d/%02d\r\n",alarm2.AlarmTime.Hours, alarm2.AlarmTime.Minutes, alarm2.AlarmTime.Seconds);
+  // printf("\r\n");
 }
 #endif
 void MoniterTask(void *argument)
@@ -200,24 +234,24 @@ void MoniterTask(void *argument)
   osDelay(9000);
   for(;;)
   {
-    task_num = uxTaskGetNumberOfTasks();      //获取系统任务数量
+    task_num = uxTaskGetNumberOfTasks();
     printf("\nuxTaskGetNumberOfTasks %ld\r\n", task_num);
 
-    StatusArray = pvPortMalloc(task_num*sizeof(TaskStatus_t));//申请内存
-    if(StatusArray!=NULL)                   //内存申请成功
+    StatusArray = pvPortMalloc(task_num*sizeof(TaskStatus_t));
+    if(StatusArray!=NULL)
     {
-        uxTaskGetSystemState((TaskStatus_t*   )StatusArray,   //任务信息存储数组
-                                      (UBaseType_t     )task_num,  //任务信息存储数组大小
-                                      (uint32_t*       )&TotalRunTime);//保存系统总的运行时间
+        uxTaskGetSystemState((TaskStatus_t*   )StatusArray,
+                                      (UBaseType_t     )task_num,
+                                      (uint32_t*       )&TotalRunTime);
         printf("\nTaskName\t\tPriority\t\tTaskNumber\t\t\r\n");
         for(uint32_t x=0;x < task_num;x++)
         {
-              TaskHandle = xTaskGetHandle(StatusArray[x].pcTaskName);         //根据任务名获取任务句柄
+              TaskHandle = xTaskGetHandle(StatusArray[x].pcTaskName);
 
-              vTaskGetInfo((TaskHandle_t  )TaskHandle,        //任务句柄
-                          (TaskStatus_t* )&TaskStatus,       //任务信息结构体
-                          (BaseType_t    )pdTRUE,            //允许统计任务堆栈历史最小剩余大小
-                          (eTaskState    )eInvalid);         //函数自己获取任务运行壮态
+              vTaskGetInfo((TaskHandle_t  )TaskHandle,
+                          (TaskStatus_t* )&TaskStatus,
+                          (BaseType_t    )pdTRUE,
+                          (eTaskState    )eInvalid);
 
               printf("task name:                %s\r\n",TaskStatus.pcTaskName);
               printf("task number:              %d\r\n",(int)TaskStatus.xTaskNumber);
diff --git a/Core/Src/protocol_lib/protocol.c b/Core/Src/protocol_lib/protocol.c
index d29da1c..3fe7ff7 100644
--- a/Core/Src/protocol_lib/protocol.c
+++ b/Core/Src/protocol_lib/protocol.c
@@ -1,37 +1,5 @@
 #include "protocol.h"
 
-#include <stdint.h>
-#include <stdio.h>
-
-#include "hf_common.h"
-#include "main.h"
-#include "ringbuffer.h"
-
-#define B_ERROR 1
-#define B_SUCCESS 0
-
-extern DMA_HandleTypeDef hdma_usart3_rx;
-#include "stm32f4xx.h"
-uint32_t RxBuf_SIZE = 64;
-uint8_t RxBuf[96];
-b_frame_class_t frame_uart3;
-
-#define MAX_FRAME_LEN 32
-
-typedef enum protocol_status_type {
-	CHECK_HEAD = 0,
-	CHECK_CMD = 1,
-	CHECK_FRAME_LEN = 2,
-	CHECK_DATA = 3,
-	CHECK_XOR = 4,
-	CHECK_TAIL = 5,
-	PROCESS_CMD = 6
-};
-typedef enum protocol_cmd_type { CMD_EEPROM_WP = 0x90, CMD_GPIO = 0x91, CMD_SET_IP = 0x92, CMD_RES = 0xb0 };
-
-#define head_meg "\xA5\x5A\xAA\x55"
-#define end_msg "\x0D\x0A\x0D\x0A"
-
 uint8_t es_frame_init(b_frame_class_t *pframe, b_frame_t *pframeinit)
 {
 	uint8_t err = 0;
@@ -126,7 +94,7 @@ uint8_t es_get_cmd(b_frame_class_t *pframe)
 
 uint8_t es_check_frame(b_frame_class_t *pframe)
 {
-	uint8_t len, xor, ret = B_ERROR;
+	uint8_t len, xor;
 	uint8_t buf[MAX_FRAME_LEN];
 	uint8_t current_xor = 0;
 
@@ -200,159 +168,3 @@ uint8_t es_check_tail(b_frame_class_t *pframe)
 
 	return B_ERROR;
 }
-#include "cmsis_os2.h"
-extern osThreadId_t http_task_handle;
-extern osThreadAttr_t http_task_attributes;
-extern uint8_t IP_ADDRESS[4];
-#include "main.h"
-#include "stm32f4xx_hal.h"
-#define req_ok "\x6B\x6F"
-#define req_fail "\x6C\x69\x61\x66"
-
-void es_send_req(b_frame_class_t *pframe, uint8_t true)
-{
-	uint8_t buf[MAX_FRAME_LEN] = {0};
-	uint8_t len, b_len, xor = 0;
-	uint8_t req_cmd = CMD_RES;
-	uint8_t *cmd_dat;
-	if (true) {
-		len = sizeof(req_ok) - 1;
-		cmd_dat = req_ok;
-	} else {
-		cmd_dat = req_fail;
-		len = sizeof(req_fail) - 1;
-	}
-	for (int i = 0; i < len; i++) {
-		xor ^= cmd_dat[i];
-	}
-	memcpy(buf, pframe->frame_info.head, pframe->frame_info.head_len);
-	b_len = pframe->frame_info.head_len;
-
-	memcpy(buf + b_len, &req_cmd, 1);
-	b_len += 1;
-
-	memcpy(buf + b_len, &len, 1);
-	b_len += 1;
-	memcpy(buf + b_len, cmd_dat, len);
-	b_len += len;
-
-	memcpy(buf + b_len, &xor, 1);
-	b_len += 1;
-
-	memcpy(buf + b_len, pframe->frame_info.end, pframe->frame_info.end_len);
-	b_len += pframe->frame_info.end_len;
-	HAL_UART_Transmit(&huart3, buf, b_len, HAL_MAX_DELAY); // transmit the full sentence again
-}
-
-uint8_t es_process_cmd(b_frame_class_t *pframe)
-{
-	GPIO_InitTypeDef GPIO_InitStruct = {0};
-	GPIO_TypeDef *gpio_group;
-	uint8_t cmd = pframe->frame.cmd;
-	// printf("%s %d cmd %x\n", __func__, __LINE__, cmd);
-	switch (cmd) {
-	case CMD_EEPROM_WP:
-		es_eeprom_wp(pframe->frame.data.value);
-		es_send_req(pframe, 1);
-		break;
-	case CMD_GPIO:
-		if (pframe->frame.data.gpio.group == 0)
-			gpio_group = GPIOA;
-		else if (pframe->frame.data.gpio.group == 1)
-			gpio_group = GPIOB;
-		else if (pframe->frame.data.gpio.group == 2)
-			gpio_group = GPIOC;
-		else if (pframe->frame.data.gpio.group == 3)
-			gpio_group = GPIOD;
-		else if (pframe->frame.data.gpio.group == 4)
-			gpio_group = GPIOE;
-		else if (pframe->frame.data.gpio.group == 5)
-			gpio_group = GPIOF;
-		else if (pframe->frame.data.gpio.group == 6)
-			gpio_group = GPIOG;
-		else if (pframe->frame.data.gpio.group == 7)
-			gpio_group = GPIOH;
-		else if (pframe->frame.data.gpio.group == 8)
-			gpio_group = GPIOI;
-		else
-			es_send_req(pframe, 0);
-		// printf("%s %d\n", __func__, __LINE__);
-
-		HAL_GPIO_WritePin(gpio_group, pframe->frame.data.gpio.pin_num, pframe->frame.data.gpio.value);
-
-		GPIO_InitStruct.Pin = pframe->frame.data.gpio.pin_num;
-		GPIO_InitStruct.Mode = pframe->frame.data.gpio.driection;
-		GPIO_InitStruct.Pull = GPIO_NOPULL;
-		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
-		HAL_GPIO_Init(gpio_group, &GPIO_InitStruct);
-		es_send_req(pframe, 1);
-		break;
-	case CMD_SET_IP:
-		if (http_task_handle)
-			osThreadTerminate(http_task_handle);
-		IP_ADDRESS[0] = pframe->frame.data.ip.ip_addr0;
-		IP_ADDRESS[1] = pframe->frame.data.ip.ip_addr1;
-		IP_ADDRESS[2] = pframe->frame.data.ip.ip_addr2;
-		IP_ADDRESS[3] = pframe->frame.data.ip.ip_addr3;
-		// printf("IP_ADDR0:%d IP_ADDR1: %d IP_ADDR2: %d IP_ADDR3 %d\n", IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], \
-			   IP_ADDRESS[3]);
-		http_task_handle = osThreadNew(hf_http_task, NULL, &http_task_attributes);
-		es_send_req(pframe, 1);
-		break;
-	default:;
-		break;
-	}
-}
-
-void protocol_task(void *argument)
-{
-	// printf("%s %d\n", __func__, __LINE__);
-	b_frame_t frame_info;
-	frame_info.head = head_meg;
-	// frame_info.head_len = 4;
-	frame_info.head_len = sizeof(head_meg) - 1;
-	frame_info.end = end_msg;
-	frame_info.end_len = sizeof(end_msg) - 1;
-	// frame_info.end_len = 4;
-	frame_info.pname = "uart3";
-	frame_uart3._in_frame_buffer_size = 256;
-	es_frame_init(&frame_uart3, &frame_info);
-	// memset(&pframe->frame, 0, siezeof(struct frame_data));
-	// printf("%s %d\n", __func__, __LINE__);
-	/* enable uart3 dma rx */
-	HAL_UARTEx_ReceiveToIdle_DMA(&huart3, RxBuf, RxBuf_SIZE);
-	uint8_t protocol_status = 0;
-	for (;;) {
-		switch (protocol_status) {
-		case CHECK_HEAD:
-			if (!es_check_head(&frame_uart3))
-				protocol_status = CHECK_CMD;
-			break;
-		case CHECK_CMD:
-			// printf("%s CHECK_CMD\n", __func__);
-			if (!es_get_cmd_and_data(&frame_uart3)) {
-				protocol_status = CHECK_TAIL;
-			} else {
-				es_send_req(&frame_uart3, 0);
-				protocol_status = CHECK_HEAD;
-			}
-			break;
-		case CHECK_TAIL:
-			// printf("%s CHECK_TAIL\n", __func__);
-			if (!es_check_tail(&frame_uart3)) {
-				protocol_status = PROCESS_CMD;
-			} else {
-				es_send_req(&frame_uart3, 0);
-				protocol_status = CHECK_HEAD;
-			}
-			break;
-		case PROCESS_CMD:
-			es_process_cmd(&frame_uart3);
-			protocol_status = CHECK_HEAD;
-			break;
-		default:
-			protocol_status = CHECK_HEAD;
-		}
-		osDelay(900);
-	}
-}
\ No newline at end of file
diff --git a/Core/Src/protocol_lib/protocol.h b/Core/Src/protocol_lib/protocol.h
index 008e738..9baae49 100644
--- a/Core/Src/protocol_lib/protocol.h
+++ b/Core/Src/protocol_lib/protocol.h
@@ -1,17 +1,22 @@
 #ifndef __ES_PROTOCOL_CORE_H__
 #define __ES_PROTOCOL_CORE_H__
 
-#include "string.h"
-#include "stdint.h"
 #include "ringbuffer.h"
-//协议描述
-typedef struct{
+#include "stdint.h"
+#include "string.h"
+#include "stm32f4xx_hal.h"
+
+#define B_ERROR 1
+#define B_SUCCESS 0
+#define MAX_FRAME_LEN 32
+
+typedef struct {
 	const uint8_t *pname;
-    uint16_t head_len; /* 帧头长度 */
-    uint16_t end_len;  /* 帧尾长度 */
-    const char *head;  /* 指向帧头数据 */
-    const char *end;   /* 指向帧尾数据 */
-}b_frame_t;
+	uint16_t head_len;
+	uint16_t end_len;
+	const char *head;
+	const char *end;
+} b_frame_t;
 
 struct gpio_cmd {
 	uint8_t group;
@@ -20,34 +25,107 @@ struct gpio_cmd {
 	uint8_t value;
 };
 
-struct ip_set_t {
-    uint8_t ip_addr0;
-    uint8_t ip_addr1;
-    uint8_t ip_addr2;
-    uint8_t ip_addr3;
+struct ip_t {
+	uint8_t ip_addr0;
+	uint8_t ip_addr1;
+	uint8_t ip_addr2;
+	uint8_t ip_addr3;
+};
+
+struct netmask_t {
+	uint8_t netmask_addr0;
+	uint8_t netmask_addr1;
+	uint8_t netmask_addr2;
+	uint8_t netmask_addr3;
+};
+
+struct getway_t {
+	uint8_t getway_addr0;
+	uint8_t getway_addr1;
+	uint8_t getway_addr2;
+	uint8_t getway_addr3;
+};
+
+struct eth_mac_t {
+	uint8_t eth_mac_addr0;
+	uint8_t eth_mac_addr1;
+	uint8_t eth_mac_addr2;
+	uint8_t eth_mac_addr3;
+	uint8_t eth_mac_addr4;
+	uint8_t eth_mac_addr5;
 };
+
+struct rtc_date_t {
+  uint16_t Year;
+  uint8_t Month;
+  uint8_t Date;
+  uint8_t WeekDay;
+};
+
+struct rtc_time_t {
+	uint8_t Hours;
+	uint8_t Minutes;
+	uint8_t Seconds;
+};
+
+struct fan_control_t {
+	uint8_t fan_num;
+	uint8_t duty;
+};
+
 struct frame_data {
 	uint8_t is_valid;
 	uint8_t cmd;
 	union {
 		uint32_t value;
 		struct gpio_cmd gpio;
-        struct ip_set_t ip;
-	}data;
+		struct ip_t ip;
+		struct netmask_t netmask;
+		struct getway_t getway;
+		struct eth_mac_t mac;
+		struct rtc_date_t rtc_date;
+		struct rtc_time_t rtc_time;
+		struct fan_control_t fan;
+	} data;
 };
 
-typedef struct
-{
-    b_frame_t frame_info;
-    ring_buf_t _frame_ring;
-    uint32_t _in_frame_buffer_size;
-    struct frame_data frame;
+typedef struct {
+	b_frame_t frame_info;
+	ring_buf_t _frame_ring;
+	uint32_t _in_frame_buffer_size;
+	struct frame_data frame;
 } b_frame_class_t;
 
-#endif
-
-
-
+typedef enum protocol_status_type {
+	CHECK_HEAD = 0,
+	CHECK_CMD = 1,
+	CHECK_FRAME_LEN = 2,
+	CHECK_DATA = 3,
+	CHECK_XOR = 4,
+	CHECK_TAIL = 5,
+	PROCESS_CMD = 6
+}protocol_status_type_e;
 
+typedef enum protocol_cmd_type {
+	CMD_EEPROM_WP = 0x90,
+	CMD_GPIO = 0x91,
+	CMD_SET_IP = 0x92,
+	CMD_SET_NETMASK = 0x93,
+	CMD_SET_GATWAY = 0x94,
+	CMD_SET_MAC = 0x95,
+	CMD_SET_DATE = 0x96,
+	CMD_SET_TIME = 0x97,
+	CMD_SET_FAN_DUTY = 0x98,
+	CMD_GET_DATE = 0xA6,
+	CMD_GET_TIME = 0xA7,
+	CMD_GET_FAN_DUTY = 0xa8,
+	CMD_RES = 0xb0
+}protocol_cmd_type_t;
 
+uint8_t es_frame_init(b_frame_class_t *pframe, b_frame_t *pframeinit);
+uint8_t es_check_head(b_frame_class_t *pframe);
+uint8_t es_get_cmd_and_data(b_frame_class_t *pframe);
+uint8_t es_check_tail(b_frame_class_t *pframe);
+uint8_t es_frame_put(b_frame_class_t *pframe, uint8_t *dat, uint32_t len);
 
+#endif
diff --git a/Core/Src/stm32f4xx_hal_msp.c b/Core/Src/stm32f4xx_hal_msp.c
index ce2bb4e..58525ae 100644
--- a/Core/Src/stm32f4xx_hal_msp.c
+++ b/Core/Src/stm32f4xx_hal_msp.c
@@ -663,6 +663,7 @@ void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
 */
 void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
 {
+  GPIO_InitTypeDef GPIO_InitStruct = {0};
   if(htim_base->Instance==TIM4)
   {
   /* USER CODE BEGIN TIM4_MspInit 0 */
@@ -677,6 +678,32 @@ void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
 
   /* USER CODE END TIM4_MspInit 1 */
   }
+  else if(htim_base->Instance==TIM5)
+  {
+  /* USER CODE BEGIN TIM5_MspInit 0 */
+
+  /* USER CODE END TIM5_MspInit 0 */
+    /* Peripheral clock enable */
+    __HAL_RCC_TIM5_CLK_ENABLE();
+
+    __HAL_RCC_GPIOA_CLK_ENABLE();
+    /**TIM5 GPIO Configuration
+    PA1     ------> TIM5_CH2
+    */
+    GPIO_InitStruct.Pin = GPIO_PIN_1;
+    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+    GPIO_InitStruct.Pull = GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
+    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
+    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
+
+    /* TIM5 interrupt Init */
+    HAL_NVIC_SetPriority(TIM5_IRQn, 5, 0);
+    HAL_NVIC_EnableIRQ(TIM5_IRQn);
+  /* USER CODE BEGIN TIM5_MspInit 1 */
+
+  /* USER CODE END TIM5_MspInit 1 */
+  }
 
 }
 
@@ -709,6 +736,7 @@ void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
   }
 
 }
+
 /**
 * @brief TIM_Base MSP De-Initialization
 * This function freeze the hardware resources used in this example
@@ -731,6 +759,25 @@ void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* htim_base)
 
   /* USER CODE END TIM4_MspDeInit 1 */
   }
+  else if(htim_base->Instance==TIM5)
+  {
+  /* USER CODE BEGIN TIM5_MspDeInit 0 */
+
+  /* USER CODE END TIM5_MspDeInit 0 */
+    /* Peripheral clock disable */
+    __HAL_RCC_TIM5_CLK_DISABLE();
+
+    /**TIM5 GPIO Configuration
+    PA1     ------> TIM5_CH2
+    */
+    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_1);
+
+    /* TIM5 interrupt DeInit */
+    HAL_NVIC_DisableIRQ(TIM5_IRQn);
+  /* USER CODE BEGIN TIM5_MspDeInit 1 */
+
+  /* USER CODE END TIM5_MspDeInit 1 */
+  }
 
 }
 
diff --git a/Core/Src/stm32f4xx_it.c b/Core/Src/stm32f4xx_it.c
index 4438938..daca7ca 100644
--- a/Core/Src/stm32f4xx_it.c
+++ b/Core/Src/stm32f4xx_it.c
@@ -65,6 +65,7 @@ extern DMA_HandleTypeDef hdma_spi1_tx;
 extern DMA_HandleTypeDef hdma_spi2_rx;
 extern DMA_HandleTypeDef hdma_spi2_tx;
 extern TIM_HandleTypeDef htim4;
+extern TIM_HandleTypeDef htim5;
 extern DMA_HandleTypeDef hdma_usart3_rx;
 extern DMA_HandleTypeDef hdma_uart4_rx;
 extern DMA_HandleTypeDef hdma_usart6_rx;
@@ -184,6 +185,20 @@ void TIM1_UP_TIM10_IRQHandler(void)
   /* USER CODE END TIM1_UP_TIM10_IRQn 1 */
 }
 
+
+/**
+  * @brief This function handles TIM5 global interrupt.
+  */
+void TIM5_IRQHandler(void)
+{
+  /* USER CODE BEGIN TIM5_IRQn 0 */
+
+  /* USER CODE END TIM5_IRQn 0 */
+  HAL_TIM_IRQHandler(&htim5);
+  /* USER CODE BEGIN TIM5_IRQn 1 */
+
+  /* USER CODE END TIM5_IRQn 1 */
+}
 /******************************************************************************/
 /* STM32F4xx Peripheral Interrupt Handlers                                    */
 /* Add here the Interrupt Handlers for the used peripherals.                  */
diff --git a/LWIP/App/lwip.c b/LWIP/App/lwip.c
index 83d696a..dcc19da 100644
--- a/LWIP/App/lwip.c
+++ b/LWIP/App/lwip.c
@@ -1,35 +1,35 @@
 /* USER CODE BEGIN Header */
 /**
  ******************************************************************************
-  * File Name          : LWIP.c
-  * Description        : This file provides initialization code for LWIP
-  *                      middleWare.
-  ******************************************************************************
-  * @attention
-  *
-  * Copyright (c) 2024 STMicroelectronics.
-  * All rights reserved.
-  *
-  * This software is licensed under terms that can be found in the LICENSE file
-  * in the root directory of this software component.
-  * If no LICENSE file comes with this software, it is provided AS-IS.
-  *
-  ******************************************************************************
-  */
+ * File Name          : LWIP.c
+ * Description        : This file provides initialization code for LWIP
+ *                      middleWare.
+ ******************************************************************************
+ * @attention
+ *
+ * Copyright (c) 2024 STMicroelectronics.
+ * All rights reserved.
+ *
+ * This software is licensed under terms that can be found in the LICENSE file
+ * in the root directory of this software component.
+ * If no LICENSE file comes with this software, it is provided AS-IS.
+ *
+ ******************************************************************************
+ */
 /* USER CODE END Header */
 
 /* Includes ------------------------------------------------------------------*/
 #include "lwip.h"
 #include "lwip/init.h"
 #include "lwip/netif.h"
-#if defined ( __CC_ARM )  /* MDK ARM Compiler */
+#if defined(__CC_ARM) /* MDK ARM Compiler */
 #include "lwip/sio.h"
 #endif /* MDK ARM Compiler */
 #include "ethernetif.h"
 #include <string.h>
 
 /* USER CODE BEGIN 0 */
-
+uint8_t lwip_dhcp_enable = 0;
 /* USER CODE END 0 */
 /* Private function prototypes -----------------------------------------------*/
 static void ethernet_link_status_updated(struct netif *netif);
@@ -37,7 +37,9 @@ static void ethernet_link_status_updated(struct netif *netif);
 void Error_Handler(void);
 
 /* USER CODE BEGIN 1 */
-
+extern uint8_t ip_address[4];
+extern uint8_t netmask_address[4];
+extern uint8_t getway_address[4];
 /* USER CODE END 1 */
 
 /* Variables Initialization */
@@ -48,13 +50,9 @@ ip4_addr_t gw;
 #if LWIP_IPV6
 ip6_addr_t ip6addr;
 #endif
-uint8_t IP_ADDRESS[4] = {0};
-#if !LWIP_DHCP
-uint8_t NETMASK_ADDRESS[4];
-uint8_t GATEWAY_ADDRESS[4];
-#endif
+
 /* USER CODE BEGIN OS_THREAD_ATTR_CMSIS_RTOS_V2 */
-#define INTERFACE_THREAD_STACK_SIZE ( 1024 )
+#define INTERFACE_THREAD_STACK_SIZE (1024)
 osThreadAttr_t attributes;
 /* USER CODE END OS_THREAD_ATTR_CMSIS_RTOS_V2 */
 
@@ -62,47 +60,52 @@ osThreadAttr_t attributes;
 
 /* USER CODE END 2 */
 /**
-  * LwIP initialization function
-  */
-void MX_LWIP_Init(void)
-{
+ * LwIP initialization function
+ */
+void MX_LWIP_Init(void) {
   /* IP addresses initialization */
-  #if !LWIP_DHCP
-  if(!IP_ADDRESS[0]) {
-    IP_ADDRESS[0] = IP_ADDR0;
-    IP_ADDRESS[1] = IP_ADDR1;
-    IP_ADDRESS[2] = IP_ADDR2;
-    IP_ADDRESS[3] = IP_ADDR3;
+  uint8_t IP_ADDRESS[4];
+  uint8_t NETMASK_ADDRESS[4];
+  uint8_t GATEWAY_ADDRESS[4];
+  if (!lwip_dhcp_enable) {
+    IP_ADDRESS[0] = ip_address[0];
+    IP_ADDRESS[1] = ip_address[1];
+    IP_ADDRESS[2] = ip_address[2];
+    IP_ADDRESS[3] = ip_address[3];
+    NETMASK_ADDRESS[0] = netmask_address[0];
+    NETMASK_ADDRESS[1] = netmask_address[1];
+    NETMASK_ADDRESS[2] = netmask_address[2];
+    NETMASK_ADDRESS[3] = netmask_address[3];
+
+    GATEWAY_ADDRESS[0] = getway_address[0];
+    GATEWAY_ADDRESS[1] = getway_address[1];
+    GATEWAY_ADDRESS[2] = getway_address[2];
+    GATEWAY_ADDRESS[3] = getway_address[3];
   }
-  NETMASK_ADDRESS[0] = NETMASK_ADDR0;
-  NETMASK_ADDRESS[1] = NETMASK_ADDR1;
-  NETMASK_ADDRESS[2] = NETMASK_ADDR2;
-  NETMASK_ADDRESS[3] = NETMASK_ADDR3;
-  GATEWAY_ADDRESS[0] = GATEWAY_ADDR0;
-  GATEWAY_ADDRESS[1] = GATEWAY_ADDR1;
-  GATEWAY_ADDRESS[2] = GATEWAY_ADDR2;
-  GATEWAY_ADDRESS[3] = GATEWAY_ADDR3;
-  #endif
-/* USER CODE BEGIN IP_ADDRESSES */
-/* USER CODE END IP_ADDRESSES */
+  /* USER CODE BEGIN IP_ADDRESSES */
+  /* USER CODE END IP_ADDRESSES */
 
   /* Initilialize the LwIP stack with RTOS */
-  tcpip_init( NULL, NULL );
-
-  #if !LWIP_DHCP
-  /* IP addresses initialization without DHCP (IPv4) */
-  IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
-  IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
-  IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
-  #else
-  /* IP addresses initialization to zero with DHCP (IPv4) */
-  ipaddr.addr = 0;
-  netmask.addr = 0;
-  gw.addr = 0;
-  #endif
+  tcpip_init(NULL, NULL);
+
+  if (!lwip_dhcp_enable) {
+    /* IP addresses initialization without DHCP (IPv4) */
+    IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2],
+             IP_ADDRESS[3]);
+    IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1],
+             NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
+    IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2],
+             GATEWAY_ADDRESS[3]);
+  } else {
+    /* IP addresses initialization to zero with DHCP (IPv4) */
+    ipaddr.addr = 0;
+    netmask.addr = 0;
+    gw.addr = 0;
+  }
 
   /* add the network interface (IPv4/IPv6) with RTOS */
-  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
+  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init,
+            &tcpip_input);
 
 #if LWIP_IPV6
   /* Create IPv6 local address */
@@ -117,24 +120,25 @@ void MX_LWIP_Init(void)
   /* We must always bring the network interface up connection or not... */
   netif_set_up(&gnetif);
 
-  /* Set the link callback function, this function is called on change of link status*/
+  /* Set the link callback function, this function is called on change of link
+   * status*/
   netif_set_link_callback(&gnetif, ethernet_link_status_updated);
 
   /* Create the Ethernet link handler thread */
-/* USER CODE BEGIN H7_OS_THREAD_NEW_CMSIS_RTOS_V2 */
+  /* USER CODE BEGIN H7_OS_THREAD_NEW_CMSIS_RTOS_V2 */
   memset(&attributes, 0x0, sizeof(osThreadAttr_t));
   attributes.name = "EthLink";
   attributes.stack_size = INTERFACE_THREAD_STACK_SIZE;
   attributes.priority = osPriorityBelowNormal;
   osThreadNew(ethernet_link_thread, &gnetif, &attributes);
-/* USER CODE END H7_OS_THREAD_NEW_CMSIS_RTOS_V2 */
-
-  /* Start DHCP negotiation for a network interface (IPv4) */
-  #if LWIP_DHCP
-  dhcp_start(&gnetif);
-  #endif
-/* USER CODE BEGIN 3 */
-/* USER CODE END 3 */
+  /* USER CODE END H7_OS_THREAD_NEW_CMSIS_RTOS_V2 */
+
+/* Start DHCP negotiation for a network interface (IPv4) */
+  if (lwip_dhcp_enable) {
+    dhcp_start(&gnetif);
+  }
+  /* USER CODE BEGIN 3 */
+  /* USER CODE END 3 */
 }
 
 #ifdef USE_OBSOLETE_USER_CODE_SECTION_4
@@ -145,40 +149,36 @@ void MX_LWIP_Init(void)
 #endif
 
 /**
-  * @brief  Notify the User about the network interface config status
-  * @param  netif: the network interface
-  * @retval None
-  */
-static void ethernet_link_status_updated(struct netif *netif)
-{
-  if (netif_is_up(netif))
-  {
-/* USER CODE BEGIN 5 */
-  printf("%s %d netif_is_up \n",__func__, __LINE__);
-/* USER CODE END 5 */
-  }
-  else /* netif is down */
+ * @brief  Notify the User about the network interface config status
+ * @param  netif: the network interface
+ * @retval None
+ */
+static void ethernet_link_status_updated(struct netif *netif) {
+  if (netif_is_up(netif)) {
+    /* USER CODE BEGIN 5 */
+    printf("%s %d netif_is_up \n", __func__, __LINE__);
+    /* USER CODE END 5 */
+  } else /* netif is down */
   {
-/* USER CODE BEGIN 6 */
-  printf("%s %d netif is down  \n",__func__, __LINE__);
-/* USER CODE END 6 */
+    /* USER CODE BEGIN 6 */
+    printf("%s %d netif is down  \n", __func__, __LINE__);
+    /* USER CODE END 6 */
   }
 }
 
-#if defined ( __CC_ARM )  /* MDK ARM Compiler */
+#if defined(__CC_ARM) /* MDK ARM Compiler */
 /**
  * Opens a serial device for communication.
  *
  * @param devnum device number
  * @return handle to serial device if successful, NULL otherwise
  */
-sio_fd_t sio_open(u8_t devnum)
-{
+sio_fd_t sio_open(u8_t devnum) {
   sio_fd_t sd;
 
-/* USER CODE BEGIN 7 */
+  /* USER CODE BEGIN 7 */
   sd = 0; // dummy code
-/* USER CODE END 7 */
+          /* USER CODE END 7 */
 
   return sd;
 }
@@ -191,10 +191,9 @@ sio_fd_t sio_open(u8_t devnum)
  *
  * @note This function will block until the character can be sent.
  */
-void sio_send(u8_t c, sio_fd_t fd)
-{
-/* USER CODE BEGIN 8 */
-/* USER CODE END 8 */
+void sio_send(u8_t c, sio_fd_t fd) {
+  /* USER CODE BEGIN 8 */
+  /* USER CODE END 8 */
 }
 
 /**
@@ -203,18 +202,18 @@ void sio_send(u8_t c, sio_fd_t fd)
  * @param fd serial device handle
  * @param data pointer to data buffer for receiving
  * @param len maximum length (in bytes) of data to receive
- * @return number of bytes actually received - may be 0 if aborted by sio_read_abort
+ * @return number of bytes actually received - may be 0 if aborted by
+ * sio_read_abort
  *
  * @note This function will block until data can be received. The blocking
  * can be cancelled by calling sio_read_abort().
  */
-u32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len)
-{
+u32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len) {
   u32_t recved_bytes;
 
-/* USER CODE BEGIN 9 */
+  /* USER CODE BEGIN 9 */
   recved_bytes = 0; // dummy code
-/* USER CODE END 9 */
+                    /* USER CODE END 9 */
   return recved_bytes;
 }
 
@@ -227,14 +226,12 @@ u32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len)
  * @param len maximum length (in bytes) of data to receive
  * @return number of bytes actually received
  */
-u32_t sio_tryread(sio_fd_t fd, u8_t *data, u32_t len)
-{
+u32_t sio_tryread(sio_fd_t fd, u8_t *data, u32_t len) {
   u32_t recved_bytes;
 
-/* USER CODE BEGIN 10 */
+  /* USER CODE BEGIN 10 */
   recved_bytes = 0; // dummy code
-/* USER CODE END 10 */
+                    /* USER CODE END 10 */
   return recved_bytes;
 }
 #endif /* MDK ARM Compiler */
-
diff --git a/LWIP/App/lwip.h b/LWIP/App/lwip.h
index cea016b..33183e3 100644
--- a/LWIP/App/lwip.h
+++ b/LWIP/App/lwip.h
@@ -42,6 +42,44 @@
 
 /* USER CODE BEGIN 0 */
 
+/**
+ * is_multicast_ethaddr - Determine if the Ethernet address is a multicast.
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Return true if the address is a multicast address.
+ * By definition the broadcast address is also a multicast address.
+ */
+static inline int is_multicast_ethaddr(const uint8_t *addr)
+{
+	return 0x01 & addr[0];
+}
+
+/**
+ * is_zero_ethaddr - Determine if give Ethernet address is all zeros.
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Return true if the address is all zeroes.
+ */
+static inline int is_zero_ethaddr(const uint8_t *addr)
+{
+	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+}
+
+/*
+ * is_valid_ethaddr - Determine if the given Ethernet address is valid
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
+ * a multicast address, and is not FF:FF:FF:FF:FF:FF.
+ *
+ * Return true if the address is valid.
+ */
+static inline int is_valid_ethaddr(const uint8_t *addr)
+{
+	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
+	 * explicitly check for it here. */
+	return !is_multicast_ethaddr(addr) && !is_zero_ethaddr(addr);
+}
 /* USER CODE END 0 */
 
 /* Global Variables ----------------------------------------------------------*/
diff --git a/LWIP/Target/ethernetif.c b/LWIP/Target/ethernetif.c
index eb359ab..76e2515 100644
--- a/LWIP/Target/ethernetif.c
+++ b/LWIP/Target/ethernetif.c
@@ -178,6 +178,8 @@ void HAL_ETH_ErrorCallback(ETH_HandleTypeDef *handlerEth)
  * @param netif the already initialized lwip network interface structure
  *        for this ethernetif
  */
+extern uint8_t mac_address[6];
+
 static void low_level_init(struct netif *netif)
 {
   HAL_StatusTypeDef hal_eth_init_status = HAL_OK;
@@ -191,12 +193,12 @@ static void low_level_init(struct netif *netif)
 
   uint8_t MACAddr[6] ;
   heth.Instance = ETH;
-  MACAddr[0] = MAC_ADDR0;
-  MACAddr[1] = MAC_ADDR1;
-  MACAddr[2] = MAC_ADDR2;
-  MACAddr[3] = MAC_ADDR3;
-  MACAddr[4] = MAC_ADDR4;
-  MACAddr[5] = MAC_ADDR5;
+  MACAddr[0] = mac_address[0];
+  MACAddr[1] = mac_address[1];
+  MACAddr[2] = mac_address[2];
+  MACAddr[3] = mac_address[3];
+  MACAddr[4] = mac_address[4];
+  MACAddr[5] = mac_address[5];
   heth.Init.MACAddr = &MACAddr[0];
   heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
   heth.Init.TxDesc = DMATxDscrTab;
diff --git a/Makefile b/Makefile
index 63b64b9..27a503a 100644
--- a/Makefile
+++ b/Makefile
@@ -13,7 +13,7 @@
 #####################################
 # stm32 toolchain
 #####################################
-GCC_PATH = /home/xxbringup/dvb/gcc-arm-none-eabi-10.3-2021.10/bin
+GCC_PATH = /IBU_8T/IBU_SOFTWARE/bringup/tools/gcc-arm-none-eabi-10.3-2021.10/bin
 
 
 ######################################
@@ -49,6 +49,7 @@ Core/Src/hf_common.c \
 Core/Src/hf_power_process.c \
 Core/Src/hf_http_process.c \
 Core/Src/hf_gpio_process.c \
+Core/Src/hf_protocol_process.c \
 Core/Src/protocol_lib/ringbuffer.c \
 Core/Src/protocol_lib/protocol.c \
 Core/Src/hf_i2c.c \
-- 
2.25.1

