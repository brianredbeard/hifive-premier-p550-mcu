From 53e5c43a351f9f9bb23802f23e72cf6bd9cb6975 Mon Sep 17 00:00:00 2001
From: xuxiang <xuxiang@eswincomputing.com>
Date: Wed, 8 May 2024 17:53:46 +0800
Subject: [PATCH 012/109] WIN2030-15328:feat: spi slv read/write 32,fix product
 test

Changelogs:
1. spi slv read/write 32
2. fix product test uart protocol bug, read/write rtc, fan control, spi slv read/write
3.Move the uart4 , uart6 init/deinit  function to som_reset_control

Change-Id: I2819a3fb6265f734cb76c8c319322ca20b20797d
---
 Core/Inc/hf_spi_slv.h            |  25 +++
 Core/Src/hf_board_init.c         |  71 +------
 Core/Src/hf_i2c.c                |   2 -
 Core/Src/hf_it_callback.c        |   2 +
 Core/Src/hf_power_process.c      |  16 +-
 Core/Src/hf_protocol_process.c   | 302 ++++++++++++++++++-----------
 Core/Src/hf_spi_slv.c            | 317 +++++++++++++++++++++++++++++++
 Core/Src/main.c                  |  28 +--
 Core/Src/protocol_lib/protocol.c |  19 +-
 Core/Src/protocol_lib/protocol.h |  11 +-
 Core/Src/stm32f4xx_it.c          |  16 ++
 Makefile                         |   1 +
 12 files changed, 588 insertions(+), 222 deletions(-)
 create mode 100644 Core/Inc/hf_spi_slv.h
 create mode 100644 Core/Src/hf_spi_slv.c

diff --git a/Core/Inc/hf_spi_slv.h b/Core/Inc/hf_spi_slv.h
new file mode 100644
index 0000000..86c91d0
--- /dev/null
+++ b/Core/Inc/hf_spi_slv.h
@@ -0,0 +1,25 @@
+#ifndef __HF_SPI_SLV_H
+#define __HF_SPI_SLV_H
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#define SPI2_FLASH_CS_LOW()                                                  \
+	do {                                                                     \
+		HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_RESET); \
+	} while (0);
+
+#define SPI2_FLASH_CS_HIGH()                                               \
+	do {                                                                   \
+		HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_SET); \
+	} while (0);
+
+int es_spi_write(unsigned char *buf, unsigned long addr, int len);
+int es_spi_read(unsigned char *dst, unsigned long src, int len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HF_SPI_SLV_H */
diff --git a/Core/Src/hf_board_init.c b/Core/Src/hf_board_init.c
index c23bf22..fc07ee9 100644
--- a/Core/Src/hf_board_init.c
+++ b/Core/Src/hf_board_init.c
@@ -141,7 +141,7 @@ int board_init(void)
 	MX_RNG_Init();
 	// MX_TIM5_Init();
 	/* There is leakage, the som must be released before initialization */
-	MX_UART4_Init();
+	// MX_UART4_Init();
 	// MX_USART6_UART_Init();
 
 	/* To ensure that the i2c runs properly, initialize the som after it is powered on */
@@ -302,69 +302,6 @@ static void MX_RTC_Init(void)
 	if (HAL_RTC_Init(&hrtc) != HAL_OK) {
 		Error_Handler();
 	}
-
-	/** Initialize RTC and set the Time and Date */
-	// RTC_TimeTypeDef sTime = {0};
-	// sTime.Hours = 18;
-	// sTime.Minutes = 8;
-	// sTime.Seconds = 0;
-	// sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
-	// sTime.StoreOperation = RTC_STOREOPERATION_SET;
-	// if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
-	// {
-	//   Error_Handler();
-	// }
-	// RTC_DateTypeDef sDate = {0};
-	// sDate.WeekDay = RTC_WEEKDAY_WEDNESDAY;
-	// sDate.Month = RTC_MONTH_APRIL;
-	// sDate.Date = 3;
-	// sDate.Year = 24;
-
-	// if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
-	// {
-	//   Error_Handler();
-	// }
-
-	// /** Enable the Alarm A */
-	// RTC_AlarmTypeDef sAlarm = {0};
-	// sAlarm.AlarmTime.Hours = 0x0;
-	// sAlarm.AlarmTime.Minutes = 0x0;
-	// sAlarm.AlarmTime.Seconds = 0x30;
-	// sAlarm.AlarmTime.SubSeconds = 0x0;
-	// sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
-	// sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
-	// sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
-	// sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
-	// sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
-	// sAlarm.AlarmDateWeekDay = 0x1;
-	// sAlarm.Alarm = RTC_ALARM_A;
-	// if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
-	// {
-	//   Error_Handler();
-	// }
-
-	// /** Enable the Alarm B */
-	// sAlarm.AlarmTime.Hours = 0;
-	// sAlarm.AlarmTime.Minutes = 0x0;
-	// sAlarm.AlarmTime.Seconds = 0x40;
-	// sAlarm.AlarmTime.SubSeconds = 0x0;
-	// sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
-	// sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
-	// sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
-	// sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
-	// sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
-	// sAlarm.AlarmDateWeekDay = 0x1;
-	// sAlarm.Alarm = RTC_ALARM_B;
-	// if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
-	// {
-	//   Error_Handler();
-	// }
-
-	// /** Enable the WakeUp */
-	// if (HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, 10, RTC_WAKEUPCLOCK_RTCCLK_DIV16) != HAL_OK)
-	// {
-	//   Error_Handler();
-	// }
 }
 
 /**
@@ -407,7 +344,7 @@ static void MX_SPI2_Init(void)
 	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 	hspi2.Init.NSS = SPI_NSS_SOFT;
-	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
+	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
@@ -577,6 +514,8 @@ static void MX_UART4_Init(void)
 	if (HAL_UART_Init(&huart4) != HAL_OK) {
 		Error_Handler();
 	}
+	// HAL_NVIC_SetPriority(UART4_IRQn, 5, 0);
+	// HAL_NVIC_EnableIRQ(UART4_IRQn);
 }
 
 /**
@@ -619,6 +558,8 @@ static void MX_USART6_UART_Init(void)
 	if (HAL_UART_Init(&huart6) != HAL_OK) {
 		Error_Handler();
 	}
+	HAL_NVIC_SetPriority(USART6_IRQn, 5, 0);
+	HAL_NVIC_EnableIRQ(USART6_IRQn);
 }
 
 /**
diff --git a/Core/Src/hf_i2c.c b/Core/Src/hf_i2c.c
index c1a43dc..19f5a4a 100644
--- a/Core/Src/hf_i2c.c
+++ b/Core/Src/hf_i2c.c
@@ -2,8 +2,6 @@
 #include "main.h"
 #include <stdio.h>
 
-extern void MX_I2C3_Init(void);
-
 int hf_i2c_reg_write(I2C_HandleTypeDef *hi2c, uint8_t slave_addr,
 					 uint8_t reg_addr, uint8_t *data_ptr)
 {
diff --git a/Core/Src/hf_it_callback.c b/Core/Src/hf_it_callback.c
index fcff0ac..a35cb29 100644
--- a/Core/Src/hf_it_callback.c
+++ b/Core/Src/hf_it_callback.c
@@ -109,6 +109,8 @@ void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
 			memset(UART4_RxBuf, 0, sizeof(UART4_RxBuf) / sizeof(uint8_t));
 			HAL_UARTEx_ReceiveToIdle_DMA(&huart4, UART4_RxBuf, sizeof(UART4_RxBuf));
 		}
+	} else if (huart->Instance == USART6) {
+		printf("%s UART6\n", __func__);
 	}
 }
 
diff --git a/Core/Src/hf_power_process.c b/Core/Src/hf_power_process.c
index b66fc8f..dca8cea 100644
--- a/Core/Src/hf_power_process.c
+++ b/Core/Src/hf_power_process.c
@@ -7,8 +7,9 @@
 /* Private includes ----------------------------------------------------------*/
 #include "hf_common.h"
 #include "hf_i2c.h"
+#include "hf_spi_slv.h"
 /* Private typedef -----------------------------------------------------------*/
- #define AUTO_BOOT
+// #define AUTO_BOOT
 /* Private define ------------------------------------------------------------*/
 #define ATX_POWER_GOOD GPIO_PIN_RESET
 #define ATX_POWER_FAIL GPIO_PIN_SET
@@ -85,6 +86,7 @@ void hf_power_task(void *parameter)
 			// 	break;
 			// }
 			som_reset_control(pdFALSE);
+			SPI2_FLASH_CS_HIGH();
 			pmic_status_led_on(pdTRUE);
 			power_led_on(pdTRUE);
 			power_state = POWERON;
@@ -100,7 +102,6 @@ void hf_power_task(void *parameter)
 		case STOP_POWER:
 			printf("STOP_POWER\r\n");
 			i2c_deinit(I2C3);
-
 			pmic_power_on(pdFALSE);
 			atx_power_on(pdFALSE);
 			pmic_status_led_on(pdFALSE);
@@ -191,13 +192,6 @@ static void pmic_status_led_on(uint8_t turnon)
  * @param  reset pdTRUE : reset; pdFALSE : release
  * @retval None
  */
-// HAL_GPIO_WritePin(MCU_RESET_SOM_N_GPIO_Port,
-// MCU_RESET_SOM_N_Pin, GPIO_PIN_SET); GPIO_InitTypeDef
-// GPIO_InitStruct = {0}; GPIO_InitStruct.Pin =
-// MCU_RESET_SOM_N_Pin; GPIO_InitStruct.Pull = GPIO_NOPULL;
-// GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
-// GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
-// HAL_GPIO_Init(MCU_RESET_SOM_N_GPIO_Port, &GPIO_InitStruct);
 static void som_reset_control(uint8_t reset)
 {
 	GPIO_InitTypeDef GPIO_InitStruct = {0};
@@ -208,6 +202,8 @@ static void som_reset_control(uint8_t reset)
 		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 		HAL_GPIO_Init(MCU_RESET_SOM_N_GPIO_Port, &GPIO_InitStruct);
 		HAL_GPIO_WritePin(MCU_RESET_SOM_N_GPIO_Port, MCU_RESET_SOM_N_Pin, GPIO_PIN_RESET);
+		uart_deinit(UART4);
+		uart_deinit(USART6);
 	} else {
 		HAL_GPIO_WritePin(MCU_RESET_SOM_N_GPIO_Port, MCU_RESET_SOM_N_Pin, GPIO_PIN_SET);
 		GPIO_InitStruct.Pin = MCU_RESET_SOM_N_Pin;
@@ -215,6 +211,8 @@ static void som_reset_control(uint8_t reset)
 		GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 		HAL_GPIO_Init(MCU_RESET_SOM_N_GPIO_Port, &GPIO_InitStruct);
+		uart_init(UART4);
+		uart_init(USART6);
 	}
 }
 
diff --git a/Core/Src/hf_protocol_process.c b/Core/Src/hf_protocol_process.c
index 993e975..a044476 100644
--- a/Core/Src/hf_protocol_process.c
+++ b/Core/Src/hf_protocol_process.c
@@ -1,11 +1,11 @@
+#include "FreeRTOS.h"
 #include "cmsis_os2.h"
 #include "hf_common.h"
+#include "list.h"
 #include "main.h"
 #include "protocol.h"
 #include "stm32f4xx.h"
 #include "stm32f4xx_hal.h"
-#include "FreeRTOS.h"
-#include "list.h"
 #include "task.h"
 
 #define head_meg "\xA5\x5A\xAA\x55"
@@ -18,7 +18,7 @@ extern uint8_t netmask_address[4];
 extern uint8_t getway_address[4];
 extern uint8_t mac_address[6];
 
-void es_send_req(b_frame_class_t *pframe, uint8_t req_cmd, int8_t *frame_data, uint8_t len)
+void es_send_req(b_frame_class_t *pframe,uint8_t req_cmd, int8_t *frame_data,uint8_t len)
 {
 	uint8_t buf[MAX_FRAME_LEN] = {0};
 	uint8_t b_len, xor = 0;
@@ -48,6 +48,7 @@ void es_send_req(b_frame_class_t *pframe, uint8_t req_cmd, int8_t *frame_data, u
 int32_t es_set_gpio(struct gpio_cmd *gpio)
 {
 	GPIO_TypeDef *gpio_group;
+	gpio->group >>= 8;
 	GPIO_InitTypeDef GPIO_InitStruct = {0};
 	if (gpio->group == 0)
 		gpio_group = GPIOA;
@@ -69,7 +70,6 @@ int32_t es_set_gpio(struct gpio_cmd *gpio)
 		gpio_group = GPIOI;
 	else
 		return HAL_ERROR;
-	// printf("%s %d\n", __func__, __LINE__);
 
 	HAL_GPIO_WritePin(gpio_group, gpio->pin_num, gpio->value);
 
@@ -89,7 +89,7 @@ int32_t es_set_eth(struct ip_t *ip, struct netmask_t *netmask, struct getway_t *
 		ip_address[2] = ip->ip_addr2;
 		ip_address[3] = ip->ip_addr3;
 		// printf("IP_ADDR0:%d IP_ADDR1: %d IP_ADDR2: %d IP_ADDR3 %d\n", \
-			// ip_address[0], ip_address[1], ip_address[2], ip_address[3]);
+		// 	ip_address[0], ip_address[1], ip_address[2], ip_address[3]);
 	}
 	if (netmask != NULL) {
 		netmask_address[0] = netmask->netmask_addr0;
@@ -105,17 +105,7 @@ int32_t es_set_eth(struct ip_t *ip, struct netmask_t *netmask, struct getway_t *
 		getway_address[2] = gw->getway_addr2;
 		getway_address[3] = gw->getway_addr3;
 		// printf("GETWAY_ADDR0:%d GETWAY_ADDR1: %dGETWAY_ADDR2: %d GETWAY_ADDR3 %d\n",
-			// getway_address[0], getway_address[1], getway_address[2], getway_address[3]);
-	}
-	if (mac != NULL) {
-		mac_address[0] = mac->eth_mac_addr0;
-		mac_address[1] = mac->eth_mac_addr1;
-		mac_address[2] = mac->eth_mac_addr2;
-		mac_address[3] = mac->eth_mac_addr3;
-		mac_address[4] = mac->eth_mac_addr4;
-		mac_address[5] = mac->eth_mac_addr5;
-		// printf("GETWAY_ADDR0:%d GETWAY_ADDR1: %dGETWAY_ADDR2: %d GETWAY_ADDR3 %d\n",
-			// getway_address[0], getway_address[1], getway_address[2], getway_address[3]);
+		// getway_address[0], getway_address[1], getway_address[2], getway_address[3]);
 	}
 	extern void dynamic_change_eth(void);
 	dynamic_change_eth();
@@ -125,13 +115,14 @@ int32_t es_set_eth(struct ip_t *ip, struct netmask_t *netmask, struct getway_t *
 int32_t es_set_rtc_date(struct rtc_date_t *sdate)
 {
 	RTC_DateTypeDef sDate = {0};
-	sDate.Year = sdate->Year - 2000;
+	uint16_t year =  (sdate->Year >> 8) | (sdate->Year && 0xff) << 8;
+	sDate.Year = year - 2000;
 	sDate.Month = sdate->Month;
 	sDate.Date = sdate->Date;
 	sDate.WeekDay = sdate->WeekDay;
 
-	// printf("yy/mm/dd  %02d/%02d/%02d\r\n", sDate.Year, sDate.Month, sDate.Date);
-	if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
+	// printf("yy/mm/dd  %04d/%02d/%02d %02d\r\n", sDate.Year + 2000, sDate.Month, sDate.Date,sDate.WeekDay);
+	if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 		return HAL_ERROR;
 	return HAL_OK;
 }
@@ -144,7 +135,8 @@ int32_t es_set_rtc_time(struct rtc_time_t *stime)
 	sTime.Seconds = stime->Seconds;
 	sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 	sTime.StoreOperation = RTC_STOREOPERATION_SET;
-	if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
+	// printf("%s hh:mm:ss %02d:%02d:%02d\r\n", __func__, sTime.Hours, sTime.Minutes,sTime.Seconds);
+	if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 		return HAL_ERROR;
 	return HAL_OK;
 }
@@ -152,7 +144,10 @@ int32_t es_set_rtc_time(struct rtc_time_t *stime)
 int32_t es_get_rtc_date(struct rtc_date_t *sdate)
 {
 	RTC_DateTypeDef GetData;
-	if (HAL_RTC_GetDate(&hrtc, &GetData, RTC_FORMAT_BCD) != HAL_OK)
+	RTC_TimeTypeDef GetTime;
+	if (HAL_RTC_GetTime(&hrtc, &GetTime, RTC_FORMAT_BIN) != HAL_OK)
+		return HAL_ERROR;
+	if (HAL_RTC_GetDate(&hrtc, &GetData, RTC_FORMAT_BIN) != HAL_OK)
 		return HAL_ERROR;
 	// printf("yy/mm/dd  %02d/%02d/%02d\r\n", 2000 + GetData.Year, GetData.Month, GetData.Date);
 	sdate->Year = 2000 + GetData.Year;
@@ -165,12 +160,16 @@ int32_t es_get_rtc_date(struct rtc_date_t *sdate)
 int32_t es_get_rtc_time(struct rtc_time_t *stime)
 {
 	RTC_TimeTypeDef GetTime;
-	if (HAL_RTC_GetTime(&hrtc, &GetTime, RTC_FORMAT_BCD) != HAL_OK)
+	RTC_DateTypeDef GetData;
+
+	if (HAL_RTC_GetTime(&hrtc, &GetTime, RTC_FORMAT_BIN) != HAL_OK)
+		return HAL_ERROR;
+	if (HAL_RTC_GetDate(&hrtc, &GetData, RTC_FORMAT_BIN) != HAL_OK)
 		return HAL_ERROR;
-	// printf(" hh:mm:ss %02d:%02d:%02d\r\n", GetTime.Hours, GetTime.Minutes, GetTime.Seconds);
 	stime->Hours = GetTime.Hours;
 	stime->Minutes = GetTime.Minutes;
 	stime->Seconds = GetTime.Seconds;
+	// printf("%s hh:mm:ss %02d:%02d:%02d\r\n", __func__, stime->Hours, stime->Minutes, stime->Seconds);
 	return HAL_OK;
 }
 
@@ -181,40 +180,40 @@ uint32_t fan1_duty = 0;
 int32_t es_set_fan_duty(struct fan_control_t *fan)
 {
 	TIM_OC_InitTypeDef sConfigOC = {0};
-	if(fan->duty > 100)
+	if (fan->duty > 100)
 		return HAL_ERROR;
 
 	if (fan->fan_num == 0) {
 		if (HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_1) != HAL_OK)
 			return HAL_ERROR;
 
-		fan0_duty = fan->duty;
 		sConfigOC.OCMode = TIM_OCMODE_PWM1;
-		sConfigOC.Pulse = fan->duty*pwm_period/100;
+		sConfigOC.Pulse = fan->duty * pwm_period / 100;
 		sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 		sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 		if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 			return HAL_ERROR;
-
 		if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1) != HAL_OK)
 			return HAL_ERROR;
+		fan0_duty = fan->duty;
 	} else if (fan->fan_num == 1) {
 		if (HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_2) != HAL_OK)
 			return HAL_ERROR;
 
-		fan1_duty = fan->duty;
 		sConfigOC.OCMode = TIM_OCMODE_PWM1;
-		sConfigOC.Pulse = fan->duty*pwm_period/100;
+		sConfigOC.Pulse = fan->duty * pwm_period / 100;
 		sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 		sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 		if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 			return HAL_ERROR;
-
 		if (HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2) != HAL_OK)
 			return HAL_ERROR;
+		fan1_duty = fan->duty;
 	} else {
 		return HAL_ERROR;
 	}
+	// printf("fan0_duty %d\n",fan0_duty);
+	// printf("fan1_duty %d\n",fan1_duty);
 	return HAL_OK;
 }
 
@@ -230,90 +229,183 @@ int32_t es_get_fan_duty(struct fan_control_t *fan)
 	return HAL_OK;
 }
 
+void big2little(uint8_t *cmd, uint64_t addr, uint8_t len)
+{
+	if(len == 4)
+	{
+		cmd[3] = (addr & 0xff);
+		cmd[2] = ((addr >> 8) & 0xff);
+		cmd[1] = ((addr >> 16) & 0xff);
+		cmd[0] = ((addr >> 24) & 0xff);
+	}
+	else if(len == 8){
+		cmd[7] = (addr & 0xff);
+		cmd[6] = ((addr >> 8) & 0xff);
+		cmd[5] = ((addr >> 16) & 0xff);
+		cmd[4] = ((addr >> 24) & 0xff);
+		cmd[3] = ((addr >> 32) & 0xff);
+		cmd[2] = ((addr >> 40) & 0xff);
+		cmd[1] = ((addr >> 48) & 0xff);
+		cmd[0] = ((addr >> 56) & 0xff);
+	}
+}
+
+void little2big(uint8_t *cmd, uint64_t addr, uint8_t len)
+{
+	if(len == 4)
+	{
+		cmd[0] = (addr & 0xff);
+		cmd[1] = ((addr >> 8) & 0xff);
+		cmd[2] = ((addr >> 16) & 0xff);
+		cmd[3] = ((addr >> 24) & 0xff);
+	}
+	else if(len == 8){
+		cmd[0] = (addr & 0xff);
+		cmd[1] = ((addr >> 8) & 0xff);
+		cmd[2] = ((addr >> 16) & 0xff);
+		cmd[3] = ((addr >> 24) & 0xff);
+		cmd[4] = ((addr >> 32) & 0xff);
+		cmd[5] = ((addr >> 40) & 0xff);
+		cmd[6] = ((addr >> 48) & 0xff);
+		cmd[7] = ((addr >> 56) & 0xff);
+	}
+}
+
+int32_t es_spi_wl(struct spi_slv_w32_t *spi)
+{
+	uint32_t addr = 0;
+	uint32_t value = 0;
+	big2little(&addr, spi->addr, 4);
+	big2little(&value, spi->value, 4);
+	// printf("%s %d addr %lx val %lx\n",__func__,__LINE__, addr, value);
+	return es_spi_write(&value, addr, 4);
+}
+
+int32_t es_spi_rl32(struct spi_slv_w32_t *spi)
+{
+	uint32_t addr=0, value=0;
+	int32_t ret = 0;
+	big2little(&addr, spi->addr, 4);
+	ret = eswin_rx(&value, addr, 4);
+	little2big(&spi->value, value,4);
+	return ret;
+}
 
+
+typedef enum req_type { REQ_OK = 0x0, REQ_FAIL = 0x1, REQ_OTHER } req_type_t;
 void es_process_cmd(b_frame_class_t *pframe)
 {
 	uint8_t cmd = pframe->frame.cmd;
-	// printf("%s %d cmd %x\n", __func__, __LINE__, cmd);
+	uint8_t req_type = REQ_FAIL;
 	switch (cmd) {
 	case CMD_EEPROM_WP:
-		es_eeprom_wp(pframe->frame.data.value);
-		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == sizeof(uint8_t)) {
+			es_eeprom_wp(pframe->frame.data.value);
+			req_type = REQ_OK;
+		}
 		break;
 	case CMD_GPIO:
-		if (es_set_gpio(&pframe->frame.data.gpio) != HAL_OK)
-			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
-		else
-			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == (sizeof(struct gpio_cmd))) {
+			if (es_set_gpio(&pframe->frame.data.gpio) == HAL_OK)
+				req_type = REQ_OK;
+		}
 		break;
 	case CMD_SET_IP:
-		es_set_eth(&pframe->frame.data.ip, NULL, NULL, NULL);
-		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == sizeof(struct ip_t)) {
+			es_set_eth(&pframe->frame.data.ip, NULL, NULL, NULL);
+			req_type = REQ_OK;
+		}
 		break;
 	case CMD_SET_NETMASK:
-		es_set_eth(NULL, &pframe->frame.data.netmask, NULL, NULL);
-		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == sizeof(struct netmask_t)) {
+			es_set_eth(NULL, &pframe->frame.data.netmask, NULL, NULL);
+			req_type = REQ_OK;
+		}
 		break;
 	case CMD_SET_GATWAY:
-		es_set_eth(NULL, NULL, &pframe->frame.data.getway, NULL);
-		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
-		break;
-	case CMD_SET_MAC:
-		es_set_eth(NULL, NULL, NULL, &pframe->frame.data.mac);
-		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == sizeof(struct getway_t)) {
+			es_set_eth(NULL, NULL, &pframe->frame.data.getway, NULL);
+			req_type = REQ_OK;
+		}
 		break;
 	case CMD_SET_DATE:
-		if (es_set_rtc_date(&pframe->frame.data.rtc_date) != HAL_OK)
-			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
-		else
-			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == (sizeof(struct rtc_date_t) - 1)) {
+			if (es_set_rtc_date(&pframe->frame.data.rtc_date) == HAL_OK)
+				req_type = REQ_OK;
+		}
 		break;
 	case CMD_SET_TIME:
-		if (es_set_rtc_time(&pframe->frame.data.rtc_date) != HAL_OK)
-			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
-		else
-			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == sizeof(struct rtc_time_t)) {
+			if (es_set_rtc_time(&pframe->frame.data.rtc_date) == HAL_OK)
+				req_type = REQ_OK;
+		}
 		break;
 	case CMD_SET_FAN_DUTY:
-		if (es_set_fan_duty(&pframe->frame.data.fan) != HAL_OK)
-			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
-		else
-			es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+		if (pframe->frame.len == sizeof(struct fan_control_t)) {
+			if (es_set_fan_duty(&pframe->frame.data.fan) == HAL_OK)
+				req_type = REQ_OK;
+		}
+		break;
+	case CMD_SPI_SLV_WL:
+		if (pframe->frame.len == sizeof(struct spi_slv_w32_t)) {
+			if (es_spi_wl(&pframe->frame.data.spislv32) == HAL_OK)
+				req_type = REQ_OK;
+		}
 		break;
 	case CMD_GET_DATE:
-		if (es_get_rtc_date(&pframe->frame.data.rtc_date) != HAL_OK)
-			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
-		else
-			es_send_req(pframe, CMD_GET_DATE, &pframe->frame.data.rtc_date, sizeof(struct rtc_date_t));
+		if (pframe->frame.len == 0) {
+			if (es_get_rtc_date(&pframe->frame.data.rtc_date) == HAL_OK)
+			{
+				es_send_req(pframe, CMD_GET_DATE, &pframe->frame.data.rtc_date, sizeof(struct rtc_date_t));
+				req_type = REQ_OTHER;
+			}
+		}
 		// printf("yy/mm/dd  %02d/%02d/%02d %02d\r\n", 2000 + pframe->frame.data.rtc_date.Year, pframe->frame.data.rtc_date.Month, \
 				pframe->frame.data.rtc_date.Date, pframe->frame.data.rtc_date.WeekDay);
 		break;
 	case CMD_GET_TIME:
-		if (es_get_rtc_time(&pframe->frame.data.rtc_time) != HAL_OK)
-			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
-		else
-			es_send_req(pframe, CMD_GET_TIME, &pframe->frame.data.rtc_time, sizeof(struct rtc_time_t));
+		if (pframe->frame.len == 0) {
+			if (es_get_rtc_time(&pframe->frame.data.rtc_time) == HAL_OK) {
+				es_send_req(pframe, CMD_GET_TIME, &pframe->frame.data.rtc_time, sizeof(struct rtc_time_t));
+				req_type = REQ_OTHER;
+			}
+		}
 		// printf(" hh:mm:ss %02d:%02d:%02d\r\n", pframe->frame.data.rtc_time.Hours,\
 						pframe->frame.data.rtc_time.Minutes, pframe->frame.data.rtc_time.Seconds);
 		break;
 	case CMD_GET_FAN_DUTY:
-		if (es_get_fan_duty(&pframe->frame.data.fan) != HAL_OK)
-			es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
-		else
-			es_send_req(pframe, CMD_GET_FAN_DUTY, &pframe->frame.data.fan, sizeof(struct fan_control_t));
+		printf("len %xuint8_t\n",pframe->frame.len);
+		if (pframe->frame.len == sizeof(uint8_t)) {
+			if (es_get_fan_duty(&pframe->frame.data.fan) == HAL_OK){
+				es_send_req(pframe, CMD_GET_FAN_DUTY, &pframe->frame.data.fan, sizeof(struct fan_control_t));
+				req_type = REQ_OTHER;
+			}
+		}
+		break;
+	case CMD_SPI_SLV_RL:
+		if (pframe->frame.len == sizeof(uint32_t)) {
+			if (es_spi_rl32(&pframe->frame.data.spislv32) == HAL_OK) {
+				es_send_req(pframe, CMD_SPI_SLV_RL, &pframe->frame.data.spislv32.value, sizeof(uint32_t));
+				req_type = REQ_OTHER;
+			}
+		}
 		break;
 	default:;
 		break;
 	}
+	if (req_type == REQ_OK)
+		es_send_req(pframe, CMD_RES, req_ok, sizeof(req_ok) - 1);
+	else if (req_type == REQ_FAIL)
+		es_send_req(pframe, CMD_RES, req_fail, sizeof(req_fail) - 1);
 }
 
 uint32_t RxBuf_SIZE = 64;
 uint8_t RxBuf[96];
 b_frame_class_t frame_uart3;
-void deamon_test(void);
 void protocol_task(void *argument)
 {
 	// printf("%s %d\n", __func__, __LINE__);
+	uint8_t protocol_status = 0;
 	b_frame_t frame_info;
 	frame_info.head = head_meg;
 	frame_info.head_len = sizeof(head_meg) - 1;
@@ -325,8 +417,6 @@ void protocol_task(void *argument)
 	es_frame_init(&frame_uart3, &frame_info);
 	/* enable uart3 dma rx */
 	HAL_UARTEx_ReceiveToIdle_DMA(frame_uart3.uart, RxBuf, RxBuf_SIZE);
-
-	uint8_t protocol_status = 0;
 	for (;;) {
 		deamon_test();
 		switch (protocol_status) {
@@ -364,8 +454,8 @@ void protocol_task(void *argument)
 	}
 }
 
-#define FRAME_HEADER    0xA55AAA55
-#define FRAME_TAIL      0xBDBABDBA
+#define FRAME_HEADER 0xA55AAA55
+#define FRAME_TAIL 0xBDBABDBA
 
 uint8_t UART4_RxBuf[sizeof(Message)];
 b_frame_class_t frame_uart4;
@@ -381,13 +471,13 @@ typedef enum {
 
 void dump_message(Message data)
 {
-	printf("Header: 0x%lX, Cmd Type: 0x%x, Data Len: %d, Checksum: 0x%X, Tail: 0x%lx\n",
-		data.header, data.cmd_type, data.data_len, data.checksum, data.tail);
+	printf("Header: 0x%lX, Cmd Type: 0x%x, Data Len: %d, Checksum: 0x%X, Tail: 0x%lx\n", data.header, data.cmd_type,
+		   data.data_len, data.checksum, data.tail);
 }
 // Function to check message checksum
 int check_checksum(Message *msg)
 {
-	unsigned char checksum = 0;
+	uint8_t checksum = 0;
 	checksum ^= msg->msg_type;
 	checksum ^= msg->cmd_type;
 	checksum ^= msg->data_len;
@@ -399,7 +489,7 @@ int check_checksum(Message *msg)
 
 void generate_checksum(Message *msg)
 {
-	unsigned char checksum = 0;
+	uint8_t checksum = 0;
 	checksum ^= msg->msg_type;
 	checksum ^= msg->cmd_type;
 	checksum ^= msg->data_len;
@@ -415,12 +505,11 @@ BaseType_t transmit_deamon_request(Message *msg)
 
 	generate_checksum(msg);
 	// Transmit using DMA
-	HAL_StatusTypeDef status = HAL_UART_Transmit(huart, (uint8_t *)msg,
-			sizeof(Message), HAL_MAX_DELAY);
+	HAL_StatusTypeDef status = HAL_UART_Transmit(huart, (uint8_t *)msg, sizeof(Message), HAL_MAX_DELAY);
 	if (status == HAL_OK) {
 		return status; // Successful transmission
 	} else {
-		printf("[%s %d]:Failed to transmit msg, status %d!\n",__func__,__LINE__, status);
+		printf("[%s %d]:Failed to transmit msg, status %d!\n", __func__, __LINE__, status);
 		return status; // Transmission failed
 	}
 }
@@ -445,11 +534,11 @@ int web_cmd_handle(CommandType cmd, void *data, int data_len)
 	};
 
 	/*Add webcmd to waiting list*/
-		// Initialize list item
+	// Initialize list item
 	vListInitialiseItem(&(webcmd.xListItem));
-		// Set the list item owner
+	// Set the list item owner
 	listSET_LIST_ITEM_OWNER(&(webcmd.xListItem), &webcmd);
-		// Enter critical section to ensure thread safety when inserting item
+	// Enter critical section to ensure thread safety when inserting item
 	taskENTER_CRITICAL();
 	vListInsertEnd(&WebCmdList, &(webcmd.xListItem));
 	taskEXIT_CRITICAL();
@@ -484,24 +573,23 @@ void handle_deamon_mesage(Message *msg)
 		if (!listLIST_IS_EMPTY(&WebCmdList)) {
 			// Enter critical section to ensure thread safety when traversing and deleting
 			taskENTER_CRITICAL();
-			for (ListItem_t *pxItem = listGET_HEAD_ENTRY(&WebCmdList);
-				pxItem != listGET_END_MARKER(&WebCmdList);) {
-					WebCmd * pxWebCmd = (WebCmd *)listGET_LIST_ITEM_OWNER(pxItem);
-					// Get the next item before deleting the current one
-					ListItem_t *pxNextItem = listGET_NEXT(pxItem);
-					if ((uint32_t)pxWebCmd->xTaskToNotify == msg->xTaskToNotify) {
-						pxWebCmd->cmd_result = msg->cmd_result;
-						memcpy(pxWebCmd->data, msg->data, msg->data_len);
-						// Remove the current item from the list
-						uxListRemove(pxItem);
-						xTaskNotifyGive(pxWebCmd->xTaskToNotify);
-					}
-					// Move to the next item
-					pxItem = pxNextItem;
+			for (ListItem_t *pxItem = listGET_HEAD_ENTRY(&WebCmdList); pxItem != listGET_END_MARKER(&WebCmdList);) {
+				WebCmd *pxWebCmd = (WebCmd *)listGET_LIST_ITEM_OWNER(pxItem);
+				// Get the next item before deleting the current one
+				ListItem_t *pxNextItem = listGET_NEXT(pxItem);
+				if ((uint32_t)pxWebCmd->xTaskToNotify == msg->xTaskToNotify) {
+					pxWebCmd->cmd_result = msg->cmd_result;
+					memcpy(pxWebCmd->data, msg->data, msg->data_len);
+					// Remove the current item from the list
+					uxListRemove(pxItem);
+					xTaskNotifyGive(pxWebCmd->xTaskToNotify);
+				}
+				// Move to the next item
+				pxItem = pxNextItem;
 			}
 			taskEXIT_CRITICAL();
 		}
-	}else {
+	} else {
 		printf("Unsupport msg type: 0x%x\n", msg->cmd_type);
 		dump_message(*msg);
 	}
@@ -518,10 +606,10 @@ void deamon_test(void)
 
 	ret = web_cmd_handle(CMD_READ_BOARD_INFO, data, FRAME_DATA_MAX);
 
-	//pass
+	// pass
 	printf("call read borad info, result 0x%x, data %s\n", ret, data);
 	g_test_flag = 0;
-	return;//0 success,TODO call
+	return; // 0 success,TODO call
 }
 
 void uart4_protocol_task(void *argument)
@@ -539,14 +627,14 @@ void uart4_protocol_task(void *argument)
 	frame_uart4.uart = &huart4;
 	frame_uart4._in_frame_buffer_size = sizeof(UART4_RxBuf);
 
-	//Init msg ring buffer for deamon
+	// Init msg ring buffer for deamon
 	es_frame_init(&frame_uart4, &frame_info);
 	ring = &frame_uart4._frame_ring;
 
-	//Init web server msg list
+	// Init web server msg list
 	vListInitialise(&WebCmdList);
 
-	//trigger uart rx
+	// trigger uart rx
 	HAL_UARTEx_ReceiveToIdle_DMA(&huart4, UART4_RxBuf, sizeof(UART4_RxBuf));
 	for (;;) {
 		len = get_ring_buf_len(ring);
@@ -555,11 +643,9 @@ void uart4_protocol_task(void *argument)
 			continue;
 		}
 		if (len < sizeof(msg)) {
-
 		}
 		len = read_ring_buf(ring, (uint8_t *)&msg, sizeof(msg));
 		if (len != sizeof(msg)) {
-
 		}
 
 		if (msg.header == FRAME_HEADER && msg.tail == FRAME_TAIL) {
diff --git a/Core/Src/hf_spi_slv.c b/Core/Src/hf_spi_slv.c
new file mode 100644
index 0000000..a364a7e
--- /dev/null
+++ b/Core/Src/hf_spi_slv.c
@@ -0,0 +1,317 @@
+#include "main.h"
+#include <stdio.h>
+#include "hf_spi_slv.h"
+#include "stm32f4xx_hal.h"
+
+unsigned int get_regval(unsigned char reg);
+
+HAL_StatusTypeDef spi_transmit(uint8_t *pData, uint16_t Size)
+{
+	HAL_StatusTypeDef ret;
+	SPI2_FLASH_CS_LOW();
+	ret = HAL_SPI_Transmit(&hspi2, pData, Size, 0xff);
+	SPI2_FLASH_CS_HIGH();
+	return ret;
+}
+
+HAL_StatusTypeDef spi_transmit_recive(uint8_t *pSndData, uint16_t SndSize, uint8_t *pRcvData, uint16_t RcvSize)
+{
+	HAL_StatusTypeDef ret;
+	SPI2_FLASH_CS_LOW();
+	ret = HAL_SPI_Transmit(&hspi2, pSndData, SndSize, 0xff);
+	if (ret != HAL_OK) {
+		return ret;
+	}
+	ret = HAL_SPI_Receive(&hspi2, pRcvData, RcvSize, 0xff);
+	SPI2_FLASH_CS_HIGH();
+	return ret;
+}
+
+HAL_StatusTypeDef spi_recive(uint8_t *pData, uint16_t Size)
+{
+	HAL_StatusTypeDef ret;
+	SPI2_FLASH_CS_LOW();
+	ret = HAL_SPI_Receive(&hspi2, pData, Size, 0xff);
+	SPI2_FLASH_CS_HIGH();
+	return ret;
+}
+void spi_addr_cfg(unsigned char *cmd, unsigned long addr)
+{
+	cmd[5] = (addr & 0xff);
+	cmd[4] = ((addr >> 8) & 0xff);
+	cmd[3] = ((addr >> 16) & 0xff);
+	cmd[2] = ((addr >> 24) & 0xff);
+	cmd[1] = ((addr >> 32) & 0xff);
+	cmd[0] = ((addr >> 40) & 0xff);
+}
+
+void spi_data_cfg(unsigned char *cmd, unsigned char *data, int len)
+{
+	int i;
+	unsigned char xdata;
+	switch (len) {
+	case 1:
+		cmd[0] = data[0];
+		break;
+	case 2:
+	case 4:
+		for (i = 0; i < len; i++) {
+			cmd[i] = data[len - i - 1];
+		}
+		break;
+	case 32:
+		for (i = 0; i < len; i += 4) {
+			cmd[i] = data[i + 3];
+			cmd[i + 1] = data[i + 2];
+			cmd[i + 2] = data[i + 1];
+			cmd[i + 3] = data[i];
+		}
+		break;
+	}
+}
+
+int eswin_ww(unsigned long addr, unsigned int data)
+{
+	unsigned char sndBuf[32];
+	HAL_StatusTypeDef ret;
+	// AXI word write: cmd(1B)+addr(6B)+data(4B)
+	sndBuf[0] = 0x1;
+	spi_addr_cfg(&sndBuf[1], addr);
+	spi_data_cfg(&sndBuf[7], (unsigned char *)&data, 4);
+	ret = spi_transmit(sndBuf, 11);
+	return ret;
+}
+
+int eswin_wb(unsigned long addr, unsigned char data)
+{
+	int ret;
+	unsigned char sndBuf[32];
+
+	// AXI word write: cmd(1B)+addr(6B)+data(1B)
+	sndBuf[0] = 0xb;
+	spi_addr_cfg(&sndBuf[1], addr);
+	spi_data_cfg(&sndBuf[7], (unsigned char *)&data, 1);
+
+	ret = spi_transmit(sndBuf, 8);
+	return ret;
+}
+
+int eswin_wh(unsigned long addr, unsigned short data)
+{
+	int ret;
+	unsigned char sndBuf[32];
+
+	// AXI word write: cmd(1B)+addr(6B)+data(2B)
+	sndBuf[0] = 0x9;
+	spi_addr_cfg(&sndBuf[1], addr);
+	spi_data_cfg(&sndBuf[7], (unsigned char *)&data, 2);
+
+	ret = spi_transmit(sndBuf, 9);
+	return ret;
+}
+
+int eswin_burst_write(unsigned long addr, unsigned char *data)
+{
+	// AXI burst write: cmd(1B)+addr(6B)+data(32B)
+	int ret;
+	unsigned char sndBuf[39];
+
+	sndBuf[0] = 0x3;
+	spi_addr_cfg(&sndBuf[1], addr);
+	spi_data_cfg(&sndBuf[7], data, 32);
+	ret = spi_transmit(sndBuf, 39);
+	return ret;
+}
+
+
+
+void format_big_2_little(unsigned char *buf, int len)
+{
+	unsigned char data;
+	int left = len, i = 0;
+
+	if (len == 1)
+		return;
+
+	switch (len) {
+	case 2:
+	case 4:
+		for (i = 0; i < len / 2; i++) {
+			data = buf[i];
+			buf[i] = buf[len - i - 1];
+			buf[len - i - 1] = data;
+		}
+		break;
+	case 32:
+		for (i = 0; i < len; i += 4) {
+			data = buf[i];
+			buf[i] = buf[i + 3];
+			buf[i + 3] = data;
+			data = buf[i + 1];
+			buf[i + 1] = buf[i + 2];
+			buf[i + 2] = data;
+		}
+		break;
+	}
+}
+
+int spi_axi_read(unsigned char *rcvBuf, int len)
+{
+	int ret;
+	unsigned char sndBuf;
+
+	if (len == 1) {
+		sndBuf = 0x1a;
+	} else if (len == 2) {
+		sndBuf = 0x18;
+	} else if ((len == 4) || (len == 32)) {
+		sndBuf = 0x16;
+	}
+	ret = spi_transmit_recive(sndBuf, 1, rcvBuf, len);
+	return ret;
+}
+
+int eswin_rx(unsigned char *rcvBuf, unsigned long addr, int len)
+{
+	int ret, xlen, offset = 0;
+	unsigned char sndBuf[32];
+	unsigned int rvdata = 0;
+	printf("%s %x %x\n",__func__, addr, len);
+	while (len) {
+		if (len >= 32) {
+			sndBuf[0] = 0x2;
+			xlen = 32;
+			len -= 32;
+		} else if (len >= 4) {
+			sndBuf[0] = 0x0;
+			xlen = 4;
+			len -= 4;
+		} else if (len >= 2) {
+			sndBuf[0] = 0x0;
+			xlen = 2;
+			len -= 2;
+		} else {
+			sndBuf[0] = 0x0;
+			xlen = 1;
+			len -= 1;
+		}
+
+		spi_addr_cfg(&sndBuf[1], addr);
+		for(int i = 0; i<7; i++) {
+			printf("sndBuf[%d] %x\n", i, sndBuf[i]);
+		}
+		if (xlen == 1) {
+			sndBuf[7] = 0x1a;
+		} else if (xlen == 2) {
+			sndBuf[7] = 0x18;
+		} else if ((xlen == 4) || (xlen == 32)) {
+			sndBuf[7] = 0x16;
+		}
+		ret = spi_transmit(sndBuf, 7);
+		if (HAL_OK != ret) {
+			goto fail;
+		}
+		ret = spi_transmit_recive(&sndBuf[7], 1, rcvBuf + offset, xlen);
+		if (ret != HAL_OK) {
+			goto fail;
+		}
+		format_big_2_little(rcvBuf + offset, xlen);
+		addr += xlen;
+		offset += xlen;
+	}
+fail:
+	return ret;
+}
+
+int es_spi_writeb(unsigned long addr, unsigned char val)
+{
+	return eswin_wb(addr, val);
+}
+int es_spi_writew(unsigned long addr, unsigned short val)
+{
+	return eswin_wh(addr, val);
+}
+int es_spi_writel(unsigned long addr, unsigned int val)
+{
+	return eswin_ww(addr, val);
+}
+
+int es_spi_write(unsigned char *buf, unsigned long addr, int len)
+{
+	int xlen, offset = 0, ret;
+	printf("addr %x len %x\n",addr, len);
+	while (len) {
+		if (len >= 32) {
+			len -= 32;
+			xlen = 32;
+			ret = eswin_burst_write(addr, buf + offset);
+			if (ret)
+				goto fail;
+		} else if (len >= 4) {
+			xlen = 4;
+			len -= 4;
+			ret = es_spi_writel(addr, *(unsigned int *)(buf + offset));
+			if (ret)
+				goto fail;
+		} else if (len >= 2) {
+			xlen = 2;
+			len -= 2;
+			ret = es_spi_writew(addr, *(unsigned short *)(buf + offset));
+			if (ret)
+				goto fail;
+		} else {
+			xlen = 1;
+			len -= 1;
+			ret = es_spi_writeb(addr, *(buf + offset));
+			if (ret)
+				goto fail;
+		}
+
+		addr += xlen;
+		offset += xlen;
+	}
+fail:
+	return ret;
+}
+
+unsigned char es_spi_readb(unsigned long addr)
+{
+	unsigned char buf[1];
+	eswin_rx(buf, addr, 1);
+
+	return *buf;
+}
+
+unsigned short es_spi_readw(unsigned long addr)
+{
+	unsigned char buf[2];
+	eswin_rx(buf, addr, 2);
+
+	return *(unsigned short *)buf;
+}
+
+unsigned int es_spi_readl(unsigned long addr)
+{
+	unsigned char buf[4];
+	eswin_rx(buf, addr, 4);
+
+	return *(unsigned int *)buf;
+}
+
+int es_spi_read(unsigned char *dst, unsigned long src, int len)
+{
+	return eswin_rx(dst, src, len);
+}
+
+unsigned int get_regval(unsigned char reg)
+{
+	unsigned char sndBuf[2];
+	unsigned char rcvBuf[4];
+	int ret;
+	sndBuf[0] = 0x4;
+	sndBuf[1] = reg;
+	ret = spi_transmit_recive(sndBuf, 2, rcvBuf, 4);
+	format_big_2_little(rcvBuf,4);
+	// printf("reg %x 0x%08x\n",reg>>4,*(unsigned int *)rcvBuf);
+	return *(unsigned int *)rcvBuf;
+}
\ No newline at end of file
diff --git a/Core/Src/main.c b/Core/Src/main.c
index c0dd55d..4288aa2 100644
--- a/Core/Src/main.c
+++ b/Core/Src/main.c
@@ -170,7 +170,6 @@ void hf_main_task(void *argument)
   }
 }
 
-#if 0
 void fan_info(void)
 {
   if (HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1) != HAL_OK)
@@ -200,31 +199,18 @@ void get_rtc_info(void)
 {
   RTC_DateTypeDef GetData;
   RTC_TimeTypeDef GetTime;
-  HAL_RTC_GetTime(&hrtc, &GetTime, RTC_FORMAT_BCD);
+  HAL_RTC_GetTime(&hrtc, &GetTime, RTC_FORMAT_BIN);
   /* Get the RTC current Date */
-  HAL_RTC_GetDate(&hrtc, &GetData, RTC_FORMAT_BCD);
+  HAL_RTC_GetDate(&hrtc, &GetData, RTC_FORMAT_BIN);
 
   /* Display date Format : yy/mm/dd */
-  printf("yy/mm/dd  %02d/%02d/%02d\r\n",2000 + GetData.Year, GetData.Month, GetData.Date);
+  printf("%s yy/mm/dd  %02d/%02d/%02d\r\n", __func__, 2000 + GetData.Year, GetData.Month, GetData.Date);
   /* Display time Format : hh:mm:ss */
-  printf(" hh:mm:ss %02d:%02d:%02d\r\n",GetTime.Hours, GetTime.Minutes, GetTime.Seconds);
-
-  // RTC_AlarmTypeDef alarm1;
-  // RTC_AlarmTypeDef alarm2;
-  // HAL_RTC_GetAlarm(&hrtc, &alarm1, RTC_ALARM_A, RTC_FORMAT_BCD);
-  // HAL_RTC_GetAlarm(&hrtc, &alarm2, RTC_ALARM_B, RTC_FORMAT_BCD);
-  // printf("alarm1 info :\n");
-  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n",
-  //       alarm1.AlarmMask, alarm1.AlarmSubSecondMask, alarm1.AlarmDateWeekDaySel, alarm1.AlarmDateWeekDay, alarm1.Alarm );
-  // printf("%02d/%02d/%02d\r\n",alarm1.AlarmTime.Hours, alarm1.AlarmTime.Minutes, alarm1.AlarmTime.Seconds);
-
-  // printf("alarm2 info :\n");
-  // printf("AlarmMask %x, AlarmSubSecondMask %x, \n AlarmDateWeekDaySel %x, AlarmDateWeekDay %x, Alarm %x:\n",
-  //       alarm2.AlarmMask, alarm2.AlarmSubSecondMask, alarm2.AlarmDateWeekDaySel, alarm2.AlarmDateWeekDay, alarm2.Alarm );
-  // printf("%02d/%02d/%02d\r\n",alarm2.AlarmTime.Hours, alarm2.AlarmTime.Minutes, alarm2.AlarmTime.Seconds);
-  // printf("\r\n");
+  printf("%s hh:mm:ss %02d:%02d:%02d\r\n", __func__, GetTime.Hours, GetTime.Minutes, GetTime.Seconds);
+
+
 }
-#endif
+
 void MoniterTask(void *argument)
 {
   TaskStatus_t *StatusArray;
diff --git a/Core/Src/protocol_lib/protocol.c b/Core/Src/protocol_lib/protocol.c
index 6b265e7..b17de1b 100644
--- a/Core/Src/protocol_lib/protocol.c
+++ b/Core/Src/protocol_lib/protocol.c
@@ -1,10 +1,10 @@
 #include "protocol.h"
+#include <stdio.h>
 
 uint8_t es_frame_init(b_frame_class_t *pframe, b_frame_t *pframeinit)
 {
 	uint8_t err = 0;
 	if ((!pframeinit) || (!pframe)) {
-		// printf("\n%s-err:frame parameter error, parameter is null\r\n", pframe->frame_info.pname);
 		return B_ERROR;
 	}
 
@@ -13,16 +13,10 @@ uint8_t es_frame_init(b_frame_class_t *pframe, b_frame_t *pframeinit)
 	pframe->frame_info.head_len = pframeinit->head_len;
 	pframe->frame_info.end = pframeinit->end;
 	pframe->frame_info.end_len = pframeinit->end_len;
-	// printf("rin_addr_t %p size %d\n", &pframe->_frame_ring, pframe->_in_frame_buffer_size);
-	// printf("pname %s head_len %d end_len %d\n", pframe->frame_info.pname, pframe->frame_info.head_len, \
-		   pframe->frame_info.end_len);
 
 	err = ring_buf_init(&pframe->_frame_ring, pframe->_in_frame_buffer_size);
-	// printf("\nrhead %p tail %p write %p, read %p\n", pframe->_frame_ring.pHead, pframe->_frame_ring.pTail, \
-		   pframe->_frame_ring.pWrite, pframe->_frame_ring.pRead);
 	if (!err)
 		return B_SUCCESS;
-	// printf("\n%s-err:ring_buf_init err ring_buf init err\r\n", pframe->frame_info.pname);
 	return B_ERROR;
 }
 
@@ -64,9 +58,7 @@ uint8_t es_check_head(b_frame_class_t *pframe)
 	do {
 		read_ring_buf(&pframe->_frame_ring, &tmp, 1);
 		if (tmp == pframe->frame_info.head[i]) {
-			printf("tmp(%d) %x \n", i, tmp);
 			if (++i == pframe->frame_info.head_len) {
-				printf("%s %d B_SUCCESS\n", __func__, __LINE__);
 				return B_SUCCESS;
 			}
 		} else {
@@ -107,31 +99,26 @@ uint8_t es_check_frame(b_frame_class_t *pframe)
 	// printf("%s %d\n", __func__, __LINE__);
 	if (read_ring_buf(&pframe->_frame_ring, buf, len) != len)
 		return B_ERROR;
+	pframe->frame.len = len;
 	for (int i = 0; i < len; i++) {
 		current_xor ^= buf[i];
-		// printf("buf[%d] %x\n", i, buf[i]);
+		printf("buf[%d] %x\n", i, buf[i]);
 	}
 
-	// printf("%s %d current_xor %x\n", __func__, __LINE__, current_xor);
 	if (read_ring_buf(&pframe->_frame_ring, &xor, 1) != 1)
 		return B_ERROR;
-	// printf("%s %d\n", __func__, __LINE__);
 	if (current_xor == xor) {
-		// printf("%s %d\n", __func__, __LINE__);
 		memset(&pframe->frame.data.value, 0, sizeof(pframe->frame.data.value));
 		memcpy(&pframe->frame.data.value, buf, len);
 		return B_SUCCESS;
 	}
-	// printf("%s %d\n", __func__, __LINE__);
 	return B_ERROR;
 }
 
 uint8_t es_get_cmd_and_data(b_frame_class_t *pframe)
 {
-	// printf("%s %d\n", __func__, __LINE__);
 	if (es_get_cmd(pframe) != B_SUCCESS)
 		return B_ERROR;
-	// printf("%s %d\n", __func__, __LINE__);
 	if (es_check_frame(pframe) != B_SUCCESS)
 		return B_ERROR;
 	return B_SUCCESS;
diff --git a/Core/Src/protocol_lib/protocol.h b/Core/Src/protocol_lib/protocol.h
index e64a47c..192fd4b 100644
--- a/Core/Src/protocol_lib/protocol.h
+++ b/Core/Src/protocol_lib/protocol.h
@@ -19,7 +19,7 @@ typedef struct {
 } b_frame_t;
 
 struct gpio_cmd {
-	uint8_t group;
+	uint16_t group;
 	uint16_t pin_num;
 	uint8_t driection;
 	uint8_t value;
@@ -73,9 +73,15 @@ struct fan_control_t {
 	uint8_t duty;
 };
 
+struct spi_slv_w32_t {
+	uint32_t addr;
+	uint32_t value;
+};
+
 struct frame_data {
 	uint8_t is_valid;
 	uint8_t cmd;
+	uint16_t len;
 	union {
 		uint32_t value;
 		struct gpio_cmd gpio;
@@ -86,6 +92,7 @@ struct frame_data {
 		struct rtc_date_t rtc_date;
 		struct rtc_time_t rtc_time;
 		struct fan_control_t fan;
+		struct spi_slv_w32_t spislv32;
 	} data;
 };
 
@@ -117,9 +124,11 @@ typedef enum protocol_cmd_type {
 	CMD_SET_DATE = 0x96,
 	CMD_SET_TIME = 0x97,
 	CMD_SET_FAN_DUTY = 0x98,
+	CMD_SPI_SLV_WL = 0x99,
 	CMD_GET_DATE = 0xA6,
 	CMD_GET_TIME = 0xA7,
 	CMD_GET_FAN_DUTY = 0xa8,
+	CMD_SPI_SLV_RL = 0xa9,
 	CMD_RES = 0xb0
 }protocol_cmd_type_t;
 
diff --git a/Core/Src/stm32f4xx_it.c b/Core/Src/stm32f4xx_it.c
index f422ed0..472e34d 100644
--- a/Core/Src/stm32f4xx_it.c
+++ b/Core/Src/stm32f4xx_it.c
@@ -356,6 +356,14 @@ void USART3_IRQHandler(void)
   HAL_UART_IRQHandler(&huart3);
 }
 
+/**
+  * @brief This function handles USART3 global interrupt.
+
+void UART4_IRQHandler(void)
+{
+  HAL_UART_IRQHandler(&huart4);
+}
+*/
 /**
   * @brief This function handles RTC alarms A and B interrupt through EXTI line 17.
   */
@@ -412,6 +420,14 @@ void DMA2_Stream3_IRQHandler(void)
   /* USER CODE END DMA2_Stream3_IRQn 1 */
 }
 
+/**
+  * @brief This function handles USART6 global interrupt.
+  */
+void USART6_IRQHandler(void)
+{
+  HAL_UART_IRQHandler(&huart6);
+}
+
 /**
   * @brief This function handles Ethernet global interrupt.
   */
diff --git a/Makefile b/Makefile
index eb56e8f..1ce0f99 100644
--- a/Makefile
+++ b/Makefile
@@ -50,6 +50,7 @@ Core/Src/hf_power_process.c \
 Core/Src/hf_http_process.c \
 Core/Src/hf_gpio_process.c \
 Core/Src/hf_protocol_process.c \
+Core/Src/hf_spi_slv.c \
 Core/Src/protocol_lib/ringbuffer.c \
 Core/Src/protocol_lib/protocol.c \
 Core/Src/hf_i2c.c \
-- 
2.25.1

